;; -*- Lisp -*-
;; file xtramelt-opengpu.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2010, 2011 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
    [funded within OpenGPU french project: http://opengpu.net/ ]

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

(defun opengpudetect_handle_parallel_loop (curloopval :long loopix)
  (debug_msg curloopval "opengpudetect_handle_parallel_loop start curloopval")
  (let (
	(:loop curloop (loop_content curloopval))
	(curloopbodytuple (loop_body_tuple discr_multiple curloop)) 
	(curloopedgetuple (loop_exit_edges_tuple discr_multiple curloop))
	(:basic_block bbloophead (loop_header curloop))
	(:basic_block bblooplatch (loop_latch curloop))
	)
    (debug "opengpudetect_handle_parallel_loop curloop=" curloop 
	   " bbloophead=" bbloophead " with nbsucc=" (basicblock_nb_succ bbloophead)
	   " bblooplatch=" bblooplatch
	   " curloopbodytuple=" curloopbodytuple
	   " curloopedgetuple=" curloopedgetuple)
    ;; loop into tree-parloops.c & tree-ssa-loop-manip.c &
    ;; tree-ssa-loop-niter.c function try_get_loop_niter &
    ;; canonicalize_loop_ivs & number_of_iterations_exit
    (foreach_edge_bb_succs 
     (bbloophead)
     (:edge edgheadsuc)
     (debugedge "opengpudetect_handle_parallel_loop edgheadsuc" edgheadsuc)
     (debugbasicblock "opengpudetect_handle_parallel_loop edgheadsuc destbb"
		      (edge_dest_bb edgheadsuc))
     )
    (debuglong  "opengpudetect_handle_parallel_loop nbsucc bblooplatch" (basicblock_nb_succ bblooplatch))
    (debug_msg curloopbodytuple "opengpudetect_handle_parallel_loop parellelizable curloopbodytuple")
    (debug_msg curloopedgetuple "opengpudetect_handle_parallel_loop parellelizable curloopedgetuple")
    (foreach_in_multiple
     (curloopbodytuple)
     (curloopbody :long bodyix)
     (debug_msg curloopbody "opengpudetect_handle_parallel_loop curloopbody")
     (assert_msg "opengpudetect_handle_parallel_loop check curloopbody" (is_basicblock curloopbody))
     (eachgimple_in_basicblock
      ((basicblock_content curloopbody))
      (:gimple gimbody)
      (debuggimple "opengpudetect_handle_parallel_loop gimbody" gimbody)
      (match gimbody
	     (?(gimple_assign_single ?lhs ?rhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign single plain lhs" lhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign single plain rhs" rhs)
	       )
	     (?(gimple_assign_plus ?lhs ?rhs1 ?rhs2)
	       (debugtree "opengpudetect_handle_parallel_loop assign plus lhs" lhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign plus rhs1" rhs1)
	       (debugtree "opengpudetect_handle_parallel_loop assign plus rhs2" rhs2)
	       )
	     (?(gimple_assign_pointerplus ?lhs ?rhs1 ?rhs2)
	       (debugtree "opengpudetect_handle_parallel_loop assign pointerplus lhs" lhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign pointerplus rhs1" rhs1)
	       (debugtree "opengpudetect_handle_parallel_loop assign pointerplus rhs2" rhs2)
	       )
	     (?(gimple_assign_mult ?lhs ?rhs1 ?rhs2)
	       (debugtree "opengpudetect_handle_parallel_loop assign mult lhs" lhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign mult rhs1" rhs1)
	       (debugtree "opengpudetect_handle_parallel_loop assign mult rhs2" rhs2)
	       )
	     (?(gimple_assign_binaryop ?lhs ?rhs1 ?rhs2 ?opcod)
	       (debugtree "opengpudetect_handle_parallel_loop assign binaryop lhs" lhs)
	       (debugtree "opengpudetect_handle_parallel_loop assign binaryop rhs1" rhs1)
	       (debugtree "opengpudetect_handle_parallel_loop assign binaryop rhs2" rhs2)
	       (debuglong "opengpudetect_handle_parallel_loop assign binaryop opcod" opcod)
	       (code_chunk 
		debugopcodnam
		#{/*$DEBUGOPCODNAM*/ const int $DEBUGOPCODNAM#_lin = __LINE__;
		debugeprintfline($DEBUGOPCODNAM#_lin,
				 "opengpudetect_handle_parallel_loop assign binaryopname %s",
				 ($OPCOD>=0 && $OPCOD<MAX_TREE_CODES)?
				 tree_code_name[$OPCOD]:"??");
		}#)
	       (assert_msg "opengpudetect_handle_parallel_loop unexpected binaryop") 
	       )
	     (?_
	      ()))
      )
     )
  (debug_msg curloopval "opengpudetect_handle_parallel_loop end curloopval")
  ))

(defun opengpudetect_gate (pass)
  (debug_msg pass "opengpudetect_gate start")
  (debug_msg pass "opengpudetect_gate end")
  (return :true)
)

(defun opengpudetect_exec (pass)
  (debug_msg pass "opengpudetect_exec start")
  (let ( (:long passcounter 0)
	 )
    (code_chunk 
     incrpasscount #{ /* $INCRPASSCOUNT */
     static long $INCRPASSCOUNT#_count		       ;
     $INCRPASSCOUNT#_count++			       ;
     $PASSCOUNTER = $INCRPASSCOUNT#_count	       ;
     melt_cbreak ("opengpudetect_exec $INCRPASSCOUNT") ;
     /* the dbgprintf goes to the dump_file */
     dbgprintf ("opengpudetect_exec start $PASSCOUNTER= %ld", $PASSCOUNTER) ;
     }#)
    (code_chunk 
     dbgcfun #{ /* $dbgcfun :: */
     debugeprintf("opengpudetect_exec start cfun=%p cfg=%p passcounter #%ld", 
		  (void*)cfun, cfun?cfun->cfg:NULL, $PASSCOUNTER) ; 
     }#) 
    (debug_msg pass "opengpudetect_exec before each_bb_cfun")
    (with_cfun_decl
     ()
     (:tree fundecl)
     (debugtree "opengpudetect_exec fundecl" fundecl)
     (each_bb_current_fun
      ()
      (:basic_block bb)
      (debugbasicblock "opengpudetect_exec bb" bb)
      ))
;;;
    (debug_msg pass "opengpudetect_exec after each_bb_cfun before each_loop")
    (each_loop 
     ()
     (:loop curloop :long loopix)
     (debugloop curloop  "opengpudetect_exec curloop")
     (debuglong "opengpudetect_exec loopix" loopix)
     (debuglong "opengpudetect_exec computed loopnum"
		(loop_index_number curloop))
     (debuglong "opengpudetect_exec computed loopdepth" 
		(loop_depth curloop))
     (if (loop_can_be_parallel curloop)
	 (let ( (curloopval (make_loop discr_loop curloop))
	       )
	   (debug_msg curloopval  "opengpudetect_exec curloopval can be parallel!!!")
	   (opengpudetect_handle_parallel_loop curloopval)
	   (debug_msg curloopval  "opengpudetect_exec after opengpudetect_handle_parallel_loop")
	   )
       (debugloop curloop "opengpudetect_exec curloop is not parallel!!!")
       )
     )
    ;;
    (debug_msg pass "opengpudetect_exec end")
    (return :true)
    ))


;; the opengpu passes translate some Gimple into OpenCL.
(defun install_opengpu_passes ()
  (let ( (opengpudetect_pass
	  (instance class_gcc_gimple_pass
		    :named_name '"meltopengpu_detect"
		    :gccpass_gate opengpudetect_gate
		    :gccpass_exec opengpudetect_exec
		    :gccpass_data (make_maptree discr_map_trees 100)
		    :gccpass_properties_required (list '"ssa" '"cfg")
		    :gccpass_todo_flags_finish 
		     () ;  (list  '"dump_func" '"dump_cgraph")
		    ))
	 )
;    (install_melt_gcc_pass opengpudetect_pass "before" "vect" 0)
    (install_melt_gcc_pass opengpudetect_pass "before" "ivcanon" 0)
    ))

(defun opengpu_docmd (cmd moduldata)
  (let ( (:long optimlevel 0)
	 (:long withgraphite 0)
	 (:long withparallelizeall 0)
	 )
    (code_chunk getoptimflags
		#{ /* $GETOPTIMFLAGS */
		$OPTIMLEVEL = (long) optimize			  ;
		$WITHGRAPHITE = (long) flag_graphite		  ;
		$WITHPARALLELIZEALL = (long) flag_loop_parallelize_all ;
		}#)
    (cond 
     ( (<i optimlevel 2)
       (warningmsg_plain 
	"opengpu MELT mode requires -O2 optimization at least"))
     ( (==i withgraphite 0)
       (warningmsg_plain
	"opengpu MELT mode requires -fgraphite"))
     ( (==i withparallelizeall 0)
       (warningmsg_plain
	"opengpu MELT mode requires -floop-parallelize-all"))
     (:else
      (install_opengpu_passes)
      (return :true)))
    ))

(definstance opengpu_mode
  class_melt_mode
  :named_name '"opengpu"
  :meltmode_help '"transforming some numerical loops [with -O2 at least]
into OpenCL code running on GPU"
  :meltmode_fun opengpu_docmd
)

(install_melt_mode opengpu_mode)
;; eof xtramelt-opengpu.melt
