;; -*- Lisp -*-
;; file xtramelt-ana-base.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
                and Jeremie Salvucci  <jeremie.salvucci@free.fr>
                and Pierre Vittet  <piervit@pvittet.com>
                and Romain Geissler  <romain.geissler@gmail.com>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to ana-base.melt and 
;; to the generated file  ana-base*.c

;; a class containing the analysis state
(defclass class_analysis_state
  :super class_proped
  :fields (
))

(defprimitive install_melt_gcc_pass 
  (:value pass :cstring positioning refpassname :long refpassnum) 
  :void
  :doc #{Install a GCC pass coded in MELT. The $PASS should be an
  object, instance of a sub-class of $CLASS_GCC_PASS, e.g. of
  $CLASS_GCC_GIMPLE_PASS. The $POSITIONNING is "before"
  or "after". The reference pass is given thru $REFPASSNAME and
  $REFPASSNUM. Usually $INSTALL_MELT_GCC_PASS is called from a mode
  initializer.}#
  #{ meltgc_register_pass ($pass, $positioning, $refpassname, $refpassnum); 
  }#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; gimple & tree related primitives

(defprimitive is_gimple (v) :long
   :doc #{Test if value $V is a boxed gimple.}#
   #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_GIMPLE)}# )

(defprimitive make_gimple (discr :gimple g) :value
  :doc #{Make a boxed gimple of given $DISCR and gimple $G.}#
  #{(meltgc_new_gimple((meltobject_ptr_t)($discr),($g)))}# )

(defprimitive gimple_content (v) :gimple
  :doc #{Retrieve the gimple stuff inside boxed gimple $V or else NULL}#
  #{(melt_gimple_content((melt_ptr_t)($v)))}# )

(defprimitive ==g (:gimple g1 g2) :long
  :doc #{Equality of gimples $G1 & $G2}#
  #{(($g1) == ($g2))}#)

(defprimitive null_gimple () 
  :gimple 
  :doc #{The null gimple.}#
   #{((gimple)0)}#)

(defprimitive gimple_seq_of_basic_block (:basic_block bb) :gimple_seq
  :doc #{Retrieve the gimple seq inside basic block $BB or null.}#
  #{(($bb)?bb_seq(($bb)):NULL)}#)

(defprimitive gimple_seq_first_stmt (:gimple_seq gs) :gimple
  :doc #{Retrieve the first gimple inside basic block $BB or null.}#
  #{(($GS)?gimple_seq_first_stmt(($GS)):NULL)}#)

(defprimitive gimple_seq_last_stmt (:gimple_seq gs) :gimple
  :doc #{Retrieve the last gimple inside basic block $BB or null.}#
  #{(($GS)?gimple_seq_last_stmt(($GS)):NULL)}#)

;;; copy an unboxed gimple_copy
(defprimitive gimple_copy (:gimple g) :gimple
  :doc #{Copy gimple stuff $G.}#
  #{ (($g)?gimple_copy($g):NULL) }#)

;;;;;;;;;;;;;;;; map associating GCC gimple-s to non-null MELT values
(defprimitive is_mapgimple (map) :long
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPGIMPLES) }#)
(defprimitive mapgimple_size (map) :long
 #{ (melt_size_mapgimples((struct meltmapgimples_st*)($map))) }#)
;; primitive to get the attribute count of a mapgimple
(defprimitive mapgimple_count (map) :long
  #{ (melt_count_mapgimples((struct meltmapgimples_st*)($map))) }# )
;; get an entry in a mapgimple from a C gimple
(defprimitive mapgimple_get (map :gimple bb) :value
  #{(melt_get_mapgimples(($map), ($bb)))}#)
;; primitive for making a new map of gimples
(defprimitive make_mapgimple (discr :long len) :value
 #{(meltgc_new_mapgimples((meltobject_ptr_t) ($discr), ($len)))}#)
;; primitive for putting into a map of gimples
(defprimitive mapgimple_put (map :gimple key :value val) :void
  #{melt_put_mapgimples(($map), 
			($key), (melt_ptr_t) ($val))}#)
;; primivite for removing from a map of gimples
(defprimitive mapgimple_remove (map :gimple key) :void
  #{meltgc_remove_mapgimples(($map), ($key))}#)

;; primitive to get the nth gimple of a mapgimple
(defprimitive mapgimple_nth_attr (map :long n) :gimple
  #{(melt_nthattr_mapgimples((struct meltmapgimples_st*)($map), (int)($n)))}#)
;; primitive to get the nth value of a mapobject
(defprimitive mapgimple_nth_val (map :long n) :value
  #{(melt_nthval_mapgimples((struct meltmapgimples_st*)($map), (int)($n)))}# )
;; iterator inside mapgimple
(defciterator foreach_mapgimple 
  (gimap)				; startformals
  eachgimap 				;state symbol
  (:gimple att :value val)	;local formals
  :doc #{Iterate inside the $GIMAP value -a map from gimples to values- for each gimple $ATT and value $VAL.}#
  ;; before expansion
  #{
   /*$eachgimap*/ int $eachgimap#_rk=0;
   for ($eachgimap#_rk=0;
        $eachgimap#_rk<melt_size_mapgimples((struct meltmapgimples_st*)($gimap));
	$eachgimap#_rk++) {
   gimple $eachgimap#_tr=melt_nthattr_mapgimples((struct meltmapgimples_st*)($gimap), $eachgimap#_rk);
   if (!$eachgimap#_tr) continue;
   $att = $eachgimap#_tr;
   $val =melt_nthval_mapgimples((struct meltmapgimples_st*)($gimap), 
				   $eachgimap#_rk);
   }#
  ;;after expansion
   #{
   } /*end $eachgimap*/
   }#
  )


(defprimitive make_edge (discr :edge edg) :value
  :doc #{Box the edge stuff $EDG with discriminant $DISCR as a boxed edge value.}#
  #{(meltgc_new_edge((meltobject_ptr_t)($DISCR),($EDG)))}# )

(defprimitive edge_content (val) :edge
  :doc #{Retrieve the edge stuff from boxed edge value $VAL.}#
  #{(melt_edge_content((melt_ptr_t)($VAL)))}# )

(defprimitive is_edge (val) :long
  :doc #{Test that $VAL is indeed a boxed edge value.}#
  #{(($VAL) && melt_magic_discr ($VAL) == MELTOBMAG_EDGE)}#)

(defprimitive ==e (:edge e1 e2) :long
  :doc #{Test physical equality, that is identity, of edge stuff $E1 and $E2.}#
  #{(($E1) == ($E2))}#)

(defprimitive null_edge () :edge
  :doc #{The null edge stuff.}#
   #{((edge)0)}#)


;;;;;;;;;;;;;;;; map associating GCC edge-s to non-null MELT values
(defprimitive is_mapedge (map) :long
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPEDGES) }#)
(defprimitive mapedge_size (map) :long
 #{ (melt_size_mapedges((struct meltmapedges_st*)($map))) }#)
;; primitive to get the attribute count of a mapedge
(defprimitive mapedge_count (map) :long
  #{ (melt_count_mapedges((struct meltmapedges_st*)($map))) }# )
;; get an entry in a mapedge from a C edge
(defprimitive mapedge_get (map :edge bb) :value
  #{(melt_get_mapedges(($map), ($bb)))}#)
;; primitive for making a new map of edges
(defprimitive make_mapedge (discr :long len) :value
 #{(meltgc_new_mapedges((meltobject_ptr_t) ($discr), ($len)))}#)
;; primitive for putting into a map of edges
(defprimitive mapedge_put (map :edge key :value val) :void
  #{melt_put_mapedges(($map), 
		      ($key), (melt_ptr_t) ($val))}#)
;; primivite for removing from a map of edges
(defprimitive mapedge_remove (map :edge key) :void
  #{meltgc_remove_mapedges(($map), ($key))}#)

;; primitive to get the nth edge of a mapedge
(defprimitive mapedge_nth_attr (map :long n) :edge
  #{(melt_nthattr_mapedges((struct meltmapedges_st*)($map), (int)($n)))}#)
;; primitive to get the nth value of a mapedge
(defprimitive mapedge_nth_val (map :long n) :value
  #{(melt_nthval_mapedges((struct meltmapedges_st*)($map), (int)($n)))}# )
;; iterator inside mapedge
(defciterator foreach_mapedge 
  (edgmap)				; startformals
  eachedgemap 				;state symbol
  (:edge att :value val)	;local formals
  ;; before expansion
  #{
   /*$EACHEDGEMAP*/ int $EACHEDGEMAP#_rk=0;
   for ($EACHEDGEMAP#_rk=0;
        $EACHEDGEMAP#_rk<melt_size_mapedges((struct meltmapedges_st*)($EDGMAP));
	$EACHEDGEMAP#_rk++) {
   edge $EACHEDGEMAP#_tr=melt_nthattr_mapedges((struct meltmapedges_st*)($EDGMAP), $EACHEDGEMAP#_rk);
   if (!$EACHEDGEMAP#_tr) continue;
   $att = $EACHEDGEMAP#_tr;
   $val =melt_nthval_mapedges((struct meltmapedges_st*)($EDGMAP), 
				   $EACHEDGEMAP#_rk);
   }#
  ;;after expansion
   #{
   } /*end $EACHEDGEMAP*/
   }#
  )

;;;;;;;;;;;;;;;; map associating GCC loop-s to non-null MELT values
(defprimitive is_maploop (map) :long
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPLOOPS) }#)
(defprimitive maploop_size (map) :long
 #{ (melt_size_maploops((struct meltmaploops_st*)($map))) }#)
;; primitive to get the attribute count of a maploop
(defprimitive maploop_count (map) :long
  #{ (melt_count_maploops((struct meltmaploops_st*)($map))) }# )
;; get an entry in a maploop from a C loop
(defprimitive maploop_get (map :tree bb) :value
  #{(melt_get_maploops(($map), ($bb)))}#)
;; primitive for making a new map of loops
(defprimitive make_maploop (discr :long len) :value
 #{(meltgc_new_maploops((meltobject_ptr_t) ($discr), ($len)))}#)
;; primitive for putting into a map of loops
(defprimitive maploop_put (map :tree key :value val) :void
  #{melt_put_maploops(($map), 
		      ($key), (melt_ptr_t) ($val))}#)
;; primivite for removing from a map of loops
(defprimitive maploop_remove (map :tree key) :void
  #{meltgc_remove_maploops(($map), ($key))}#)

;; primitive to get the nth loop of a maploop
(defprimitive maploop_nth_attr (map :long n) :loop
  #{(melt_nthattr_maploops(($map), (int)($n)))}#)
;; primitive to get the nth value of a maploop
(defprimitive maploop_nth_val (map :long n) :value
  #{(melt_nthval_maploops(($map), (int)($n)))}# )
;; iterator inside maploop
(defciterator foreach_maploop 
  (loomap)				; startformals
  eachloomap 				;state symbol
  (:loop att :value val)	;local formals
  ;; before expansion
  #{
   /*$eachloomap*/ int $eachloomap#_rk=0;
   for ($eachloomap#_rk=0;
        $eachloomap#_rk<melt_size_maploops((struct meltmaploops_st*)($loomap));
	$eachloomap#_rk++) {
   loop_p $eachloomap#_tr=melt_nthattr_maploops((struct meltmaploops_st*)($loomap), $eachloomap#_rk);
   if (!$eachloomap#_tr) continue;
   $att = $eachloomap#_tr;
   $val =melt_nthval_maploops((struct meltmaploops_st*)($loomap), 
				   $eachloomap#_rk);
   }#
  ;;after expansion
   #{
   } /*end $eachloomap*/
   }#
  )


;; iterator on all the loops
(defciterator each_loop
  ()
  eachloop
  (:loop curloop :long loopix)
  ;; before expansion
  #{ /*$EACHLOOP +*/ 
   loop_iterator $EACHLOOP#_li = {};
   FOR_EACH_LOOP($EACHLOOP#_li, $CURLOOP, 0) {
     $LOOPIX = $CURLOOP->num;
  }#
  ;;after expansion
   #{ } /*$EACHLOOP -*/
   }#
)


;; debugloop is ok even for nil
(defprimitive debugloop (:loop lo :cstring msg) :void
  #{ do {debugeprintfnonl("debugloop %s @%p ", $MSG, (void*)$LO);
  if (flag_melt_debug) { if ($LO) flow_loop_dump($LO, stderr, NULL, 1); }
  fputc('\n',stderr); 
 }while(0)  }#
)



(defprimitive loop_can_be_parallel (:loop lo) :long
  #{ (($LO) && ($LO)->can_be_parallel) }#)

(defprimitive loop_header (:loop lo) :basic_block
  :doc #{The header if any of loop $LO}#
  #{($LO)?(($LO)->header):(basic_block)0}#)

(defprimitive loop_latch (:loop lo) :basic_block
  :doc #{The latch if any of loop $LO}#
  #{($LO)?(($LO)->latch):(basic_block)0}#)

(defprimitive loop_inner (:loop lo) :loop
  :doc #{The inner if any of loop $LO}#
  #{($LO)?(($LO)->inner):(loop)0}#)

(defprimitive loop_index_number (:loop lo) :long
  :doc #{The index number if any of loop $LO}#
  #{($LO)?(($LO)->num):0L}#)

(defprimitive loop_depth (:loop lo) :long
  :doc #{The depth of loop $LO}#
  #{($LO)?loop_depth($LO):0L}#)

(defprimitive number_of_loops () :long 
  :doc #{Return the number of loops in current_loops.}#
  #{number_of_loops ()}#)

;; match a gimple value & extract the gimple of it
(defcmatcher gimpleval
  (gv)					;match & no ins
  (:gimple g) 				;outs
  gimpsta				;statesymb
  :doc #{Match a gimple boxed value $GV and extract its gimple stuff $G.
 As operator, build a boxed gimple from $G.}#
  ;; test expansion
  #{ (melt_magic_discr((melt_ptr_t)($gv)) == MELTOBMAG_GIMPLE) }#
  ;; fill expansion
  #{ $g = melt_gimple_content(((melt_ptr_t)($gv)));
  }#
  ;; operator expansion
  #{ (meltgc_new_gimple((meltobject_ptr_t)NULL, ($g))) }#
)

;; match or build a gimple single assign
(defcmatcher gimple_assign_single
  (:gimple ga)				;match
  ;; outputs
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )
  gimpassi
  :doc #{Match gimple $GA as a single assign into tree $LHS of tree $RHS, or build such an assign.}#
  ;; test expansion
  #{/*$gimpassi test*/ ($ga && gimple_assign_single_p ($ga))}#
  ;;fill expansion
  #{/*$gimpassi fill*/
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
   }#
  ;; operator expansion
  #{($LHS != NULL_TREE && $RHS != NULL_TREE)?gimple_build_assign(($LHS),($RHS)):((gimple)0)}#
)


;; match a gimple cast assign
(defcmatcher gimple_assign_cast
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpascs
  :doc #{Match gimple $GA as a casting assign into tree $LHS of tree $RHS. 
See also $GIMPLE_BUILD_ASSIGN_CONVERT, $GIMPLE_BUILD_ASSIGN_VIEW_CONVERT, $GIMPLE_BUILD_ASSIGN_FLOAT.}#
  ;;test expansion
  #{/*$gimpascs test*/($ga && gimple_assign_cast_p ($ga))}#
  ;;fill expansion
  #{/*$gimpascs fill*/
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
  }#
)

(defprimitive gimple_build_assign_convert (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and convert to $TLHS the tree $TRHS, if both are non-null.}#
  #{($TLHS != (tree)0 && $TRHS != (tree)0)?gimple_build_assign_with_ops(CONVERT_EXPR,($TLHS),($TRHS), NULL):((gimple)0)}#
)

(defprimitive gimple_build_assign_view_convert (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and view convert to $TLHS the tree $TRHS, if both are non-null.}#
  #{($TLHS != (tree)0 && $TRHS != (tree)0)?gimple_build_assign_with_ops(VIEW_CONVERT_EXPR,($TLHS),($TRHS), NULL):((gimple)0)}#
)

(defprimitive gimple_build_assign_fix_trunc (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and fixed truncation to $TLHS the tree $TRHS, if both are non-null.}#
  #{($TLHS != (tree)0 && $TRHS != (tree)0)?gimple_build_assign_with_ops(FIX_TRUNC_EXPR,($TLHS),($TRHS), NULL):((gimple)0)}#
)

(defprimitive gimple_build_assign_float (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign the conversion to float $TLHS the tree $TRHS, if both are non-null.}#
  #{($TLHS != (tree)0 && $TRHS != (tree)0)?gimple_build_assign_with_ops(FLOAT_EXPR,($TLHS),($TRHS), NULL):((gimple)0)}#
)

;; match a gimple copy assign
(defcmatcher gimple_assign_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  ;;test expansion
  #{($ga && gimple_assign_copy_p ($ga))}#
  ;;fill expansion
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
  }#
)

;; match a gimple copy assign with ssa name
(defcmatcher gimple_assign_ssa_name_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  ;;test expansion
   #{($ga && gimple_assign_ssa_name_copy_p ($ga))}#
  ;;fill expansion
   #{
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
   }#
)

;; match a gimple unary nop assign
(defcmatcher gimple_assign_unary_nop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  :doc #{$GIMPLE_ASSIGN_UNARY_NOP match or build an unary nop assign into $LHS of $RHS.}# 
  ;;test expansion
  #{($ga && gimple_assign_unary_nop_p ($ga))}#
  ;;fill expansion
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
  }#
  ;; operator expansion
  #{gimple_build_assign_with_ops(NOP_EXPR, $LHS, $RHS, NULL_TREE)}#
)

;;; match a gimple assign with unary minus X = -Y
(defcmatcher gimple_assign_unary_minus
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gaum
  ;; test
  #{
       ($ga && gimple_expr_code ($ga) == NEGATE_EXPR)
  }#
  ;; fill
  #{
       $lhs = gimple_assign_lhs ($ga);
       $rhs = gimple_assign_rhs1 ($ga);
  }#
  ;; operator expansion
  #{gimple_build_assign_with_ops(NEGATE_EXPR, $LHS, $RHS, NULL_TREE)}#
  )

;;;; match a gimple assign with addition ie X = Y + Z

(defcmatcher gimple_assign_plus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasplus
  :doc #{$GIMPLE_ASSIGN_PLUS match or build addition into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == PLUS_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(PLUS_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with substraction ie X = Y - Z
(defcmatcher gimple_assign_minus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasminus
  :doc #{$GIMPLE_ASSIGN_MINUS match or build substraction into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == MINUS_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(MINUS_EXPR, $LHS, $RHS1, $RHS2)}#
)


(defcmatcher gimple_assign_pointerplus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gaspplus
  :doc #{$GIMPLE_ASSIGN_POINTERMINUS match or build pointer addition into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{ $ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == POINTER_PLUS_EXPR }#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
  }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(POINTER_PLUS_EXPR, $LHS, $RHS1, $RHS2)}#
)


;;;; match a gimple assign with multiplication ie X = Y * Z

(defcmatcher gimple_assign_mult
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_MULT match or build multiplication into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == MULT_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(MULT_EXPR, $LHS, $RHS1, $RHS2)}#
)



;;;; match a gimple assign with trunc division ie X = Y /trunc Z
(defcmatcher gimple_assign_trunc_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gastdiv
  :doc #{$GIMPLE_ASSIGN_TRUNC_DIC match or build truncated division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == TRUNC_DIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(TRUNC_DIV_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with ceil division ie X = Y /ceil Z
(defcmatcher gimple_assign_ceil_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gascdiv
  :doc #{$GIMPLE_ASSIGN_TRUNC_DIC match or build ceiling division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == CEIL_DIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(CEIL_DIV_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with floor division ie X = Y /floor Z
(defcmatcher gimple_assign_floor_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasfdiv
  :doc #{$GIMPLE_ASSIGN_TRUNC_DIV match or build floor division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == FLOOR_DIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(FLOOR_DIV_EXPR, $LHS, $RHS1, $RHS2)}#
)


;;;; match a gimple assign with round division ie X = Y /round Z
(defcmatcher gimple_assign_round_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrdiv
  :doc #{$GIMPLE_ASSIGN_ROUND_DIV match or build rounding division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == ROUND_DIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(ROUND_DIV_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with real division ie X = Y /real Z
(defcmatcher gimple_assign_rdiv
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrediv
  :doc #{$GIMPLE_ASSIGN_RDIV match or build reaol division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == RDIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(RDIV_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with exact division ie X = Y /exact Z
(defcmatcher gimple_assign_exact_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasxdiv
  :doc #{$GIMPLE_ASSIGN_EXACT_DIV match or build exact division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == EXACT_DIV_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(EXACT_DIV_EXPR, $LHS, $RHS1, $RHS2)}#
)


;;;;;;;;;;;;;;;;
;;;; match a gimple assign with trunc remainder ie X = Y %trunc Z
(defcmatcher gimple_assign_trunc_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gastmod
  :doc #{$GIMPLE_ASSIGN_TRUNC_MOD match or build truncated modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == TRUNC_MOD_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(TRUNC_MOD_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with ceil remainder ie X = Y %ceil Z
(defcmatcher gimple_assign_ceil_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gascmod
  :doc #{$GIMPLE_ASSIGN_TRUNC_MOD match or build ceil modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == CEIL_MOD_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(CEIL_MOD_EXPR, $LHS, $RHS1, $RHS2)}#
)

;;;; match a gimple assign with floor remainder ie X = Y %floor Z
(defcmatcher gimple_assign_floor_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_FLOOR_MOD match or build floor modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == FLOOR_MOD_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(FLOOR_MOD_EXPR, $LHS, $RHS1, $RHS2)}#
)


;;;; match a gimple assign with round remainder ie X = Y %round Z
(defcmatcher gimple_assign_round_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_ROUND_MOD match or build rounded modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == ROUND_MOD_EXPR)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops(ROUND_MOD_EXPR, $LHS, $RHS1, $RHS2)}#
)



;;; match a gimple assign binary op
(defcmatcher gimple_assign_binaryop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   :long opcode
   )
  gasbinop
  :doc #{$GIMPLE_ASSIGN_BINARYOP match or build a binary operator of $OPCODE into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{($ga && is_gimple_assign($ga) && gimple_num_ops($ga) >= 3)}#
  ;; fill
  #{
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   $opcode = gimple_assign_rhs_code($ga);
   }# 
  ;; operator expansion
  #{gimple_build_assign_with_ops($OPCODE, $LHS, $RHS1, $RHS2)}#
)

;;;;;;;;;;;;;;;;
;;; match a gimple cond less or equal
(defcmatcher gimple_cond_lessequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_LESSEQUAL match or build a <= condition between $LHS and $RHS.}#
  ;; test expansion
  #{($gc && gimple_code($gc)==GIMPLE_COND 
     && gimple_cond_code($gc)==LE_EXPR)}#
  ;; fill expansion
  #{
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }# 
  ;; operator expansion
  #{gimple_build_cond(LE_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;; match a gimple cond less 
(defcmatcher gimple_cond_less
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_LESSEQUAL match or build a < condition between $LHS and $RHS.}#
  ; test expansion
  #{($gc && gimple_code($gc)==GIMPLE_COND
     && gimple_cond_code($gc)==LT_EXPR)}#
  ;; fill expansion
  #{
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }# 
  ;; operator expansion
  #{gimple_build_cond(LT_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;;;;;;;;;;;;;;;
;;; match a gimple cond not equal
(defcmatcher gimple_cond_notequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_LESSEQUAL match or build a != condition between $LHS and $RHS.}#
  ;; test expansion
  #{($gc && gimple_code($gc)==GIMPLE_COND 
     && gimple_cond_code($gc)==NE_EXPR)}#
  ;; fill expansion
  #{
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }#
  ;; operator expansion
  #{gimple_build_cond(NE_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple_cond equal
(defcmatcher gimple_cond_equal
  (:gimple gc)
  (:tree lhs
   :tree rhs)
  gce
  :doc #{$GIMPLE_COND_EQUAL match or build a == condition between $LHS and $RHS.}#
  ;; test expansion
  #{
       ($gc &&
	gimple_code ($gc) == GIMPLE_COND &&
	gimple_cond_code ($gc) == EQ_EXPR)
  }#
  ;; fill expansion
  #{
       $lhs = gimple_cond_lhs ($gc);
       $rhs = gimple_cond_rhs ($gc);
  }#
  ;; operator expansion
  #{gimple_build_cond(EQ_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple cond greater
(defcmatcher gimple_cond_greater
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_GREATER match or build a > condition between $LHS and $RHS.}#
  ;; test expansion
  #{($gc && gimple_code($gc)==GIMPLE_COND 
      && gimple_cond_code($gc)==GT_EXPR)}#
  ;; fill expansion
  #{
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }# 
  ;; operator expansion
  #{gimple_build_cond(GT_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple_cond greater or equal
(defcmatcher gimple_cond_greater_or_equal
  (:gimple gc)
  (:tree lhs
   :tree rhs)
  gcgoe
  :doc #{$GIMPLE_COND_GREATER match or build a >= condition between $LHS and $RHS.}#
  ;; test
  #{
       ($gc && 
        gimple_code ($gc) == GIMPLE_COND && 
        gimple_cond_code ($gc) == GE_EXPR)
  }#
  ;; fill
  #{
       $lhs = gimple_cond_lhs ($gc);
       $rhs = gimple_cond_rhs ($gc);
  }#
  ;; operator expansion
  #{gimple_build_cond(GE_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;; match a gimple cond true
(defcmatcher gimple_cond_true
  (:gimple gc)
  ()
  gimpcondtr
  ;;test
  #{/*$gimpcondtr ? */ ($gc && gimple_code($gc)==GIMPLE_COND 
     && gimple_cond_true_p($gc))}#
  ;;fill
  #{ /*$gimpcondtr !*/
  }# )


;; match a gimple cond false
(defcmatcher gimple_cond_false
  (:gimple gc)
  ()
  gimpcondtr
  ;;test
  #{/*$gimpcondtr ?*/ ($gc && gimple_code($gc)==GIMPLE_COND
	 && gimple_cond_false_p($gc))}# )


;; rarely used pattern to extract the true & false labels. These are
;; often null!
(defcmatcher gimple_cond_with_true_false_labels
  (:gimple gc)
  (:tree truelab falselab)
  gimpcondtrlab
  ;; test
  #{/*$gimpcondtrlab ?*/ ($gc && gimple_code($gc)==GIMPLE_COND)}#
  ;;fill
  #{
   $truelab = gimple_cond_true_label($gc);
   $falselab = gimple_cond_false_label($gc);
   }#
)

;; pattern to extract the true & false edges of a gimple_cond.
(defcmatcher gimple_cond_with_edges
  (:gimple gc)
  (:edge truedge falsedge)
  gimpcondtredges
  ;; test
  #{/*$gimpcondtredges ?*/  ($gc && gimple_code($gc)==GIMPLE_COND)}#
  ;;fill
  #{ /*$gimpcondtredges !*/
  extract_cond_bb_edges ((gimple_bb ($gc)), &($truedge), &($falsedge));
  }#)

;;; iterate on each argument of a call function
(defciterator foreach_argument_of_gimple_call
  (:gimple function_call)
  eaocf
  (:tree argument)
  #{
       /* before $EAOCF */

       int $EAOCF#_i = 0;

       if ($function_call&&  gimple_code($function_call) == GIMPLE_CALL)
       {
           int $EAOCF#_n = gimple_call_num_args ($function_call);

           for ($EAOCF#_i = 0; 
		$EAOCF#_i < $EAOCF#_n; 
                $EAOCF#_i++)
           {
               $argument = gimple_call_arg ($function_call, $EAOCF#_i);
  }#

  #{
        /* after $EAOCF */
           }
        }
  }#)


;;; match a gimple call to a direct function of any matched arity
(defcmatcher gimple_call
  (:gimple gc)
  (:tree lhs
	 fndecl
   :long nbargs
   )
  gimpcall
  ;; test 
  #{/*$gimpcall ?*/($gc && gimple_code($gc)==GIMPLE_CALL)}#
  ;; fill
  #{ /*$gimpcall !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $nbargs = gimple_call_num_args($gc);
  }# )

;; match a gimple call to a direct function of arity 1 exactly
(defcmatcher gimple_call_1
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0)
  gimp1call
  ;; test
  #{/*$gimp1call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==1)}#
  ;; fill
  #{ /*$gimp1call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   }#)

;; match a gimple call to a direct function of arity 1 or more
(defcmatcher gimple_call_1_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
   :long nbargs)
  gimp1calm
  ;; test
  #{/*$gimp1calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=1)}#
  ;; fill
  #{ /*$gimp1calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $nbargs = gimple_call_num_args($gc);
   }#)

;; match a gimple call to a direct function of arity 2 exactly
(defcmatcher gimple_call_2
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1)
  gimp2call
  ;; test
  #{/*$gimp2call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==2)}#
  ;; fill
  #{ /*$gimp2call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   }#)

;; match a gimple call to a direct function of arity 2 or more
(defcmatcher gimple_call_2_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
   :long nbargs)
  gimp2calm
  ;; test
  #{/*$gimp2calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=2)}#
  ;; fill
  #{ /*$gimp2calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;; match a gimple call to a direct function of arity 3 exactly
(defcmatcher gimple_call_3
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2)
  gimp3call
  ;; test
  #{/*$gimp3call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==3)}#
  ;; fill
  #{ /*$gimp3call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   }#)

;; match a gimple call to a direct function of arity 3 or more
(defcmatcher gimple_call_3_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
   :long nbargs
	 )
  gimp3calm
  ;; test
  #{/*$gimp3calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=3)}#
  ;; fill
  #{ /*$gimp3calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;; match a gimple call to a direct function of arity 4 exactly
(defcmatcher gimple_call_4
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3)
  gimp4call
  ;; test
  #{/*$gimp4call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==4)}#
  ;; fill
  #{ /*$gimp4call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   }#)

;; match a gimple call to a direct function of arity 4 or more
(defcmatcher gimple_call_4_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
   :long nbargs
	 )
  gimp4calm
  ;; test
  #{/*$gimp4calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=4)}#
  ;; fill
  #{ /*$gimp4calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $nbargs = gimple_call_num_args($gc);
   }#)
  
;;;;
;; match a gimple call to a direct function of arity 5 exactly
(defcmatcher gimple_call_5
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4)
  gimp5call
  ;; test
  #{/*$gimp5call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==5)}#
  ;; fill
  #{ /*$gimp5call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   }#)

;; match a gimple call to a direct function of arity 5 or more
(defcmatcher gimple_call_5_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
   :long nbargs
	 )
  gimp5calm
  ;; test
  #{/*$gimp5calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=5)}#
  ;; fill
  #{ /*$gimp5calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;;
;; match a gimple call to a direct function of arity 6 exactly
(defcmatcher gimple_call_6
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5)
  gimp6call
  ;; test
  #{/*$gimp6call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==6)}#
  ;; fill
  #{ /*$gimp6call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   }#)

;; match a gimple call to a direct function of arity 6 or more
(defcmatcher gimple_call_6_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
   :long nbargs
	 )
  gimp6calm
  ;; test
  #{/*$gimp6calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=6)}#
  ;; fill
  #{ /*$gimp6calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;;
;; match a gimple call to a direct function of arity 7 exactly
(defcmatcher gimple_call_7
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
	 arg6)
  gimp7call
  ;; test
  #{/*$gimp7call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==7)}#
  ;; fill
  #{ /*$gimp7call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $arg6 = gimple_call_arg(($gc), 6);
   }#)

;; match a gimple call to a direct function of arity 7 or more
(defcmatcher gimple_call_7_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
	 arg6
   :long nbargs
	 )
  gimp7calm
  ;; test
  #{/*$gimp7calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=7)}#
  ;; fill
  #{ /*$gimp7calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $arg6 = gimple_call_arg(($gc), 6);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;; fetch the nth argument inside a call
(defprimitive gimple_call_nth_arg (:gimple gc :long n) :tree
  :doc #{Safely retrieve in gimple call $GC its $N-th argument.}#
  #{(($gc && gimple_code($gc) == GIMPLE_CALL && ($n)>=0 
      && ($n) < gimple_call_num_args($gc)) 
     ? gimple_call_arg(($gc), ($n)) : NULL_TREE)}# )



;;;;;;;;;;;;;;;;
;;;;  match a gimple return
(defcmatcher gimple_return
  (:gimple gr)
  (:tree retval
   )
  gimpret
  ;; test 
  #{($gr && gimple_code($gr)==GIMPLE_RETURN)}#
  ;; fill
  #{
   $retval = gimple_return_retval($gr);
  }# )
 


;;;;;;;;;;;;;;;;
;;;; match a goto [to a label or var for indirect goto]
(defcmatcher gimple_goto
  (:gimple gr)
  (:tree tlabeld)
  gimpgoto
  ;; test
  #{ /* $gimpgoto ? */ ($gr && gimple_code($gr) == GIMPLE_GOTO) }#
  ;; fill
  #{ /* $gimpgoto ! */ 
  $tlabeld = gimple_goto_dest($gr);
  }# )


;;; match a gimple error mark or a nil; probably not very useful!
(defcmatcher gimple_error_mark_or_nil
  (:gimple gr)
  ()
  gimperrnil
  ;; test
  #{ /*$gimperrnil ? */ (!$gr ||  gimple_code($gr) == GIMPLE_ERROR_MARK) }#
  ;; no fill
)


;; match any gimple_debug 
(defcmatcher gimple_debug
  (:gimple gr)
  ()
  gimpdbg
  ;; test
  #{ (($gr) && is_gimple_debug(($gr))) }#
  ;; no fill
)


;; match a gimple_debug_bind
(defcmatcher gimple_debug_bind
  (:gimple gr)
  (:tree tvar tval)
  gimpdbgbind
  ;; test
  #{ /* $gimpdbgbind ? */ (($gr) && gimple_debug_bind_p (($gr))) }#
  ;; fill
  #{ /* $gimpdbgbind ! */ 
  $tvar = gimple_debug_bind_get_var ($gr);
  $tval = gimple_debug_bind_get_value ($gr);
  }#)

;;; match a label
(defcmatcher gimple_label
  (:gimple gr)
  (:tree tlabel)
  gimplab
  ;; test
  #{ /* $gimplab ? */ ($gr && gimple_code($gr) == GIMPLE_LABEL) }#
  ;; fill
  #{ /* $gimplab ! */ 
  $tlabel = gimple_label_label($gr);
  }# )




;;; match a nop
(defcmatcher gimple_nop
  (:gimple gr)
  ()
  gimpnop
  ;; test
  #{ /* $gimpnop ?*/ ($gr && gimple_code($gr) == GIMPLE_NOP) }#
  ;; no fill
  #{ /* $gimpnop ! */ }#)

;;; match a gimple bind
(defcmatcher gimple_bind
  (:gimple gr)
  (:tree tvars tblock
  :gimple_seq gbody
	 )
  gimpbind
  ;; test
  #{ /* $gimpbind ? */ ($gr && gimple_code($gr) == GIMPLE_BIND) }#
  ;; fill
  #{ /* $gimpbind ! */
   $tvars = gimple_bind_vars($gr);
   $tblock = gimple_bind_block($gr);
   $gbody = gimple_bind_body($gr);
  }# )

;;; match a gimple asm
(defcmatcher gimple_asm
  (:gimple gr)
  (:cstring asmstr
   :long ninputs noutputs nclobbers)
  gimpasm
  ;; test
  #{ /* $gimpasm ? */ ($gr &&  gimple_code($gr) == GIMPLE_ASM) }#
  ;; fill
  #{ /* $gimpasm ! */
  $asmstr = gimple_asm_string ($gr);
  $ninputs = gimple_asm_ninputs ($gr);
  $noutputs = gimple_asm_noutputs ($gr);
  $nclobbers = gimple_asm_nclobbers ($gr);
  }# )

;;;;;;;;;;;;;;;;
;;; match a gimple switch
(defcmatcher gimple_switch
  (:gimple gr)
  (:tree tindex 
   :long numlabels)
  gimpswitch
  ;; test
  #{ /* $gimpswitch ? */ ($gr &&  gimple_code($gr) == GIMPLE_SWITCH) }#
  ;; fill
  #{ /* $gimpswitch ! */
  $tindex = gimple_switch_index ($gr);
  $numlabels = gimple_switch_num_labels ($gr);
  }#
)

;;; return the index of a switch
(defprimitive gimple_switch_index (:gimple gs) :tree
  :doc #{Retrieve the index of gimple switch $GS.}#
  #{ (($gs) && gimple_code($gs) == GIMPLE_SWITCH) ? 
  gimple_switch_index_ptr($gs) : NULL }#)

;;; return a tree label
(defprimitive gimple_switch_label (:gimple gs :long n) :tree
  :doc #{Safely retrieve the $N-th label in gimple switch $GS.}#
  #{ (($gs) && gimple_code($gs) == GIMPLE_SWITCH
      &&  $n>= 0&&  $n<  gimple_switch_num_labels($gs)) ?
  gimple_switch_label($gs, $n) : NULL }#)



;;; iterator on switch cases
(defciterator foreach_case_of_gimple_switch
  (:gimple gs)
  ecos
  (:tree case)
  #{
      /* before $ECOS */
      int $ECOS#_i = 0;

      if ($gs&&  gimple_code($gs) == GIMPLE_SWITCH)
      {
          int $ECOS#_n = gimple_switch_num_labels($gs);

          for ($ECOS#_i = 0; 
	       $ECOS#_i < $ECOS#_n; 
               $ECOS#_i++)
          {
              $case = gimple_switch_label ($gs, $ECOS#_i);
  }#

  #{
      /* after $ECOS */
          }
      }
  }#
)

;;;;;;;;;;;;;;;;
;;; match a phi node

(defcmatcher gimple_phi
  (:gimple gr)
  (:tree lres				;left hand result
   :long numargs)
  gimphi
  ;; test
  #{ /* $gimphi ? */ ($gr && gimple_code ($gr) == GIMPLE_PHI) }#
  ;; fill
  #{ /* $gimphi ! */
  $lres = gimple_phi_result ($gr);
  $numargs = gimple_phi_num_args ($gr);
  }# )

;;; safely retrieve the N-th argdeftree of a gimple phinode
(defprimitive gimple_phi_nth_arg_def (:gimple g :long n) :tree
  #{ ( ($g && gimple_code($g) == GIMPLE_PHI && n >= 0 && n < gimple_phi_num_args ($g)) 
       ? gimple_phi_arg_def($g, $n) : NULL) }#)
;;; safely retrieve the N-th argedge of a gimple phinode
(defprimitive gimple_phi_nth_arg_edge (:gimple g :long n) :edge
  #{ ( ($g && gimple_code($g) == GIMPLE_PHI && n >= 0 && n < gimple_phi_num_args ($g)) 
       ? gimple_phi_arg_edge($g, $n) : NULL) }#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; issue a notice or a warning at a gimple location
(defprimitive inform_at_gimple (:gimple g :cstring msg) :void
  #{ inform (($g ? gimple_location($g) : UNKNOWN_LOCATION), $msg); }#
)

(defprimitive warning_at_gimple (:gimple g :cstring msg) :void
   #{ warning_at(($g ? gimple_location($g) : UNKNOWN_LOCATION), 0, $msg); }#
)

(defprimitive warning_at_gimple_strbuf (:gimple g :value msg) :void
   #{ melt_warning_at_strbuf(($g ? gimple_location($g) : UNKNOWN_LOCATION)
    , $msg); }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defprimitive is_gimpleseq (v) :long
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_GIMPLESEQ)}# )

(defprimitive make_gimpleseq (discr :gimple_seq g) :value
  #{(meltgc_new_gimpleseq((meltobject_ptr_t)($discr),($g)))}# )

(defprimitive gimpleseq_content (v) :gimple_seq
  #{(melt_gimpleseq_content((melt_ptr_t)($v)))}# )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defprimitive is_tree (v) :long
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_TREE)}# )

(defprimitive isnull_tree (:tree tr) :long
  #{$tr == NULL_TREE}#
)

(defprimitive make_tree (discr :tree g) :value
  #{(meltgc_new_tree((meltobject_ptr_t)($discr),($g)))}# )

(defprimitive tree_content (v) :tree
  #{(melt_tree_content((melt_ptr_t)($v)))}# )

(defprimitive ==t (:tree t1 t2) :long
  #{(($t1) == ($t2))}# )

(defprimitive null_tree () :tree #{(NULL_TREE)}#)

(defprimitive inform_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  #{ inform((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
	    : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
  $msg );
  }# )

(defprimitive warning_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  #{ warning_at( (($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
		 : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
		 0,
		 $msg);
  }# )

(defprimitive warning_at_tree_decl_with_number
  (:tree trdecl :cstring msg :long num) :void
  #{ warning (0, "MELT warning %s at %q+D - #%ld", $MSG, ($TRDECL), ($NUM));
  }# )

(defprimitive tree_type (:tree tr) :tree
  #{(($tr)?TREE_TYPE($tr):NULL)}#)

(defprimitive tree_uid (:tree tr) :long
  #{(($tr) ? (long) DECL_UID($tr) : NULL)}#)

(defprimitive tree_chain_prepend (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the begining of $CHAIN. Returns the newly created
	chain.}#
	#{
		tree_cons ($PURPOSE, $VALUE, $CHAIN)
	}#)

(defprimitive tree_chain_append (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the end of $CHAIN. Returns the newly created
	chain (different from $CHAIN if $CHAIN is NULL_TREE).}#
	#{
		chainon ($CHAIN, tree_cons ($PURPOSE, $VALUE, NULL_TREE))
	}#)

(defprimitive tree_chain_join (:tree chain1 chain2) :tree
	:doc #{Append $CHAIN2 to $CHAIN1 and returns the newly created
	chain (different from $CHAIN1 if $CHAIN1 is NULL_TREE).}#
	#{
		chainon ($CHAIN1, $CHAIN2)
	}#)

(defprimitive build_identifier_tree (name) :tree
	:doc #{Create and returns a new IDENTIFIER_NODE tree whose
	name is $NAME.}#
	#{
		get_identifier (melt_string_str ($NAME))
	}#)

(defprimitive build_string_tree (string_value) :tree
	:doc #{Create and returns a new STRING_CST tree whose
	value is $STRING_VALUE.}#
	#{
		build_string (strlen (melt_string_str ($STRING_VALUE)), melt_string_str ($STRING_VALUE))
	}#)

(defprimitive build_int_tree (int_value) :tree
	:doc #{Create and returns a new INTEGER_CST tree whose
	value is $INT_VALUE and type is the default language
	integer type.}#
	#{
		build_int_cst (integer_type_node, (int)melt_get_int ($INT_VALUE))
	}#)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; pattern (tree_function_decl <funame> <initialtree>) match a tree for a function
;; declaration
(defcmatcher tree_function_decl 
  (:tree tr) 				;matched
  ;; output 
  (:cstring funame
   :tree initialdcl
   )
  treefun				;state symbol
  ;; test expansion
  #{ (($tr) && TREE_CODE($tr) == FUNCTION_DECL) }#
  ;; fill expansion
  #{
   $funame = NULL; 
   $initialdcl = NULL; 
   if (DECL_NAME($tr))
     $funame = IDENTIFIER_POINTER(DECL_NAME($tr)); 
   $initialdcl = DECL_RESULT($tr); 
  }#
)

;; pattern (tree_function_type <return type>) match a tree function type.
(defcmatcher tree_function_type
  (:tree tr)
  (:tree ret_tr)
  tfunt
  ;; test expansion
  #{ /* $tfunt ? */ (($tr) && TREE_CODE($tr) == FUNCTION_TYPE) }#
  ;; fill expansion
  #{ /* $tfunt ! */
      $ret_tr = TREE_TYPE($tr);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_of_type 
  (:tree tr)
  (:tree typetr)
  treeoftype
  ;; test expansion
  #{ /*$treeoftype ?*/ ($tr) != NULL }#
  ;; fill expansion
  #{ /*$treeoftype !*/ $typetr = TREE_TYPE($tr); }#
)

;;;;;;;;;;;;;;;;
;; similarily pattern (tree_var_decl <name>)
(defcmatcher tree_var_decl 
  (:tree tr)
  (:tree type :cstring varname :long uid)
  treevard				;statesym
  ;; test expansion
  #{/*$treevard ?*/ (($tr) && TREE_CODE($tr) == VAR_DECL) }#
  ;; fill expansion
  #{/*$treevard !*/
   $varname =NULL;
   $type = TREE_TYPE($tr);
   $uid = DECL_UID($tr);
   if (DECL_NAME($tr))
     $varname = IDENTIFIER_POINTER(DECL_NAME($tr));
   }# )

;; pattern for a var_decl of given name
	   
(defcmatcher tree_var_decl_named 
  (:tree tr :cstring varname)
  ()
  treevarn				;statesym
  ;; test expansion
  #{ /*$treevarn ?*/ (($tr) && TREE_CODE($tr) == VAR_DECL && DECL_NAME($tr) 
      && !strcmp($varname, IDENTIFIER_POINTER(DECL_NAME($tr)))) }#
  ;; fill expansion
  #{ /*$treevarn !*/ }# )

;;;;;;;;;;;;;;;;
;; pattern tree_array_ref matches an array reference with array and index
(defcmatcher tree_array_ref
  (:tree tr)				;input
  (:tree trarr trindex)
  treearrayref			 ;statesym
  ;; test
  #{ /*$TREEARRAYREF ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /*$TREEARRAYREF !*/ 
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
  }#)

;; pattern tree_array_ref_full
(defcmatcher  tree_array_ref_full
  (:tree tr)				;input
  (:tree trarr trindex trmin trsize)
  treearrayreffull			 ;statesym
  ;; test
  #{ /*$TREEARRAYREFFULL ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /*$TREEARRAYREFFULL !*/ 
    int $TREEARRAYREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
    $TRMIN = ($TREEARRAYREFFULL#_len >= 3) ? TREE_OPERAND ($TR, 2) : (NULL_TREE);
    $TRSIZE = ($TREEARRAYREFFULL#_len >= 4) ? TREE_OPERAND ($TR, 3) : (NULL_TREE);
  }#)

;;;;;;;;;;;;;;;;
;; pattern tree_component_ref matches an component reference with component and index
(defcmatcher tree_component_ref
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield)		;output
  treecomponentref			 ;statesym
  ;; test
  #{ /*$TREECOMPONENTREF ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /*$TREECOMPONENTREF !*/ 
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
  }#)

(defcmatcher tree_component_ref_full
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield troff)
  treecomponentreffull			 ;statesym
  ;; test
  #{ /*$TREECOMPONENTREFFULL ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /*$TREECOMPONENTREFFULL !*/ 
    int $TREECOMPONENTREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
    $TROFF = ($TREECOMPONENTREFFULL#_len > 2) ? TREE_OPERAND ($TR, 2) : NULL_TREE;
  }#)

(defcmatcher tree_component_ref_typed
  (:tree tr)
  (:tree type
   :tree arg0
   :tree arg1)
  treecr

  #{
       (($tr) && TREE_CODE ($tr) == COMPONENT_REF)
  }#

  #{
       $type = TREE_TYPE ($tr);
       $arg0 = TREE_OPERAND ($tr, 0);
       $arg1 = TREE_OPERAND ($tr, 1);
  }#)

;; pattern tree_mem_ref matches a memory reference with pointer and offset
(defcmatcher tree_mem_ref
  (:tree tr)				;input
  (:tree trptr troff)
  treememref			 ;statesym
  ;; test
  #{ /*$TREEMEMREF ?*/ (($TR) && TREE_CODE($TR) == MEM_REF) }#
  ;; fill
  #{ /*$TREEMEMREF !*/ 
    $TRPTR = TREE_OPERAND ($TR, 0);
    $TROFF = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
;; pattern tree_block matches a block
(defcmatcher tree_block 
  (:tree tr)
  (					;output
   :tree trvars  trsubblocks 	 
   )
  treeblock				;statesym
  ;; test expander
   #{/*$treeblock ?*/ (($tr) && TREE_CODE($tr) == BLOCK)}#
  ;; fill expander
   #{ /*$treeblock !*/
   $trvars = BLOCK_VARS($tr);
   $trsubblocks =BLOCK_SUBBLOCKS($tr);
   }# )

;;;;;;;;;;;;;;;;
;;; pattern tree_parm_decl matches a formal parameter declaration
(defcmatcher tree_parm_decl 
  (:tree tr)
  (					;output
   :tree trargtype trdecl
   :cstring name
   )
  treeparmdecl				;statesym
  ;; test expander
   #{(($tr) && TREE_CODE($tr) == PARM_DECL)}#
  ;; fill expander
   #{
   $trargtype = DECL_ARG_TYPE($tr);
   $trdecl = DECL_NAME($tr);
   $name = DECL_NAME($tr) ? IDENTIFIER_POINTER(DECL_NAME($tr)) : NULL;
   }# )



;;;;;;;;;;;;;;;;
;;; pattern tree_identifier matches any identifier node
(defcmatcher tree_identifier
  (:tree tr)
  (:cstring name)
  treeident
  #{ /*$TREEIDENT ?*/ $TR && TREE_CODE ($TR) == IDENTIFIER_NODE }#
  #{ /*$TREEIDENT !*/ $NAME = (const char*) IDENTIFIER_POINTER ($TR) }#
)

;;; pattern tree_list matches any tree list node
(defcmatcher tree_list
  (:tree tr)
  (:tree trvalue trpurpose trchain)
  treelist
  #{ /*$TREELIST ?*/ $TR && TREE_CODE ($TR) == TREE_LIST }#
  #{ /*$TREELIST !*/ 
    $TRVALUE = TREE_VALUE ($TR);
    $TRPURPOSE = TREE_PURPOSE ($TR);
    $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;; pattern tree_vec matches any tree vector node
(defcmatcher tree_vec
  (:tree tr)
  (:long len :tree trchain)
  treevec
  #{ /*$TREEVEC ?*/ $TR && TREE_CODE ($TR) == TREE_VEC }#
  #{ /*$TREEVEC !*/ 
  $LEN = TREE_VEC_LENGTH ($TR);
  $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;;;;;;;;;;;;;;;
;;; pattern tree_decl matches any declaration
(defcmatcher tree_decl 
  (:tree tr)
  (					;output
   :tree trdecl
   :cstring name
   :long uid
   )
  treedecl				;statesym
  ;; test expander
  #{(($tr) && DECL_P($tr))}#
  ;; fill expander
  #{
   tree  $treedecl#_name = DECL_NAME($tr);
   $trdecl = $treedecl#_name;
   $name = ($treedecl#_name) ? IDENTIFIER_POINTER($treedecl#_name) : NULL;
   $uid = DECL_UID($tr);
   }# )


;; pattern tree_void_type
(defcmatcher tree_void_type
  (:tree tr)
  (:tree type)
  treevt

  #{
       (($tr) && TREE_CODE ($tr) == VOID_TYPE)
  }#

  #{
       $type = TYPE_NAME ($tr);
  }#)

;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type
(defcmatcher tree_integer_type 
  (:tree tr)
  (					;output
   :tree type
   :value minbig maxbig 
   :tree size
   )
  treeinty				;statesym
  ;; test expander
   #{ /*$treeinty ?*/ (($tr) && TREE_CODE($tr) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /*$treeinty !*/
      mpz_t $treeinty#_minz;
      mpz_t $treeinty#_maxz;

      $type = TYPE_NAME($tr);
      $size = TYPE_SIZE($tr);

      mpz_init ($treeinty#_minz);
      mpz_init ($treeinty#_maxz);
      get_type_static_bounds($tr, $treeinty#_minz, $treeinty#_maxz);
      $minbig = meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
					 NULL, 
					 $treeinty#_minz);
      $maxbig =  meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
					 NULL, 
					 $treeinty#_maxz);
      mpz_clear ($treeinty#_minz);
      mpz_clear ($treeinty#_maxz);
    }#)

;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type_bounded, the bounds are trees
(defcmatcher tree_integer_type_bounded
  (:tree tr)
  (					;output
   :tree ttype
   :tree tmin tmax
   :tree tsize
   )
  treeintybnd				;statesym
  ;; test expander
   #{ /*$TREEINTYBND ?*/ (($TR) && TREE_CODE($TR) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /*$TREEINTYBND !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
    }#)

;; Pattern tree_type_declaration. 
(defcmatcher tree_type_declaration
  (:tree tr)
  (:tree declaration)
  titd
  #{
      (($tr) && TREE_CODE($tr) == TYPE_DECL)
  }#

  #{
      $declaration = DECL_NAME($tr);
  }#)

;;; pattern tree_real_type. It matches any real type.
;;; asked by Marie Krumpe.
(defcmatcher tree_real_type 
  (:tree tr)
  (					;output
   :tree type
   :tree size
  )
  tranyfloaty

  #{ /* $tranyfloaty ? */ 
      (($tr) && TREE_CODE($tr) == REAL_TYPE)
  }#

  #{ /* $tranyfloaty ! */
      $type = TYPE_NAME($tr);
      $size = TYPE_SIZE($tr);
  }#
)

;;; pattern tree_integer_cst
(defcmatcher tree_integer_cst
  (:tree tr)
  (					;output
   :long n )
  treeintk
  ;; test expander
  #{ /*$treeintk ?*/ (($TR) && TREE_CODE($TR) == INTEGER_CST && host_integerp($TR, 0)) }#
  ;; fill expander
  #{ /*$treeintk !*/ $n  = tree_low_cst(($tr), 0);
  }#  )


;;; pattern tree_real_cst
(defcmatcher tree_real_cst
  (:tree tr)
  (:value v)
  treerealc
  ;; test expander 
  #{ /* $treerealc ?*/ (($tr) && TREE_CODE($tr) == REAL_CST) }#
  ;; fill expander
  #{ /* treerealc! */
  $v = meltgc_new_real ((meltobject_ptr_t) MELT_PREDEF (DISCR_REAL), 
                       TREE_REAL_CST(($tr))); }#
)

(defcmatcher tree_string_cst
  (:tree tr)
  (:value v)
  treestringc
  ;; test expander
  #{   /* $treestringc ? */
       (($tr) && TREE_CODE ($tr) == STRING_CST)
  }#
  ;; fill expander
  #{   /* $treestringc ! */
       $v = meltgc_new_string_raw_len ((meltobject_ptr_t) MELT_PREDEF (DISCR_STRING),
				       TREE_STRING_POINTER ($tr),
				       TREE_STRING_LENGTH ($tr));
  }#)
       
;;; pattern for pointer types
(defcmatcher tree_pointer_type_p
  (:tree tr)
  (:tree typetr)
  treeisptrt
  ;; test
  #{ /*$treeisptrt ?*/ (($tr) && POINTER_TYPE_P(($tr))) }#
  ;; fill
  #{ /*$treeisptrt !*/ $typetr = TREE_TYPE($tr); }#
;;; :doc annotation are not yet accepted in cmatcher-s!
;  :doc #{The $TREE_POINTER_TYPE_P cmatchers matches pointer &
;  reference type trees.}#
)

;;; pattern for indirect references
(defcmatcher tree_indirect_reference
  (:tree tr)
  (:tree type
   :tree reference)
  treeir

  #{
       (($tr) && INDIRECT_REF_P ($tr))
  }#

  #{
       $type = TREE_TYPE ($tr);
       $reference = TREE_OPERAND ($tr, 0);
  }#)

(defcmatcher tree_addr_expr
  (:tree tr)
  (:tree type
   :tree expression)
  treeae

  #{
       (($tr) && TREE_CODE ($tr) == ADDR_EXPR)
  }#

  #{
       $type = TREE_TYPE ($tr);
       $expression = TREE_OPERAND ($tr, 0);
  }#)

(defcmatcher tree_record_type
  (:tree tr)
  (:tree type)
  treerectyp

  #{ /* $TREERECTYP ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{
       $TYPE = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_record_type_with_fields
  (:tree tr)
  (:tree type tfields)
  trectyfld
  #{  /* $TRECTYFLD ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{ /* $TRECTYFLD ! */
       $TYPE = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)

(defcmatcher tree_array_type
  (:tree tr)
  (:tree telemtype tdomaintype)
  treearrtyp
  #{ /* $TREEARRTYP ? */
  (($TR) && TREE_CODE ($TR) == ARRAY_TYPE)
  }#
  #{ /* $TREEARRTYP ! */
  $TELEMTYPE = TREE_TYPE ($TR);
  $TDOMAINTYPE = TYPE_DOMAIN ($TR);
  }#)


(defcmatcher tree_field_decl
  (:tree tr)
  (:tree name type)
  treefield
  #{ /* $TREEFIELD ? */
       (($TR) && TREE_CODE ($TR) == FIELD_DECL)
  }#
  #{ /* $TREEFIELD ! */
       $NAME = DECL_NAME ($TR);
       $TYPE = TREE_TYPE ($TR);
  }#)

;;;; matcher for patter ssa_name
(defcmatcher tree_ssa_name 
  (:tree tr)
  (:tree tvar tvalu :long vers :gimple defstmt)
  treessa
  ;; test expander
  #{ (($tr) && TREE_CODE($tr) == SSA_NAME) }#
  ;; fill expander
  #{
   $tvar = SSA_NAME_VAR($tr);
   $tvalu = SSA_NAME_VALUE($tr);
   $vers = SSA_NAME_VERSION($tr);
   $defstmt = SSA_NAME_DEF_STMT($tr);
  }# )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(defprimitive is_basicblock (v) :long
 #{ (melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_BASICBLOCK)}# )

(defprimitive isnull_basicblock (:basic_block bb) :long
 #{($bb == (basic_block)0)}# )

(defprimitive notnull_basicblock (:basic_block bb) :long
 #{($bb != (basic_block)0)}# )

(defprimitive null_basicblock () :basic_block #{((basic_block)0)}#)

(defprimitive make_basicblock (discr :basic_block bb) :value
 #{/*make_basicblock*/(meltgc_new_basicblock((meltobject_ptr_t)($discr),($bb)))}# )

(defprimitive basicblock_content (v) :basic_block
 #{(melt_basicblock_content((melt_ptr_t)($v)))}# )

(defprimitive basicblock_gimpleseq (v) :gimple_seq
  #{(melt_basicblock_gimpleseq((melt_ptr_t)($v)))}# )
  
(defprimitive basicblock_phinodes (v) :gimple_seq
  #{(melt_basicblock_phinodes((melt_ptr_t)($v)))}# )
  
(defprimitive ppstrbuf_gimple (sbuf :long indent :gimple g) :void
  #{ meltgc_ppstrbuf_gimple((melt_ptr_t)($sbuf), 
			       (int) ($indent), ($g)) }# )

(defprimitive ppstrbuf_gimple_seq (sbuf :long indent :gimple_seq gseq) :void
  #{ meltgc_ppstrbuf_gimple_seq((melt_ptr_t)($sbuf),
				   (int) ($indent), ($gseq)) }# )

(defprimitive ppstrbuf_tree (sbuf :long indent :tree t) :void
  #{ meltgc_ppstrbuf_tree((melt_ptr_t)($sbuf), 
			     (int) ($indent), ($t)) }# )

(defprimitive ppstrbuf_basicblock (sbuf :long indent :basic_block bb) :void
  #{ meltgc_ppstrbuf_basicblock((melt_ptr_t)($sbuf),
				   (int) ($indent), ($bb)) }# )

(defprimitive output_edge (out :edge edg) :void
  :doc #{Output to $OUT the edge $EDG}#
  #{ meltgc_out_edge((melt_ptr_t)($OUT), ($EDG)) }# )

(defprimitive basicblock_single_succ (:basic_block bb) :basic_block
  #{(($bb && single_succ_p($bb))?single_succ($bb):NULL)}# )

(defprimitive basicblock_nb_succ (:basic_block bb) :long
  #{(($bb)?EDGE_COUNT($bb->succs):0)}#)

(defprimitive basicblock_nth_succ_edge  (:basic_block bb :long ix) :edge
  #{(($bb && $ix>=0 && $ix<EDGE_COUNT($bb->succs))?EDGE_SUCC($bb,$ix):NULL)}#)

;; Primitives concerning dominance in basic_blocks
;; those functions mainly come from gcc/dominance.c

(defprimitive is_dominance_info_available () :long
  :doc #{Check if dominance info are already calculated.
        User normally doesn't have to call this primitive, as MELT functions
        check if there is a need to use this.}#
  #{dom_info_available_p(CDI_DOMINATORS)}#
)

(defprimitive is_post_dominance_info_available () :long
  :doc #{Check if post dominance info are already calculated.
        User normally doesn't have to call this primitive, as MELT functions
        check if there is a need to use this.}#
  #{dom_info_available_p(CDI_POST_DOMINATORS)}#
)

(defprimitive calculate_dominance_info_unsafe () :void
  :doc #{This primitive is internally called, user doesn't need it.
        Build the struct containing dominance info.
        This struct is necessary to use others dominance related function.
        This function is unsafe because it does not register any future call to
        free_dominance_info.}#
  #{calculate_dominance_info(CDI_DOMINATORS)}#
)

(defprimitive calculate_post_dominance_info_unsafe () :void
  :doc #{This primitive is internally called, user doesn't need it.
        Build the struct containing post dominance info.
        This struct is necessary to use other dominance related function.
        This function is unsafe because it does not register any future call to
        free_dominance_info.}#
  #{calculate_dominance_info(CDI_POST_DOMINATORS)}#
)

(defprimitive free_dominance_info () :void
  :doc #{This primitive is internally called, user doesn't need it.
        Clear dominance info if they have been allocated.}#
  #{free_dominance_info(CDI_DOMINATORS)}#
)

(defprimitive free_post_dominance_info () :void
  :doc #{This primitive is internally called, user doesn't need it.
    Clear post dominance info if they have been allocated.}#
  #{free_dominance_info(CDI_POST_DOMINATORS)}#
)

(defun calculate_dominance_info ()
  :doc #{This primitive is internally called, user doesn't need it.
      Build the struct containing dominance info.
      This struct is necessary to use other dominance related info.
      It place a call to free dominance info when pass is finished if it is
      necessary.}#
  (if (is_dominance_info_available)
    () ;; do nothing
    (progn ;; else calculate dom and ask to free them at end of pass
      (calculate_dominance_info_unsafe)
      (at_end_melt_pass_first free_dominance_info)
    ))
)

(defun calculate_post_dominance_info () 
  :doc #{This primitive is internally called, user doesn't need it
      Build the struct containing post dominance info.
      This struct is necessary to use other post dominance related info.
      It place a call to free dominance info when pass is finished if it is
      necessary.}#
  (if (is_post_dominance_info_available)
    ()  ;; do nothing
    (progn ;; else calculate dom and ask to free them at end of pass
      (calculate_post_dominance_info_unsafe)
      (at_end_melt_pass_first free_post_dominance_info)
    ))
)

(defprimitive debug_dominance_info (:cstring msg) :void
  :doc #{Debug-print the dominance information.}#
  ;; be careful to keep the __LINE__ on the first line of the macrostring.
  #{ if (flag_melt_debug) { const int thislineno = __LINE__ ;
       extern void debug_dominance_info (enum cdi_direction);
       if (dom_info_available_p(CDI_DOMINATORS)) {
         debugeprintflinenonl (thislineno,
			       "debug_dominance_info %s", $MSG);
         debug_dominance_info (CDI_DOMINATORS);
       } 
       else debugeprintfline (thislineno, 
			      "debug_dominance_info %s not available", $MSG);
     }}#
)

(defprimitive debug_post_dominance_info (:cstring msg) :void
  :doc #{Debug-print the post dominance information.}#
  ;; be careful to keep the __LINE__ on the first line of the macrostring.
  #{ if (flag_melt_debug) { const int thislineno = __LINE__ ;
       extern void debug_dominance_info (enum cdi_direction);
       if (dom_info_available_p(CDI_POST_DOMINATORS)) {
         debugeprintflinenonl (thislineno, 
			       "debug_post_dominance_info %s", $MSG);
         debug_dominance_info (CDI_POST_DOMINATORS);
       } 
       else debugeprintfline (thislineno,
			      "debug_post_dominance_info %s not available", 
			      $MSG);
     }}#
)

(defprimitive get_immediate_dominator_unsafe (:basic_block bb) :basic_block
  :doc#{It doesn't check that dominance info are build, use
      get_immediate_dominator instead.}#
  #{($bb) ? get_immediate_dominator (CDI_DOMINATORS, $bb) : NULL}#
)

(defun get_immediate_dominator (bb) 
 :doc#{Return the next immediate dominator of the boxed basic_block $BB as a
      MELT value.}#
  (if (is_basicblock bb)
  (progn
    (calculate_dominance_info) 
    (return (make_basicblock discr_basic_block 
      (get_immediate_dominator_unsafe (basicblock_content bb))))))
)

(defprimitive get_immediate_post_dominator_unsafe (:basic_block bb) 
  :basic_block
  :doc#{It doesn't check that post_dominance info are build, use
      get_immediate_post_dominator instead.}#
  #{($bb) ? get_immediate_dominator (CDI_POST_DOMINATORS, $bb) : NULL}#
)

(defun get_immediate_post_dominator (bb)
  :doc#{Return the next immediate post dominator of the boxed basic_block $BB as
  a MELT value.}#
  (if (is_basicblock bb)
      (progn
	(calculate_post_dominance_info) 
	(return (make_basicblock discr_basic_block 
				 (get_immediate_post_dominator_unsafe (basicblock_content bb))))))
  )

(defprimitive dominated_by_other_unsafe (:basic_block bba bbb) :long
  :doc#{It doesn't check that dominance info is built, use
  dominated_by_other instead.}#
  #{ (($BBA) && ($BBB) && dominated_by_p (CDI_DOMINATORS, $BBA, $BBB)) }#
  )

(defun dominated_by_other (bbA bbB)
  :doc#{true if boxed basic_block $BBA is dominated by boxed basic_block $BBB.}#
  (if (and (is_basicblock bbA) (is_basicblock bbB))
  (progn
    (calculate_dominance_info) 
    (if (dominated_by_other_unsafe (basicblock_content bbA) 
                                   (basicblock_content bbB))
      (return :true)
    )))
)

(defprimitive post_dominated_by_other_unsafe (:basic_block bbA bbB) :long
  :doc#{It doesn't check that post_dominance info are build, use
      post_dominated_by_other instead.}#
  #{ (($bbA) && ($bbB)) ?
      dominated_by_p (CDI_POST_DOMINATORS, $bbA, $bbB) 
      : 0 
  }#
)

(defun post_dominated_by_other (bbA bbB)
  :doc#{true if boxed basic_block $BBA is post dominated by boxed basic_block
      $BBB.}#
  (if (and (is_basicblock bbA) (is_basicblock bbB))
  (progn
    (calculate_post_dominance_info) 
    (if (post_dominated_by_other_unsafe (basicblock_content bbA) 
                                   (basicblock_content bbB))
      (return :true)
    )))
)

(defciterator foreach_dominated_unsafe
  (:basic_block dominator_bb)
  ebbdomd
  (:basic_block dominated_bb)
  #{
    /* $EBBDOMD before+ */

    VEC (basic_block, heap)*  $EBBDOMD#_bbvec = 0;
    unsigned int $EBBDOMD#_ix = 0;
    basic_block $EBBDOMD#_bb = 0;

    if($DOMINATOR_BB){
      $EBBDOMD#_bbvec = get_dominated_by(CDI_DOMINATORS, $DOMINATOR_BB);
      if($EBBDOMD#_bbvec){
        FOR_EACH_VEC_ELT (basic_block, $EBBDOMD#_bbvec, 
          $EBBDOMD#_ix, $EBBDOMD#_bb){
          if (!$EBBDOMD#_ix)
            continue;
          $DOMINATED_BB = $EBBDOMD#_bb;
     /*$EBBDOMD before- */}#
      ;; after expansion
  #{/*$EBBDOMD after+ */
          }
      }}
    VEC_free (basic_block, heap, $EBBDOMD#_bbvec);
    $EBBDOMD#_bbvec = 0;
    $EBBDOMD#_bb = 0;
    /* $EBBDOMD after- */}#
)

(defun dominated_by_bb_iterator (f data bb)
  :doc #{run function $F on every basicblocks dominated by boxed basic_block
      $BB with $DATA as first parameters and ending with the dominated
      basicblock as last parameters.}#
  (calculate_dominance_info)
  (foreach_dominated_unsafe
    ((basicblock_content bb))
    (:basic_block dominated_bb)
    (f data dominated_bb)
  )
)

;;;;;;;;;;;;;;;; iterating on edges succeeding a given basic_block	
;;;see also foreach_basicblock_succ_edge
(defciterator foreach_edge_bb_succs
  (:basic_block bb)			;the input formal
  eachedgebbsucc			;the state symbol
  (:edge edg)				;the local formal
  ;;
  ;; before expansion
  #{ /* $EACHEDGEBBSUCC++ */		
  if ($BB) {
    edge_iterator $EACHEDGEBBSUCC#_iter = {};
    edge $EACHEDGEBBSUCC#_edge = NULL;
    FOR_EACH_EDGE($EACHEDGEBBSUCC#_edge, $EACHEDGEBBSUCC#_iter, ($BB)->succs) 
      {
        if (!$EACHEDGEBBSUCC#_edge) continue;
	$EDG = $EACHEDGEBBSUCC#_edge;
  }#
  ;;
  ;; after expansion 
  #{ /* $EACHEDGEBBSUCC-- */
     }; /* end FOR_EACH_EDGE $EACHEDGEBBSUCC */
   } /* end if $EACHEDGEBBSUCC */
   }#
)

;;
(defun bb_dominator_iterator (bb f data)
  :doc #{apply function $F on each dominator of $BB.}#
  (calculate_dominance_info)
  (let ( (dom (get_immediate_dominator bb)) )
  (if dom
    (progn 
      (f data dom)
      (bb_dominator_iterator dom f data)
    )
  ))
)

;;
(defun bb_post_dominator_iterator (bb f data)
  :doc #{apply function $F on each dominator of $BB.}#
  (debugbasicblock "entering bb_post_dominator_iterator" (basicblock_content
                                                          bb))
  (calculate_post_dominance_info)
  (let ( (dom (get_immediate_post_dominator bb)) )
  (if (basicblock_content dom)
    (progn 
      (f data dom)
      (bb_post_dominator_iterator dom f data)
    )
  ))
)

;;;;;;;;;;;;;;;; iterating on edges preceding a given basic_block
(defciterator foreach_edge_bb_preds
  (:basic_block bb)			;the input formal
  eachedgebbpred			;the state symbol
  (:edge edg)				;the local formal
  ;;
  ;; before expansion
  #{ /* $EACHEDGEBBPRED++ */		
  if ($BB) {
    edge_iterator $EACHEDGEBBPRED#_iter = {};
    edge $EACHEDGEBBPRED#_edge = NULL;
    FOR_EACH_EDGE($EACHEDGEBBPRED#_edge, $EACHEDGEBBPRED#_iter, ($BB)->preds) 
      {
        if (!$EACHEDGEBBPRED#_edge) continue;
	$EDG = $EACHEDGEBBPRED#_edge;
  }#
  ;;
  ;; after expansion 
  #{ /* $EACHEDGEBBPRED-- */
     }; /* end FOR_EACH_EDGE $EACHEDGEBBPRED */
   } /* end if $EACHEDGEBBPRED */
   }#
)

;;;;
(defprimitive null_gimpleseq () :gimple_seq #{((gimple_seq)0)}#)
;;;;;;;;;;;;;;;;

(defprimitive is_mapbasicblock (map) :long
  #{(melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPBASICBLOCKS)}# )
(defprimitive mapbasicblock_size (map) :long
  #{(melt_size_mapbasicblocks((struct meltmapbasicblocks_st*)($map)))}#)
;; primitive to get the attribute count of a mapbasicblock
(defprimitive mapbasicblock_count (map) :long
  #{(melt_count_mapbasicblocks((struct meltmapbasicblocks_st*)($map)))}#)
;; get an entry in a mapbasicblock from a C basicblock
(defprimitive mapbasicblock_get (map :basic_block bb) :value
  #{(melt_get_mapbasicblocks(($map), ($bb)))}#)
;; primitive for making a new map of basicblocks
(defprimitive make_mapbasicblock (discr :long len) :value
  #{(meltgc_new_mapbasicblocks( (meltobject_ptr_t) ($discr),
				   ($len)))}#)
;; primitive for putting into a map of basicblocks
(defprimitive mapbasicblock_put (map :basic_block key :value val) :void
  #{melt_put_mapbasicblocks(($map), ($key), (melt_ptr_t) ($val))}#)
;; primivite for removing from a map of basicblocks
(defprimitive mapbasicblock_remove (map :basic_block key) :void
 #{meltgc_remove_mapbasicblocks(($map), ($key))}#)

;; primitive to get the nth basicblock of a mapbasicblock
(defprimitive mapbasicblock_nth_attr (map :long n) :basic_block
 #{(melt_nthattr_mapbasicblocks((struct meltmapbasicblocks_st*)($map), 
				   (int)($n)))}#)
;; primitive to get the nth value of a mapobject
(defprimitive mapbasicblock_nth_val (map :long n) :value
 #{(melt_nthval_mapbasicblocks((struct meltmapbasicblocks_st*)($map),
				  (int)($n)))}#)
(defciterator foreach_mapbasicblock 
  (bbmap)				; startformals
  eachmapbb 				;state symbol
  (:basic_block bbatt :value bbval)	;local formals
  ;; before expansion
  #{
   /*eachbbmap*/ int  $eachmapbb#_rk=0;
   for ( $eachmapbb#_rk=0;  
	 $eachmapbb#_rk<melt_size_mapbasicblocks((struct meltmapbasicblocks_st*)($bbmap));  
	 $eachmapbb#_rk++) {
   basic_block $eachmapbb#_bb=melt_nthattr_mapbasicblocks((struct meltmapbasicblocks_st*)($bbmap), $eachmapbb#_rk);
   if (!$eachmapbb#_bb) continue;
   $bbatt = $eachmapbb#_bb;
   $bbval = melt_nthval_mapbasicblocks((struct meltmapbasicblocks_st*)($bbmap ), $eachmapbb#_rk);
   }#
  ;;after expansion
   #{
   } /*endeachbbmap*/
   }#
  )


;; see also foreach_edge_bb_succs
(defciterator foreach_basicblock_succ_edge
  (:basic_block bb)
  eachbbsucc
  (:edge e :long eix)
  #{
  /* $eachbbsucc start */
   int $eachbbsucc#_nbsuc = $bb ? EDGE_COUNT($bb->succs) : 0;
   int $eachbbsucc#_ix = 0;
   for ($eachbbsucc#_ix=0; 
	$eachbbsucc#_ix < $eachbbsucc#_nbsuc;  
	$eachbbsucc#_ix++) {
     $e = EDGE_SUCC(($bb), $eachbbsucc#_ix);
     if (!$e) continue;
     $eix = $eachbbsucc#_ix;
   }#
   #{  /* $eachbbsucc end */ }  }#
)

;; Iterator on function argument 
(defciterator foreach_argument_in_function_tree
  (:tree tr_fun)
  eachtrfun
  (:tree tr_arg)
  #{
      /* $eachtrfun start */
      function_args_iterator $eachtrfun#_args_iter;
      tree $eachtrfun#_t = NULL;

      if ($tr_fun && TREE_CODE($tr_fun) == FUNCTION_TYPE)
      {
          FOREACH_FUNCTION_ARGS($tr_fun, $eachtrfun#_t, $eachtrfun#_args_iter)
          {
   }#
              
   #{
              $tr_arg = $eachtrfun#_t;
          } 
      }
      /* $eachtrfun end */
   }#)

;;;;;;;;;;;;;;;;

(defprimitive is_maptree (map) :long
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPTREES) }#)
(defprimitive maptree_size (map) :long
 #{ (melt_size_maptrees((struct meltmaptrees_st*)($map))) }#)
;; primitive to get the attribute count of a maptree
(defprimitive maptree_count (map) :long
  #{ (melt_count_maptrees((struct meltmaptrees_st*)($map))) }# )
;; get an entry in a maptree from a C tree
(defprimitive maptree_get (map :tree bb) :value
  #{(melt_get_maptrees(($map), ($bb)))}#)
;; primitive for making a new map of trees
(defprimitive make_maptree (discr :long len) :value
 #{(meltgc_new_maptrees((meltobject_ptr_t) ($discr), ($len)))}#)
;; primitive for putting into a map of trees
(defprimitive maptree_put (map :tree key :value val) :void
  #{melt_put_maptrees(($map), 
		      ($key), (melt_ptr_t) ($val))}#)
;; primivite for removing from a map of trees
(defprimitive maptree_remove (map :tree key) :void
  #{meltgc_remove_maptrees( (struct meltmaptrees_st*) ($map), ($key))}#)

;; primitive to get the nth tree of a maptree
(defprimitive maptree_nth_attr (map :long n) :tree
  #{(melt_nthattr_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}#)
;; primitive to get the nth value of a mapobject
(defprimitive maptree_nth_val (map :long n) :value
  #{(melt_nthval_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}# )
;; iterator inside maptree
(defciterator foreach_maptree 
  (trmap)				; startformals
  eachmaptr 				;state symbol
  (:tree tratt :value trval)	;local formals
  ;; before expansion
  #{
   /*eachtrmap*/ int $eachmaptr#_rk=0;
   for ($eachmaptr#_rk=0;
        $eachmaptr#_rk<melt_size_maptrees((struct meltmaptrees_st*)($trmap));
	$eachmaptr#_rk++) {
   tree $eachmaptr#_tr=melt_nthattr_maptrees((struct meltmaptrees_st*)($trmap), $eachmaptr#_rk);
   if (!$eachmaptr#_tr) continue;
   $tratt = $eachmaptr#_tr;
   $trval =melt_nthval_maptrees((struct meltmaptrees_st*)($trmap), 
				   $eachmaptr#_rk);
   }#
  ;;after expansion
   #{
   } /*endeachtrmap*/
   }#
  )

;;;;;;;;;;;;;;;;
;;; primitive to push the cfun asociated with a function declaration
;;; this is required otherwise dump of gimple crashes
(defprimitive push_cfun_decl (:tree fundecl) :void
#{ push_cfun(DECL_STRUCT_FUNCTION($fundecl)) }#) 
(defprimitive pop_cfun () :void
"pop_cfun()")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Parma Polyhedra Library stuff (aka PPL)
(defprimitive ppl_new_empty_constraint_system (discr) :value
 #{ meltgc_new_ppl_constraint_system(($discr), 
					MELT_PPL_EMPTY_CONSTRAINT_SYSTEM)}# )

(defprimitive ppl_clone_constraint_system (pplv) :value
 #{ meltgc_clone_ppl_constraint_system($pplv) }#)

(defprimitive ppl_new_unsatisfiable_constraint_system (discr) :value
  #{ meltgc_new_ppl_constraint_system(($discr), 
					 MELT_PPL_UNSATISFIABLE_CONSTRAINT_SYSTEM) }#)

(defprimitive raw_new_ppl_empty_constraint_system () :ppl_constraint_system
  #{ melt_raw_new_ppl_empty_constraint_system() }#)

(defprimitive raw_new_ppl_unsatisfiable_constraint_system () :ppl_constraint_system
  #{ melt_raw_new_ppl_unsatisfiable_constraint_system() }#)

(defprimitive ppl_ppstrbuf (sbuf ppl :long indent :value varvect) :void
  #{ meltgc_ppstrbuf_ppl_varnamvect (($sbuf), ($indent), ($ppl), ($varvect))}#)

(defprimitive ppl_coefficient_from_tree (:tree tr) :ppl_coefficient
  #{ (melt_make_ppl_coefficient_from_tree($tr)) }#)

(defprimitive ppl_coefficient_from_long (:long l) :ppl_coefficient
   #{(melt_make_ppl_coefficient_from_long($l))}#)

(defprimitive ppl_delete_Coefficient (:ppl_coefficient coef) :void
  #{ { if ($coef) ppl_delete_Coefficient($coef); 
       $coef =NULL;} 
       }#)

(defprimitive make_ppl_linear_expression () :ppl_linear_expression
  #{ melt_make_ppl_linear_expression() }#)

(defprimitive ppl_delete_Linear_Expression (:ppl_linear_expression liex) :void
#{ { if ($liex) 
     ppl_delete_Linear_Expression($liex); 
   $liex =NULL;} 
 }#)

(defprimitive ppl_delete_Constraint (:ppl_constraint cons) :void
  #{ { if ($cons) 
      ppl_delete_Constraint($cons); 
    $cons =NULL;}
    }#)

(defprimitive ppl_Linear_Expression_add_to_coefficient 
  (:ppl_linear_expression liex 
   :long vardim
   :ppl_coefficient coef) :void
#{ 
   { if (($liex) && ($coef)) 
       ppl_Linear_Expression_add_to_coefficient(($liex), ($vardim), ($coef)); 
     else debugeprintf("failed ppl_Linear_Expression_coefficient");}
  }#)

(defprimitive ppl_Linear_Expression_add_to_inhomogeneous
  (:ppl_linear_expression liex :ppl_coefficient coef) :void
#{ { if (($liex) && ($coef)) 
       ppl_Linear_Expression_add_to_inhomogeneous(($liex), ($coef)); }
}#)

(defprimitive make_ppl_constraint 
  (:ppl_linear_expression liex
   :cstring constyp) :ppl_constraint
#{ melt_make_ppl_constraint_cstrtype(($liex), ($constyp)) }#)

(defprimitive clear_special (v) :void
 #{ melt_clear_special($v); 
 }#)

(defprimitive insert_ppl_constraint_in_boxed_system 
  (:ppl_constraint cons :value sysv) :void
 #{melt_insert_ppl_constraint_in_boxed_system(($cons), ($sysv))}#)

(defprimitive ppl_Constraint_System_insert_Constraint
 (:ppl_constraint_system consys :ppl_constraint cons) :void
#{ if (ppl_Constraint_System_insert_Constraint ($consys, $cons)) 
     melt_fatal_error("ppl_Constraint_System_insert_Constraint failed"); }#)

(defprimitive ppl_Polyhedron_add_constraint 
(:ppl_polyhedron poly :ppl_constraint cons) :void
#{ if (ppl_Polyhedron_add_constraint(($poly), ($cons))) 
     melt_fatal_error("ppl_Polyhedron_add_constraint failed"); }#
)

(defprimitive debug_ppl_coefficient
  (:cstring msg :ppl_coefficient coef) :void
#{  if (flag_melt_debug)  {char*s=0; 
     if ($coef) ppl_io_asprint_Coefficient(&s, $coef); 
     debugeprintf("debug_ppl_coefficient %s @%p %s", $msg, (void*)$coef, s); 
     free(s);}
}#)

(defprimitive debug_ppl_linear_expression
  (:cstring msg :ppl_linear_expression liex) :void
 #{ if (flag_melt_debug)   {char*s=0; 
    if ($liex) ppl_io_asprint_Linear_Expression(&s, $liex); 
    debugeprintf("debug_ppl_linear_expression %s @%p %s", 
		 $msg, (void*)$liex, s); free(s);}
 }#)

(defprimitive debug_ppl_constraint (:cstring msg :ppl_constraint cons) :void
 #{if (flag_melt_debug) { char*s=0; 
  if ($cons) ppl_io_asprint_Constraint(&s, $cons); 
  debugeprintf("debug_ppl_constraint %s @%p %s", $msg, (void*)$cons, s); 
  free(s);}
 }#)

(defprimitive debug_ppl_polyhedron (:cstring msg :ppl_polyhedron poly) :void
#{ if (flag_melt_debug) {  char*s = 0; 
     debugeprintfnonl("debug_ppl_polyhedron %s @%p ", $msg, $poly);
     if ($poly) ppl_io_asprint_Polyhedron(&s, $poly);
     debugeprintf_raw("%s\n", s);
     free(s); } 
}#)

(defprimitive ppl_NNC_Polyhedron_from_Constraint_System
  (:ppl_constraint_system consys) :ppl_polyhedron
#{ melt_make_ppl_NNC_Polyhedron_from_Constraint_System($consys) }#
)

(defprimitive make_ppl_polyhedron_same(discr :ppl_polyhedron poly) :value
#{ meltgc_new_ppl_polyhedron($discr, $poly, SAME_PPL_POLHYEDRON) }#
)

(defprimitive make_ppl_polyhedron_cloned(discr :ppl_polyhedron poly) :value
#{ meltgc_new_ppl_polyhedron($discr, $poly, CLONED_PPL_POLHYEDRON) }#
)

(defprimitive ppl_delete_Polyhedron (:ppl_polyhedron poly) :void
 #{ { if ($poly) ppl_delete_Polyhedron($poly); $poly=NULL;} }#
)

(defprimitive ppl_Polyhedron_is_empty (:ppl_polyhedron poly) :long
 #{ $poly && ppl_Polyhedron_is_empty($poly) }#
)

(defprimitive ppl_coefficient_content (pplv) :ppl_coefficient
  #{ melt_ppl_coefficient_content($pplv) }#
)

(defprimitive ppl_constraint_content (pplv) :ppl_constraint
  #{ melt_ppl_constraint_content($pplv) }#
)

(defprimitive ppl_constraint_system_content (pplv) :ppl_constraint_system
  #{ melt_ppl_constraint_system_content($pplv) }#
)

(defprimitive ppl_polyhedron_content (pplv) :ppl_polyhedron
  #{ melt_ppl_polyhedron_content($pplv) }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEBUG OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; boxed gimple debug
(defun dbgout_boxgimple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (ppstrbuf_gimple out depth (gimple_content self))
    (add2out_strconst out "}/ ")
    )
  )
(install_method discr_gimple dbg_output dbgout_boxgimple_method)

;;;; boxed gimple seq debug
(defun dbgout_boxgimpleseq_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (add2out_indentnl out (+i 1 depth))
    (ppstrbuf_gimple_seq out (+i 1 depth) (gimpleseq_content self))
    (add2out_indentnl out (+i 1 depth))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_gimple_seq dbg_output dbgout_boxgimpleseq_method)

;;;; boxed tree debug
(defun dbgout_boxtree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (ppstrbuf_tree out depth (tree_content self))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_tree dbg_output dbgout_boxtree_method)

;;;; boxed basicblock debug
(defun dbgout_boxbasicblock_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (add2out_indentnl out (+i 1 depth))
    (ppstrbuf_basicblock out (+i 1 depth) (basicblock_content self))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_basic_block dbg_output dbgout_boxbasicblock_method)


;;;; boxed edge debug
(defun dbgout_boxedge_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_edge self))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/[")
    (output_edge out (edge_content self))
    (add2out_strconst out "]/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_edge dbg_output dbgout_boxedge_method)


;;; boxed loop debug
(defun dbgout_boxloop_method (self dbgi :long depth)
  (assert_msg "check self" (is_loop self))
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/[")
    (output_loop out (loop_content self))
    (add2out_strconst out "]/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_loop dbg_output dbgout_boxloop_method)


;;;; basicblockmap debug
(defun dbgout_mapbasicblock_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_mapbasicblock self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (mapbasicblock_count self))
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " !bbmap.")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/")
    (add2out_longdec out mapcount)
    (add2out_strconst out "!{")
    (foreach_mapbasicblock
     (self)
     (:basic_block bbatt :value bbval)
     (add2out_indentnl out (+i depth 1))
     (add2out_strconst out "*")
     (ppstrbuf_basicblock out (+i depth 1) bbatt)
     (add2out_strconst out " == ")
     (dbg_out bbval dbgi (+i depth 2))
     )
    (add2out_strconst out "}!")
    (add2out_indentnl out depth)
    ))
(install_method discr_map_basic_blocks dbg_output dbgout_mapbasicblock_method)


;;;; treemap debug
(defun dbgout_maptree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_maptree self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (maptree_count self))
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " !bbmap.")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/")
    (add2out_longdec out mapcount)
    (add2out_strconst out "!{ ")
    (foreach_maptree
     (self)
     (:tree tratt :value trval)
     (add2out_indentnl out (+i depth 1))
     (add2out_strconst out "*")
     (ppstrbuf_tree out (+i depth 1) tratt)
     (add2out_strconst out " == ")
     (dbg_out trval dbgi (+i depth 2))
     )
    (add2out_strconst out "}!")
    (add2out_indentnl out depth)
    ))
(install_method discr_map_trees dbg_output dbgout_maptree_method)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; iterators needed in our analysis

;;; an iterator is simply something which translates to a for loop in
;;; C. It usually binds some variables (local to the iterated body)
;;; to some C stuff.

;;; Be careful to not declare any iterator related stuff in
;;; warmelt*.melt file, because we want to be able to bootstrap
;;; Melt/MELT (ie to generate the warmelt*.c files) even when GCC
;;; internal representation changes a little.

;;;;;;;;;;;;;;;;
;;;; iterate on every cgraph_node which is a function with a body
(defciterator each_cgraph_fun_body 
  ()					; startformals
  eachcgrfun 				;state symbol
  (:tree funtree :gimple_seq funbody)	;local formals
  ;; before expansion
  #{ /* $EACHCGRFUN + */
   struct cgraph_node *$eachcgrfun#_nd = NULL; 
   for ($eachcgrfun#_nd = cgraph_nodes; 
	$eachcgrfun#_nd != NULL; 
	$eachcgrfun#_nd = $eachcgrfun#_nd->next) {
     tree $eachcgrfun#_dcl = NULL;
     gimple_seq  $eachcgrfun#_bdy = NULL;
     $eachcgrfun#_dcl =  $eachcgrfun#_nd->decl;
     if (!$eachcgrfun#_dcl) continue;
     if (TREE_CODE($eachcgrfun#_dcl) != FUNCTION_DECL) continue;
     $eachcgrfun#_bdy = gimple_body($eachcgrfun#_dcl);
     if (!$eachcgrfun#_bdy) continue;
     $funtree = $eachcgrfun#_dcl;
     $funbody = $eachcgrfun#_bdy;
  }#
   ;;after expansion
   #{ } /* $EACHCGRFUN - */ }#  )


;;; iterate on every cgraph_node which is a function with a CFG and an
;;; entryblock
(defciterator each_cgraph_fun_entryblock
  ()					;startformals
  eachcgrafunentrblo				;state symbol
  (:tree funtree :basic_block funentrybb funexitbb)	;local formals
  ;;before expansion
  #{ /* $EACHCGRAFUNENTRBLO + */
   struct cgraph_node *$EACHCGRAFUNENTRBLO#_nd = NULL; 
   for ($EACHCGRAFUNENTRBLO#_nd = cgraph_nodes; 
   $EACHCGRAFUNENTRBLO#_nd != NULL; 
   $EACHCGRAFUNENTRBLO#_nd = $EACHCGRAFUNENTRBLO#_nd->next) {
   tree  $EACHCGRAFUNENTRBLO#_dcl = NULL;
   basic_block  $EACHCGRAFUNENTRBLO#_entrybb = NULL;
   basic_block  $EACHCGRAFUNENTRBLO#_exitbb = NULL;
   struct function *$EACHCGRAFUNENTRBLO#_fun = NULL;
   $EACHCGRAFUNENTRBLO#_dcl = $EACHCGRAFUNENTRBLO#_nd->decl;
   if (! $EACHCGRAFUNENTRBLO#_dcl) continue;
   if (TREE_CODE($EACHCGRAFUNENTRBLO#_dcl) != FUNCTION_DECL) continue;
   $EACHCGRAFUNENTRBLO#_fun = DECL_STRUCT_FUNCTION($EACHCGRAFUNENTRBLO#_dcl);
   if (!$EACHCGRAFUNENTRBLO#_fun) continue;
   /* this assert fails when in a pass without control flow graph */
   melt_assertmsg ("no cfg in each_cgraph_fun_entryblock $EACHCGRAFUNENTRBLO",
		   $EACHCGRAFUNENTRBLO#_fun->cfg != NULL);
   $EACHCGRAFUNENTRBLO#_entrybb = 
     ENTRY_BLOCK_PTR_FOR_FUNCTION ($EACHCGRAFUNENTRBLO#_fun);
   if (! $EACHCGRAFUNENTRBLO#_entrybb) continue;
   $EACHCGRAFUNENTRBLO#_exitbb = 
     EXIT_BLOCK_PTR_FOR_FUNCTION ($EACHCGRAFUNENTRBLO#_fun);
   if (! $EACHCGRAFUNENTRBLO#_exitbb) continue;
   $funtree = $EACHCGRAFUNENTRBLO#_dcl;
   $funentrybb = $EACHCGRAFUNENTRBLO#_entrybb;
   $funexitbb = $EACHCGRAFUNENTRBLO#_exitbb;
  }#
  ;;after expansion
  #{ } /* $EACHCGRAFUNENTRBLO - */ }# )


;; iterator on every cgraph_node which is a function with a CFG, and
;; retrieve its entry block, exit block, tuple of blocks, and uses a
;; temporary value TMPV
(defciterator each_cgraph_fun_call_flow_graph
  ()	      ;start formals
  eachcgrafuncfg
  (:tree funtree :basic_block funentrybb funexitbb :value bbtup tmpv)
  ;; before expansion
  #{ /* $EACHCGRAFUNCFG + */
   struct cgraph_node *$EACHCGRAFUNCFG#_nd = NULL; 
   for ($EACHCGRAFUNCFG#_nd = cgraph_nodes; 
        $EACHCGRAFUNCFG#_nd != NULL; 
        $EACHCGRAFUNCFG#_nd = $EACHCGRAFUNCFG#_nd->next) {
      tree  $EACHCGRAFUNCFG#_dcl = NULL;
      basic_block $EACHCGRAFUNCFG#_entrybb = NULL;
      basic_block $EACHCGRAFUNCFG#_exitbb = NULL;
      basic_block $EACHCGRAFUNCFG#_curbb = NULL;
      struct function *$EACHCGRAFUNCFG#_fun = NULL;
      int $EACHCGRAFUNCFG#_n_bb = 0;
      int $EACHCGRAFUNCFG#_ix = 0;
      $EACHCGRAFUNCFG#_dcl = $EACHCGRAFUNCFG#_nd->decl;
      if (! $EACHCGRAFUNCFG#_dcl) 
        continue;
      if (TREE_CODE($EACHCGRAFUNCFG#_dcl) != FUNCTION_DECL) 
        continue;
      $EACHCGRAFUNCFG#_fun = DECL_STRUCT_FUNCTION($EACHCGRAFUNCFG#_dcl);
      if (!$EACHCGRAFUNCFG#_fun) 
        continue;
      debugeprintf("$EACHCGRAFUNCFG#_fun %p", $EACHCGRAFUNCFG#_fun);
      $TMPV = NULL;
      /* this assert fails when in a pass without control flow graph */
      melt_assertmsg ("no cfg in each_cgraph_fun_call_flow_graph $EACHCGRAFUNCFG",
		   $EACHCGRAFUNCFG#_fun->cfg != NULL);
      $EACHCGRAFUNCFG#_n_bb = n_basic_blocks_for_function ($EACHCGRAFUNCFG#_fun);
      /* $EACHCGRAFUNCFG create the tuple of basic blocks */
      $BBTUP = meltgc_new_multiple
        ((meltobject_ptr_t) MELT_PREDEF (DISCR_MULTIPLE),
	 $EACHCGRAFUNCFG#_n_bb);
      for ($EACHCGRAFUNCFG#_ix = 0;
	   $EACHCGRAFUNCFG#_ix < $EACHCGRAFUNCFG#_n_bb;
	   $EACHCGRAFUNCFG#_ix ++) {
	   $EACHCGRAFUNCFG#_curbb =
	   BASIC_BLOCK_FOR_FUNCTION($EACHCGRAFUNCFG#_fun, $EACHCGRAFUNCFG#_ix);
	   if (!$EACHCGRAFUNCFG#_curbb) 
	   continue;
	   $TMPV = 
	   meltgc_new_basicblock 
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_BASIC_BLOCK),
	    $EACHCGRAFUNCFG#_curbb);
	   meltgc_multiple_put_nth ((melt_ptr_t)$BBTUP,
				    $EACHCGRAFUNCFG#_ix,
				    $TMPV);
      } /* $EACHCGRAFUNCFG done bb tuple */
      $TMPV = NULL;
  }#
  ;; after expansion
  #{ /* $EACHCGRAFUNCFG - */
     $TMPV = NULL;
   }
  }#
)

;;;;;;;;;;;;;;;;
;;;; iterate on every cgraph_node which is a declaration
(defciterator each_cgraph_decl
  ()
  eachcgrdcl
  (:tree decl)
  ;;before expansion
#{ /* $eachcgrdcl */
   struct cgraph_node *$eachcgrdcl#_nd = NULL; 
   for ($eachcgrdcl#_nd = cgraph_nodes; 
   $eachcgrdcl#_nd != NULL; 
   $eachcgrdcl#_nd = $eachcgrdcl#_nd->next) {
   tree  $eachcgrdcl#_dcl = NULL;
   $eachcgrdcl#_dcl = $eachcgrdcl#_nd->decl;
   if (!$eachcgrdcl#_dcl) continue;
   $decl = $eachcgrdcl#_dcl;
   }#
   ;; after expansion
#{ /* end $eachcgrdcl */ } }#
)


;; iterator to get the current cfun decl
(defciterator with_cfun_decl
  ()
  withcfundecl
  (:tree cfundecl)
  #{ /*before $WITHCFUNDECL*/
   if (cfun) {
     $CFUNDECL = cfun->decl;
  }#
  #{ /*after $WITHCFUNDECL*/ }
  }#)


;;; iterate on evey basicblock of the current cfun
(defciterator each_bb_current_fun
  ()					;startformals
  eachbbcurfun				;state symbol
  (					;local formals
   :basic_block curbb 
   )	
  ;;before expansion
  #{ /* start $EACHBBCURFUN */ const int $EACHBBCURFUN#_line = __LINE__;
   if (cfun && cfun->cfg) {
     basic_block  $EACHBBCURFUN#_bb = NULL;
    FOR_EACH_BB_FN($EACHBBCURFUN#_bb, cfun) {
      if (!$EACHBBCURFUN#_bb) continue;
      $CURBB  = $EACHBBCURFUN#_bb;
 }#
 ;;after expansion
 #{ }} else 
      melt_fatal_error_at_line
       ($EACHBBCURFUN#_line,
	"each_bb_current_fun used with invalid cfun=%p [$EACHBBCURFUN]", 
	cfun);
  /* end $EACHBBCURFUN */  
 }# )

;;; iterate on evey basicblock of the current cfun & its decl
(defciterator each_bb_cfun
  ()					;startformals
  eachbbcfun				;state symbol
  (					;local formals
   :basic_block cfunbb 
   :tree cfundecl
   )	
  ;;before expansion
  #{ /* start $EACHBBCFUN */ const $EACHBBCFUN#_line = __LINE__;
   if (cfun && cfun->cfg) {
     basic_block  $EACHBBCFUN#_bb = NULL;
     $cfundecl  = cfun->decl;
    FOR_EACH_BB_FN($EACHBBCFUN#_bb, cfun) {
      if (!$EACHBBCFUN#_bb) continue;
      $cfunbb  = $EACHBBCFUN#_bb;
 }#
 ;;after expansion
 #{  } /* end FOR_EACH_BB_FN $EACHBBCFUN */ 
   } else /* no cfg in $EACHBBCFUN */
      melt_fatal_error_at_line 
       ($EACHBBCFUN#_line,
	"each_bb_cfun used with invalid cfun=%p without cfg [$EACHBBCFUN]", 
	cfun);
  /* end $eachbbcfun */  
 }# )

;;; iterate on evey local declaration of the current cfun
(defciterator each_local_decl_cfun
  ()					;startformals
  eachlocalcfun				;state symbol
  (					;local formals
   :tree tlocdecl :long ix
  )
  ;;before expansion
  #{ /* start $EACHLOCALCFUN */ const int $EACHLOCALCFUN#_line = __LINE__;
   if (!cfun)
     melt_fatal_error_at_line
      ($EACHLOCALCFUN#_line,
       "each_local_decl_cfun [$EACHLOCALCFUN] called without cfun");
   if (cfun->local_decls) {
     unsigned $EACHLOCALCFUN#_ix = 0;
     tree $EACHLOCALCFUN#_tdcl = NULL_TREE;
     FOR_EACH_LOCAL_DECL (cfun, $EACHLOCALCFUN#_ix, $EACHLOCALCFUN#_tdcl) {
        $TLOCDECL = $EACHLOCALCFUN#_tdcl;
        $IX = $EACHLOCALCFUN#_ix;
  }#
  ;; after expansion
  #{ /* end $EACHLOCALCFUN */
        $TLOCDECL = NULL_TREE;
      }; /* end FOR_EACH_LOCAL_DECL $EACHLOCALCFUN */
    $EACHLOCALCFUN#_tdcl = NULL_TREE;
    $EACHLOCALCFUN#_ix = 0;
    } /* end if cfun $EACHLOCALCFUN */ 
  }#
)

;; debug_tree is ok even for nil trees
(defprimitive debugtree (:cstring msg :tree tr) :void
  #{ do {debugeprintfnonl("debugtree %s @%p /%s ", $msg, (void*)$tr, 
		       ($tr)?tree_code_name[TREE_CODE($tr)]:" *niltree*");
  if (flag_melt_debug) debug_tree($tr);}while(0)
  }#
)


;; debug_edge is ok even for nil
(defprimitive debugedge (:cstring msg :edge eg) :void
  #{ do {debugeprintfnonl("debugedge %s @%p ", $msg, (void*)$eg);
  if (flag_melt_debug) { if ($eg) dump_edge_info(stderr,$eg,1);
  fputc('\n',stderr); }
 }while(0)  }#
)

;; the basic block source of an edge
(defprimitive edge_src_bb (:edge eg) :basic_block
#{ ($eg)?($eg->src):NULL }#)

;; the basic block destination of an edge
(defprimitive edge_dest_bb (:edge eg) :basic_block
#{ ($eg)?($eg->dest):NULL }#)

;; test if an edge is for a true value of a branch
(defprimitive edge_for_true_value (:edge eg) :long
#{ ($eg && $eg->flags & EDGE_TRUE_VALUE) }#)
;; test if an edge is for a false value of a branch
(defprimitive edge_for_false_value (:edge eg) :long
#{ ($eg && $eg->flags & EDGE_FALSE_VALUE) }#)

(defprimitive debugtreecodenum  (:cstring msg :long opcod) :void
  #{ debugeprintf("debugtreecodenum %s #%ld %s", $msg, 
		  $opcod, tree_code_name[$opcod]);
}#)


(defprimitive make_gimple_mixloc (:gimple g :long num :value val dis) :value
:doc #{Make a mixed location for the location of gimple $G with value $VAL 
and discriminant $DIS, usually $DISCR_MIXED_LOCATION.}#
#{ (($g && gimple_location($g))?
    meltgc_new_mixloc((meltobject_ptr_t)($dis), (melt_ptr_t)($val), 
		      ($num), (location_t)gimple_location(($g))):NULL) }#)

;; debug_gimple_stmt is ok even for nil gimples
(defprimitive debuggimple(:cstring msg :gimple g) :void
  #{ do{debugeprintfnonl("debuggimple %s @%p /%s ", $msg , (void*)$g, 
			 ($g)?gimple_code_name[gimple_code($g)]: "*nil*");
  if ($g && gimple_location($g))
    debugeprintf_raw("{%s:%d} ", LOCATION_FILE(gimple_location($g)), 
		     LOCATION_LINE(gimple_location($g)));
  if (flag_melt_debug) debug_gimple_stmt($g);} while(0)
}# )

(defprimitive debuggimpleseq(:cstring msg :gimple_seq gs) :void
  #{ do{debugeprintf("debuggimpleseq %s @%p", $msg, (void*)$gs);
  if (flag_melt_debug && $gs) debug_gimple_seq($gs);}while(0) 
  }#)

(defprimitive debugbasicblock(:cstring msg :basic_block bb) :void
  #{ do{debugeprintf("debugbasicblock %s @%p", $msg, (void*)$bb);
  if (flag_melt_debug && $bb) debug_bb($bb);}while(0) 
}#
)


(defprimitive gimple_seq_add_stmt (:gimple_seq gs :gimple g) :void
  :doc #{Add to end of gimple_seq $GS the gimple $G if non-null. May allocate $GS if it was null.}#
  #{if ($G) gimple_seq_add_stmt (&($GS), ($G));}#
)

(defprimitive gimplify_seq_add_stmt (:gimple_seq gs :gimple g) :void
  :doc #{Add to end of gimple_seq $GS the gimple $G if non-null. May allocate $GS if it was null. 
Don't scan operands of the added $G.}#
  #{if ($G) gimplify_seq_add_stmt (&($GS), ($G));}#
)

(defprimitive gimple_seq_add_seq (:gimple_seq gsdst gssrc) :void
  :doc #{Add to end of gimple_seq $GSDST the gimple sequence $GSSRC. May allocate $GSDST.}#
  #{if ($GSSRC) gimple_seq_add_seq (&($GSDST), ($GSSRC));}#
)

(defprimitive gimple_seq_copy (:gimple_seq gs) :gimple_seq 
  :doc #{Return a deep copy of gimple_seq $GS.}#
  #{(($GS)?gimple_seq_copy(($GS)):((gimple_seq)0))}#
)

(defprimitive gimple_seq_boxed_add_stmt (bgs :gimple g) :void
  :doc #{Add to end of boxed gimple_seq $BGS the gimple $G. May fill $BGS if it contained a null gimple_seq.}#
  #{/*gimple_seq_boxed_add_stmt*/
  if (melt_magic_discr((melt_ptr_t)($BGS)) == MELTOBMAG_GIMPLESEQ && $G != (gimple)0) 
     gimple_seq_add_stmt (&(((meltgimpleseq_st*)($BGS))->val), ($G));}#
)

(defprimitive gimplify_seq_boxed_add_stmt (bgs :gimple g) :void
  :doc #{Add to end of boxed gimple_seq $BGS the gimple $G. May fill $BGS if it contained a null gimple_seq.
  Don't scan operands of the added $G.}#
  #{/*gimple_seq_boxed_add_stmt*/
  if (melt_magic_discr((melt_ptr_t)($BGS)) == MELTOBMAG_GIMPLESEQ && $G != (gimple)0) 
     gimplify_seq_add_stmt (&(((meltgimpleseq_st*)($BGS))->val), ($G));}#
)

(defprimitive gimple_seq_boxed_add_seq  (bgs :gimple_seq gs) :void
  :doc #{Add to end of boxed gimple_seq $BGS the gimple_seq $GS. May fill $BGS if it contained a null gimple_seq.}#
  #{/*gimple_seq_boxed_add_seq*/
  if (melt_magic_discr((melt_ptr_t)($BGS)) == MELTOBMAG_GIMPLESEQ && $GS != (gimple_seq)0) 
     gimple_seq_add_seq (&(((meltgimpleseq_st*)($BGS))->val), ($GS));}#
)

(defprimitive gimple_build_return (:tree tr) :gimple
  :doc #{Build a gimple to return $TR, if non-null.}#
  #{($TR)?gimple_build_return(($TR)):((gimple)0)}#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;; gimpleseq iteration
;;;; iterate on a gimpleseq
(defciterator each_in_gimpleseq
  (:gimple_seq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ;;; before expansion
  #{
   gimple_stmt_iterator gsi_$eachgimplseq;
   if ($gseq) 
     for (gsi_$eachgimplseq = gsi_start ($gseq);
	  !gsi_end_p (gsi_$eachgimplseq);
	  gsi_next (&gsi_$eachgimplseq)) {
    $g  = gsi_stmt (gsi_$eachgimplseq);
   }#
  ;;; after expansion
  #{ } }# )


;;;; reverseiterate on a gimpleseq
(defciterator reveach_in_gimpleseq
  (:gimple_seq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ;;; before expansion
  #{
   gimple_stmt_iterator gsi_$eachgimplseq;
   if ($gseq) 
     for (gsi_$eachgimplseq = gsi_last ($gseq); 
          !gsi_end_p (gsi_$eachgimplseq);
	  gsi_prev (&gsi_$eachgimplseq)) {
    $g = gsi_stmt (gsi_$eachgimplseq);
  }#
  ;;; after expansion
  #{ } }# )

;; apply a function to each boxed gimple in a gimple seq
(defun do_each_gimpleseq (f :gimple_seq gseq)
  (each_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)


;; apply a function to each boxed gimple in a gimple seq
(defun do_reveach_gimpleseq (f :gimple_seq gseq)
  (reveach_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;; basicblock iteration

(defciterator eachgimple_in_basicblock
  (:basic_block bb)			;start formals
  eachgimpbb
  (:gimple g)				;local formals
  ;;; before expansion
  #{
   /* start $eachgimpbb */ 
   gimple_stmt_iterator gsi_$eachgimpbb;
   if ($bb) 
     for (gsi_$eachgimpbb = gsi_start_bb ($bb);
          !gsi_end_p (gsi_$eachgimpbb);
          gsi_next (&gsi_$eachgimpbb)) {
       $g = gsi_stmt (gsi_$eachgimpbb);
  }#
  ;;; after expansion
  #{ } /* end $eachgimpbb */ }#  )
  

(defun do_eachgimple_in_basicblock (f :basic_block bb)
  (eachgimple_in_basicblock 
   (bb) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
   )

;;;;;;;;;;;;;;;;;;;;;;;;;;;; gimpleseq iteration
;;;; iterate on a function formal parameters
(defciterator each_param_in_fundecl
  ( :tree fundeclt )			;start formals
  eachparamfun
  ( :tree paramdclt )				;local formals
  ;;; before expansion
  #{
   /*eachparaminfunctiondecl*/
   tree $eachparamfun#_tr=NULL;
   if (($fundeclt) && TREE_CODE($fundeclt) == FUNCTION_DECL)
     for ($eachparamfun#_tr = DECL_ARGUMENTS($fundeclt);
          $eachparamfun#_tr != NULL;
          $eachparamfun#_tr = TREE_CHAIN($eachparamfun#_tr)) {
 	    $paramdclt = $eachparamfun#_tr;
  }#
  ;;; after expansion
  #{
   }/*end eachparaminfunctiondecl*/
  }# )

;;; iterate on fields of a structure
(defciterator foreach_field_in_record_type
  (:tree first_field)
  efirt
  (:tree field)

  #{   /* $EFIRT + */
       if ($first_field && TREE_CODE ($first_field) == FIELD_DECL)
       {
           tree $efirt#_current;
	   for ($efirt#_current = $first_field; 
		$efirt#_current != NULL;
		$efirt#_current = TREE_CHAIN ($efirt#_current))
	   {
	       $field = $efirt#_current;
  }#

  #{ /* $EFIRT - */
           }
       }
  }#)

;;; gimple iterator
(defun gimple_iterator (f data :gimple g)
  (each_bb_cfun
   ()
   (:basic_block body :tree header)
   (let ((:gimple_seq instructions (gimple_seq_of_basic_block body)))
     (each_in_gimpleseq
      (instructions)
      (:gimple instruction)
      (f data instruction))))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; loop related operations

(defprimitive is_loop (v) :long
   #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_LOOP)}# )

(defprimitive make_loop (discr :loop l) :value
  #{(meltgc_new_loop((meltobject_ptr_t)($discr),($l)))}# )

(defprimitive loop_content (v) :loop
  #{(melt_loop_content((melt_ptr_t)($v)))}# )


(defprimitive output_loop (out :loop lo) :void
  :doc #{Output to $OUT the loop $LO}#
  #{ meltgc_out_loop((melt_ptr_t)($OUT), ($LO)) }# )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; retrieve the loop body as a tuple of boxed basic_block-s
(defun loop_body_tuple (discr :loop lo) 
  (debugloop lo "loop_body_tuple lo")
  (if (null discr) (setq discr discr_multiple))
  (if lo
      (let ( (:long loopnbnodes 0) 
	     )
	(code_chunk 
	 getloopnbnodeschunk
	 #{/*$GETLOOPNBNODESCHUNK*/
	 $LOOPNBNODES = $LO?($LO -> num_nodes):0 ; }#
	 )
	(let ( (tupbody (make_multiple discr loopnbnodes))
	       )
	  (if (null tupbody) (return)) 
	  ;; first, fill the tuple with empty basic block boxes
	  (foreach_long_upto 
	   (0 (-i loopnbnodes 1))
	   (:long ix)
	     (multiple_put_nth 
	      tupbody ix 
	      (make_basicblock discr_basic_block (null_basicblock)))
	   )
	  (let ( (ourbb ())
		 )
	  ;; retrieve the malloc-ed array of basic blocks and use it to fill the tuple
	  ;; then free it
	  (code_chunk
	   fillbbboxeschunk
	   #{ /*$FILLBBBOXESCHUNK*/
	   long $FILLBBBOXESCHUNK#_ix = 0	       ;
	   basic_block* $FILLBBBOXESCHUNK#_bbtab = 0   ;
	   $FILLBBBOXESCHUNK#_bbtab = get_loop_body ($LO) ; /* a malloc-ed array */
	   for ($FILLBBBOXESCHUNK#_ix = 0		  ;
				      $FILLBBBOXESCHUNK#_ix < $LOOPNBNODES ;
				      $FILLBBBOXESCHUNK#_ix++) {
	   $OURBB = melt_multiple_nth ($TUPBODY, $FILLBBBOXESCHUNK#_ix)	;
	   meltgc_basicblock_updatebox
                ($OURBB, 
		 $FILLBBBOXESCHUNK#_bbtab[$FILLBBBOXESCHUNK#_ix]) ;
	   }
	   free ($FILLBBBOXESCHUNK#_bbtab), $FILLBBBOXESCHUNK#_bbtab=0 ;
	   $OURBB = (melt_ptr_t)0;
	   /*end $FILLBBBOXESCHUNK*/
	   }#)
	  )
	  (debug_msg tupbody "loop_body_tuple return tupbody")
	  (return tupbody)
	  ))))

;;; iterator to retrieve loop exit edges & iterate on them
(defciterator foreach_loop_exit_edges
  (:loop lo)				;start formal
  eachloopexitedge			;state symbol
  (:edge ed :long ix)			;local formals
  ;; before expansion
  #{ /* $EACHLOOPEXITEDGE before+ */
  VEC (edge, heap)* $EACHLOOPEXITEDGE#_edgevec = 0;
  unsigned $EACHLOOPEXITEDGE#_ix = 0;
  edge $EACHLOOPEXITEDGE#_edge = 0;
  if ($LO) 
    $EACHLOOPEXITEDGE#_edgevec = get_loop_exit_edges ($LO);
  if ($EACHLOOPEXITEDGE#_edgevec)
    FOR_EACH_VEC_ELT (edge, $EACHLOOPEXITEDGE#_edgevec, 
			    $EACHLOOPEXITEDGE#_ix, $EACHLOOPEXITEDGE#_edge) {
      if (!$EACHLOOPEXITEDGE#_edge) 
        continue;
      $ED = $EACHLOOPEXITEDGE#_edge; 
      $IX = $EACHLOOPEXITEDGE#_ix;
/* $EACHLOOPEXITEDGE before- */}#
  ;; after expansion
  #{ /* $EACHLOOPEXITEDGE after+ */
  } /* end FOR_EACH_VEC_ELT  $EACHLOOPEXITEDGE*/
  VEC_free (edge, heap, $EACHLOOPEXITEDGE#_edgevec);
  $EACHLOOPEXITEDGE#_edgevec = 0;
  $EACHLOOPEXITEDGE#_edge = 0;
/* $EACHLOOPEXITEDGE after- */}#
)
 
;; retrieve the loop exit edges as a tuple of boxed edge-s
(defun loop_exit_edges_tuple (discr :loop lo) 
  (debugloop lo "loop_exit_edges_tuple lo")
  (if (null discr) (setq discr discr_multiple))
  (let ( (:long maxix 0)
	 (edglis (make_list discr_list))
	 )
    (foreach_loop_exit_edges
     (lo)
     (:edge ed :long ix)
     (let ( (boxedge (make_edge discr_edge ed))
	    )
       (if (>=i maxix ix) (setq maxix (+i 1 ix)))
       (list_append edglis boxedge)
       ))
    (let ( (edgevec (make_multiple discr maxix))
	   (:long ix 0)
	   )
      (foreach_in_list
       (edglis)
       (curpair edgebox)
       (multiple_put_nth edgevec ix edgebox)
       (setq ix (+i ix 1)))
      (debug_msg edgevec "loop_exit_edges_tuple return edgevec")
      (return edgevec)))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; safe queries to the cfun (when cfun is null, return null or 0)
(defprimitive has_cfun () :long #{ cfun != NULL }#)

(defprimitive cfun_gimple_body () :gimple_seq 
  #{ (cfun?(cfun->gimple_body):NULL) }#)

(defprimitive cfun_decl () :tree 
  #{ (cfun?(cfun->decl):NULL) }#)

(defprimitive cfun_static_chain_decl () :tree
  #{ (cfun?(cfun->static_chain_decl):NULL) }#)

(defprimitive cfun_nonlocal_goto_save_area () :tree
  #{ (cfun?(cfun->nonlocal_goto_save_area):NULL) }#)


(defprimitive cfun_has_cfg () :long
  #{ (cfun?(cfun->cfg != NULL):0) }#)

(defprimitive cfun_cfg_entry_block () :basic_block
  #{ ((cfun && cfun->cfg)? ENTRY_BLOCK_PTR_FOR_FUNCTION(cfun):NULL) }#)

(defprimitive cfun_cfg_exit_block () :basic_block
  #{ ((cfun && cfun->cfg)? EXIT_BLOCK_PTR_FOR_FUNCTION(cfun):NULL) }#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 ==e
 ==g
 ==t
 basicblock_content
 basicblock_gimpleseq
 basicblock_nb_succ
 basicblock_phinodes
 basicblock_single_succ 
 bb_dominator_iterator
 bb_post_dominator_iterator
 build_identifier_tree
 build_int_tree
 build_string_tree
 cfun_decl
 cfun_gimple_body
 cfun_has_cfg
 cfun_cfg_entry_block
 cfun_cfg_exit_block
 cfun_nonlocal_goto_save_area
 cfun_static_chain_decl
 clear_special 
 debug_dominance_info
 debug_post_dominance_info
 debug_ppl_coefficient
 debug_ppl_constraint
 debug_ppl_linear_expression
 debug_ppl_polyhedron 
 debugbasicblock
 debugedge
 debuggimple
 debuggimpleseq
 debugloop
 debugtree
 debugtreecodenum
 dominated_by_bb_iterator
 dominated_by_other
 dominated_by_other
 each_bb_cfun
 each_local_decl_cfun
 each_bb_current_fun
 each_cgraph_decl
 each_cgraph_fun_body
 each_cgraph_fun_call_flow_graph
 each_cgraph_fun_entryblock 
 each_in_gimpleseq
 each_loop
 each_param_in_fundecl
 eachgimple_in_basicblock
 edge_content
 edge_dest_bb
 edge_for_false_value
 edge_for_true_value 
 edge_src_bb
 foreach_argument_in_function_tree
 foreach_argument_of_gimple_call
 foreach_basicblock_succ_edge
 foreach_case_of_gimple_switch
 foreach_edge_bb_preds
 foreach_edge_bb_succs
 foreach_field_in_record_type
 foreach_loop_exit_edges
 foreach_mapbasicblock
 foreach_mapedge
 foreach_mapgimple
 foreach_maploop
 foreach_maptree
 get_immediate_dominator
 get_immediate_post_dominator
 gimple_asm
 gimple_assign_binaryop
 gimple_assign_cast
 gimple_assign_ceil_div
 gimple_assign_ceil_mod
 gimple_assign_copy
 gimple_assign_exact_div
 gimple_assign_floor_div
 gimple_assign_floor_mod
 gimple_assign_minus 
 gimple_assign_mult 
 gimple_assign_plus 
 gimple_assign_pointerplus
 gimple_assign_rdiv
 gimple_assign_round_div
 gimple_assign_round_mod
 gimple_assign_single
 gimple_assign_ssa_name_copy 
 gimple_assign_trunc_div
 gimple_assign_trunc_mod
 gimple_assign_unary_minus
 gimple_assign_unary_nop
 gimple_bind
 gimple_build_assign_convert
 gimple_build_assign_fix_trunc
 gimple_build_assign_float
 gimple_build_assign_view_convert
 gimple_build_return
 gimple_call
 gimple_call_1
 gimple_call_1_more
 gimple_call_2
 gimple_call_2_more
 gimple_call_3
 gimple_call_3_more
 gimple_call_4
 gimple_call_4_more
 gimple_call_5
 gimple_call_5_more
 gimple_call_6
 gimple_call_6_more
 gimple_call_7
 gimple_call_7_more
 gimple_call_nth_arg
 gimple_cond_equal  
 gimple_cond_false
 gimple_cond_greater
 gimple_cond_greater_or_equal
 gimple_cond_less  
 gimple_cond_lessequal
 gimple_cond_notequal
 gimple_cond_true   
 gimple_cond_with_edges
 gimple_cond_with_true_false_labels
 gimple_content
 gimple_copy
 gimple_debug
 gimple_debug_bind
 gimple_error_mark_or_nil
 gimple_goto
 gimple_iterator
 gimple_label
 gimple_nop
 gimple_phi
 gimple_phi_nth_arg_def
 gimple_phi_nth_arg_edge
 gimple_return
 gimple_seq_add_seq
 gimple_seq_add_stmt
 gimple_seq_boxed_add_seq
 gimple_seq_boxed_add_stmt
 gimple_seq_copy
 gimple_seq_first_stmt
 gimple_seq_last_stmt
 gimple_seq_of_basic_block 
 gimple_switch
 gimple_switch_index
 gimple_switch_label
 gimpleseq_content 
 gimpleval
 gimplify_seq_add_stmt
 gimplify_seq_boxed_add_stmt
 has_cfun
 inform_at_gimple
 inform_at_tree
 insert_ppl_constraint_in_boxed_system 
 install_melt_gcc_pass
 is_basicblock
 is_edge
 is_gimple
 is_gimpleseq  
 is_loop
 is_mapbasicblock 
 is_mapedge
 is_mapgimple 
 is_maploop
 is_maptree
 is_tree
 isnull_tree
 isnull_basicblock
 loop_body_tuple
 loop_can_be_parallel
 loop_content
 loop_depth
 loop_exit_edges_tuple
 loop_header
 loop_index_number
 loop_inner
 loop_latch
 make_basicblock
 make_edge
 make_gimple
 make_gimple_mixloc
 make_gimpleseq
 make_loop
 make_mapbasicblock
 make_mapedge
 make_mapgimple
 make_maploop
 make_maptree
 make_ppl_constraint 
 make_ppl_linear_expression  
 make_ppl_polyhedron_cloned
 make_ppl_polyhedron_same 
 make_tree  
 mapbasicblock_count
 mapbasicblock_get
 mapbasicblock_nth_attr
 mapbasicblock_nth_val 
 mapbasicblock_put
 mapbasicblock_remove  
 mapbasicblock_size 
 mapedge_count
 mapedge_get
 mapedge_nth_attr
 mapedge_nth_val
 mapedge_put
 mapedge_remove
 mapedge_size
 mapgimple_count
 mapgimple_get
 mapgimple_nth_attr
 mapgimple_nth_val
 mapgimple_put
 mapgimple_remove
 mapgimple_size
 maploop_count
 maploop_get
 maploop_nth_attr
 maploop_nth_val
 maploop_put
 maploop_remove
 maploop_size
 maptree_count
 maptree_get
 maptree_nth_attr
 maptree_nth_val
 maptree_put
 maptree_remove
 maptree_size
 notnull_basicblock
 null_basicblock
 null_edge
 null_gimple
 null_gimpleseq
 null_tree
 number_of_loops
 output_edge
 output_loop
 pop_cfun
 post_dominated_by_other
 post_dominated_by_other
 ppl_Constraint_System_insert_Constraint
 ppl_Linear_Expression_add_to_coefficient
 ppl_Linear_Expression_add_to_inhomogeneous
 ppl_NNC_Polyhedron_from_Constraint_System  
 ppl_Polyhedron_add_constraint
 ppl_Polyhedron_is_empty 
 ppl_clone_constraint_system
 ppl_coefficient_content 
 ppl_coefficient_from_long
 ppl_coefficient_from_tree 
 ppl_constraint_content 
 ppl_constraint_system_content 
 ppl_delete_Coefficient  
 ppl_delete_Constraint  
 ppl_delete_Linear_Expression 
 ppl_delete_Polyhedron  
 ppl_new_empty_constraint_system
 ppl_new_unsatisfiable_constraint_system 
 ppl_polyhedron_content
 ppl_ppstrbuf  
 ppstrbuf_basicblock 
 ppstrbuf_gimple
 ppstrbuf_gimple_seq
 ppstrbuf_tree
 push_cfun_decl
 raw_new_ppl_empty_constraint_system
 raw_new_ppl_unsatisfiable_constraint_system
 reveach_in_gimpleseq
 tree_addr_expr
 tree_array_ref
 tree_array_ref_full
 tree_array_type
 tree_block
 tree_chain_append
 tree_chain_join
 tree_chain_prepend
 tree_component_ref
 tree_component_ref_full
 tree_component_ref_typed
 tree_content 
 tree_decl
 tree_field_decl
 tree_function_decl 
 tree_function_type
 tree_identifier
 tree_indirect_reference
 tree_integer_cst
 tree_integer_type
 tree_integer_type_bounded
 tree_list
 tree_mem_ref
 tree_of_type
 tree_parm_decl
 tree_pointer_type_p
 tree_real_cst
 tree_real_type
 tree_record_type
 tree_record_type_with_fields
 tree_ssa_name 
 tree_string_cst
 tree_type
 tree_type_declaration
 tree_uid
 tree_var_decl
 tree_var_decl_named
 tree_vec
 tree_void_type
 warning_at_gimple
 warning_at_gimple_strbuf
 warning_at_tree
 warning_at_tree_decl_with_number
 with_cfun_decl
 )

(export_class
 class_analysis_state
)
;; eof ana-base.melt
