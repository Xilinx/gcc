;; File warmelt-genobj.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-genobj.melt and 
;; to the generated file  warmelt-genobj*.c

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; value like objects
(defclass class_objvalue
  :super class_generated_c_code
  :fields ( obv_type			;the ctype
	    ))


;;; pure values are side-effect free
(defclass class_objpurevalue
  :super class_objvalue
  :fields ())

;; object local variable
;;;; disposed local variables can be reused.
(defclass class_objlocv
  :super class_objpurevalue
  :fields (obl_off			;offset in frame
	   obl_proc			;containing procedure or nil if disposed
	   obl_cname			;symbolic cname string
	   ))


;; closed occurrence
(defclass class_objcloccv
  :super class_objpurevalue
  :fields (obc_off			;offset in closure
	   obc_proc			;containing procedure
	   obc_name			;symbolic name
	   ))


;; constant [closed] occurrence
(defclass class_objconstv
  :super class_objcloccv
  :fields (
	   ))

;; predefined object
(defclass class_objpredef
  :super class_objpurevalue
  :fields (obpredef
	   ))

;; nil
(defclass class_objnil
  :super class_objpurevalue
  :fields ())

;; initial element 
(defclass class_objinitelem
  :super class_objpurevalue
  :fields (oie_cname 			;symbolic cname string - fieldname in cdat
	   oie_data			;normal data
	   oie_discr			;compiled discriminant
	   oie_locvar			;initial routine's local variable
	   ;; the size, if any is the obj_num
	   ))

;;; initial object - see MELT_OBJECT_STRUCT in melt-runtime.h
(defclass class_objinitobject
  :super class_objinitelem
  :fields (
	   oio_predef			;the predef name or number to contain this object
	   oio_class			;the class of the object
	   ))

;;; some initial objects, such as existing symbols, should not be
;;; recreated if they already exist. Use this class for them.
(defclass class_objinituniqueobject
  :super class_objinitobject
  :fields (
	   ))

  
;;; initial multiple - see MELT_MULTIPLE_STRUCT in melt-runtime.h
(defclass class_objinitmultiple
  :super class_objinitelem
  :fields (
	   ;; we may need to tuple of compiled values for accessing
	   ;; the nth at compilation time in compilobj_nrep_multacc
	   oim_tupval			;tuple of compiled values
	   ))

;;; initial closure - see MELT_CLOSURE_STRUCT in melt-runtime.h
(defclass class_objinitclosure 
  :super  class_objinitelem
  :fields (oiclo_rout			;the compiled routine of the
					;closure, useful for lambda-s
					;in letrec-s
	   ))

;;; initial routine - see  MELT_ROUTINE_STRUCT in melt-runtime.h
(defclass class_objinitroutine
  :super class_objinitelem
  :fields (
	   oir_procroutine		;the procroutine associated
	   ))

;;; initial string - see MELT_STRING_STRUCT in melt-runtime.h
(defclass class_objinitstring
  :super class_objinitelem
  :fields (
	   ))

;;; initial pair - see struct meltpair_st in melt-runtime.h
(defclass class_objinitpair
  :super class_objinitelem
  :fields ())

;;; initial list - see struct meltlist_st in melt-runtime.h
(defclass class_objinitlist
  :super class_objinitelem
  :fields ())


;;; initial boxed int - see struct meltint_st in melt-runtime.h
(defclass class_objinitboxinteger
  :super class_objinitelem
  :fields (
	   ))


;; expanded value
(defclass class_objexpv
  :super class_objvalue
  :fields (obx_cont
	   ))

;; expanded value with location 
(defclass class_objlocatedexpv
  :super class_objexpv
  :fields (obcx_loc			;optional location
	   ))

(defclass class_objflag
  :super class_objpurevalue
  :fields (obflag_matchflag
	   obflag_name
	   obflag_rank
	   ))

;;;; instructions
(defclass class_objinstr
  :super class_generated_c_code
  :fields (obi_loc			;src location
	   ))

(defclass class_objcommentinstr		;just a comment, useful only for debugging our generator
  :super class_objinstr
  :fields (obci_comment
	   ))

(defclass class_objchecksignal
  :super class_objinstr
  :fields (
	   ))

;;;; instructions with a list of destinations (computes, calls, sends, etc...)
(defclass class_objdestinstr
  :super class_objinstr
  :fields (obdi_destlist		;a list of destination lovations
	   ))

;;; compute instruction
(defclass class_objcompute
  :super class_objdestinstr
  :fields (obcpt_expr			;expression list or object or tuple
	   obcpt_type			;ctype of expression
	   ))

;; get argument instruction
(defclass class_objgetarg
  :super class_objinstr
  :fields (obarg_obloc			;objlocation
	   obarg_bind			;formal binding
	   ))

;; get argument & update rest index in variadic instruction
(defclass class_objgetargrest
  :super class_objgetarg
  :fields (obarg_rest ;name prefix of rest index, as a string
	   ))


;; put extra result instruction
(defclass class_objputxtraresult
  :super class_objinstr
  :fields (obxres_rank 			;boxed rank
	   obxres_obloc			;objlocation
	   ))

;; final return
(defclass class_objfinalreturn
  :super class_objinstr
  :fields (				;no argument
	   ))

;; clear instruction
(defclass class_objclear
  :super class_objinstr
  :fields (oclr_vloc			;varlocation to clear
	   ))



;; block instruction
(defclass class_objanyblock
  :super class_objinstr
  :fields ( oblo_bodyl			;body list
	    oblo_epil			;epilogue list
	    ))

(defclass class_objplainblock
  :super class_objanyblock
  :fields (
	   ))

;; multi-allocation block instruction, used for letrec compilation
(defclass class_objmultiallocblock
  :super class_objanyblock
  :fields ( omalblo_allstruct		;the allocated structure is a
					;tuple of class_objinitelem
	    omalblo_name		;unique name
))

;; a block with a comment string appearing in the generated code
(defclass class_objcommentedblock
  :super class_objanyblock
  :fields ( ocomblo_comment		;the comment string
	    ))


;; a block for compiling matches. We need to redistribute put_objdest
;; inside appropriately
(defclass class_objmultiblock
  :super class_objanyblock
  :fields (omulblo_subcomp		;the tuple of subcomponents
					;into which redistribute
					;destination
	   ))

;; a block for compiling new matches with flags
(defclass class_objmatchflagblock
  :super class_objanyblock
  :fields (omchflgblo_flags 		;the tuple of flags
	   ))

;; unique label instr
(defclass class_objlabelinstr
  :super class_objinstr
  :fields (oblab_prefix			;unique prefix string
	   oblab_rank			;additional rank
	   ))

;; unconditional goto label
(defclass class_objgotoinstr
  :super class_objinstr
  :fields (obgoto_prefix		;unique prefix string
	   obgoto_rank			;additional rank
	   ))

;; looping block
(defclass class_objloop
  :super class_objanyblock		 ;the body is looped, not the epilogue
  :fields (obloop_label		 ;cloned symbol
	   obloop_resv		 ;the result of the loop
	   ))

;; exit a loop
(defclass class_objexit
  :super class_objinstr
  :fields (obexit_label			;cloned symbol for goto destination
	   ))

;; start again a loop
(defclass class_objagain
  :super class_objinstr
  :fields (obagain_label			;cloned symbol for goto destination
	   ))


;; citeration block
(defclass class_objciterblock
  :super class_objanyblock
  :fields (obciter_citer
	   obciter_before
	   obciter_after
	   ))

;; conditional instruction
(defclass class_objcond
  :super class_objinstr
  :fields (obcond_test
	   obcond_then
	   obcond_else
	   ))

;; preprocessor conditional instruction
(defclass class_objcppif
  :super class_objinstr
  :fields (obifp_cond
	   obifp_then
	   obifp_else
	   ))


;;; keyword & symbol intern instruction
(defclass class_objinterncommon
  :super class_objinstr
  :fields (obintern_iobj			;the objinitobject for
					;the symbol or keyword
	   ))

(defclass class_objinternsymbol
  :super class_objinterncommon
  :fields (
	   ))

(defclass class_objinternkeyword
  :super class_objinterncommon
  :fields (
	   ))

;;; keyword & symbol getnamed instruction
(defclass class_objgetnamedcommon
  :super class_objinstr
  :fields (obgnamed_iobj		;the objinitobject for the
					;symbol or keyword
	   ))

(defclass class_objgetnamedsymbol
  :super class_objgetnamedcommon
  :fields (
	   ))

(defclass class_objgetnamedkeyword
  :super class_objgetnamedcommon
  :fields (
	   ))

;;; apply instruction
(defclass class_objapply
  :super class_objdestinstr
  :fields (obapp_clos			;closure to be applied
	   obapp_args			;argument tuple
	   ))

;;; multiapply instruction
(defclass class_objmultiapply
  :super class_objapply
  :fields (obmultapp_xres		;extraresult tuple
	   ))

;;; message send instruction
(defclass class_objmsend
  :super class_objdestinstr
  :fields (obmsnd_sel			;selector object (compiled)
	   obmsnd_recv			;message receiver (compiled)
	   obmsnd_args 			;argument tuple (compiled)
	   ))

;;; multisend instruction
(defclass class_objmultimsend
  :super class_objmsend
  :fields (obmultsnd_xres		;extraresult tuple
	   ))

;; raw object allocation instruction
(defclass class_objrawallocobj
  :super class_objdestinstr
  :fields (
	   obrallobj_class		;the class data
	   obrallobj_len		;the boxed integer length
	   obrallobj_classname		;the class name
	   ))

;; instruction for debugtracing of written or created objects, for low
;; level debug purposes using GDB, see melt_dbgtrace_write_object in
;; runtime.
(defclass class_objdbgtracewriteobj
  :super  class_objinstr
  :fields (obdtw_writtenobj		;the changed object
	   obdtw_message			;the message
	   ))


;; new closure allocation
(defclass class_objnewclosure
  :super class_objdestinstr
  :fields (obnclo_discr		     ;the discriminant
	   obnclo_rout		     ;the routine
	   obnclo_len		     ;the boxed integer length
	   ))

;; put a component inside a tuple
(defclass class_objputuple
  :super class_objinstr
  :fields (oputu_tupled			;the tuple data
	   oputu_offset			;numerical offset
	   oputu_value			;the new value
	   ))


;; put inside a pair
(defclass class_objputpair
  :super class_objinstr
  :fields (oputp_pair 			;the pair to update
	   ))

(defclass class_objputpairhead
  :super class_objputpair
  :fields (oputp_head			;the head to put
	   ))

(defclass class_objputpairtail
  :super class_objputpair
  :fields (oputp_tail			;the tail to put
	   ))

;; put the first and last inside a list
(defclass class_objputlist
  :super class_objinstr
  :fields (oputl_list			;the list to update
	   oputl_first			;the first pair
	   oputl_last			;the last pair
	   ))

;; put a slot inside an object
(defclass class_objputslot
  :super class_objinstr
  :fields ( oslot_odata			;the object data to put
	    oslot_offset		;numerical offset
	    oslot_field			;the [optional] field 
	    oslot_value			;the new value
	    ))


;; get a slot from an object
(defclass class_objgetslot
  :super class_objdestinstr
  :fields (ogetsl_obj		   ;the object to get from
	   ogetsl_field		   ;the fieldname
	   ))

;; put the routine inside a closure
(defclass class_objputclosurout
  :super class_objinstr
  :fields (opclor_clos			;the closure data
	   opclor_rout			;the routine data
	   ))

;; put a closed value inside a closure
(defclass class_objputclosedv
  :super class_objinstr
  :fields (opclov_clos			;the closure data or local
	   opclov_off 			;the boxed offset
	   opclov_cval			;the closed value
	   ))

;; likewise, but check that the closed value is notnull
(defclass class_objputclosednotnullv
  :super class_objputclosedv
  :fields (
	   ))

;; put a constant value inside a routine
(defclass class_objputroutconst
  :super class_objinstr
  :fields (oprconst_rout	 ;the routine data
	   oprconst_off		 ;the boxed offset
	   oprconst_cval	 ;the constant value
	   ))

;; likewise, but check that the constant is notnull
(defclass class_objputroutconstnotnull
  :super class_objputroutconst
  :fields (
	   ))

;; touch a value, with a tiny comment
(defclass class_objtouch
  :super class_objinstr
  :fields (otouch_val
	   otouch_comment
	   ))

;; set a predef
(defclass class_objsetpredef
  :super class_objinstr
  :fields ( ospr_object			;the object 
	    ospr_predef			;its predef rank
	    ))


;;; routines
(defclass class_routineobj
  :super class_named
  :fields (obrout_proc			;the associated procedure
	   obrout_body			;the body (a list)
	   obrout_nbval			;the boxed number of value pointers
	   obrout_nblong		;the boxed number of longs
	   obrout_others		;the list of other (nonvalue,
					;nonlongs) locals (usually C
					;pointers like tree-s,
					;cstrings, ...)
	   obrout_retval		;the main return value
	   obrout_cntciter		;the boxed counter of citerations
	   obrout_cntletrec		;the boxed counter of letrecs
	   ))

;; procedure routine
(defclass class_procroutineobj
  :super class_routineobj
  :fields (oprout_getargs		;the get arguments tuple of instructions
	   oprout_loc			;the source location
	   oprout_funam			;function name
	   oprout_restnam		;the name used for variadic arguments, or else null
	   oprout_filenum		;boxed C file number
	   ))

;; initial routine common super-class
(defclass class_initialroutineobj
  :super class_routineobj
  :fields (
	   oirout_data			;the tuple of initial data
	   oirout_prolog       ;the prologue (list of instr) before filling the data. Imports should go here!
	   oirout_fill			;the fill of the data (a list of instr)
	   ))

;; initial routine in modules
(defclass class_initial_module_routineobj
  :super class_initialroutineobj
  :fields (
	   oirout_modulename		;the module name
	   ))

;; initial routine in extensions
(defclass class_initial_extension_routineobj
  :super class_initialroutineobj
  :fields (
	   oiroutx_extendname
	   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; export the above classes
(export_class				;alphabetical order
 class_initial_extension_routineobj
 class_initial_module_routineobj
 class_initialroutineobj
 class_objagain
 class_objapply
 class_objanyblock
 class_objchecksignal
 class_objplainblock
 class_objciterblock
 class_objclear
 class_objcloccv
 class_objcommentedblock
 class_objcommentinstr
 class_objcompute
 class_objcond
 class_objconstv
 class_objcppif
 class_objdbgtracewriteobj
 class_objdestinstr
 class_objexit
 class_objexpv
 class_objfinalreturn
 class_objgetarg
 class_objgetargrest
 class_objgetnamedcommon
 class_objgetnamedkeyword
 class_objgetnamedsymbol
 class_objgetslot
 class_objgotoinstr
 class_objinitboxinteger
 class_objinitclosure
 class_objinitelem
 class_objinitlist
 class_objinitmultiple
 class_objinitobject
 class_objinitpair
 class_objinitroutine
 class_objinitstring
 class_objinituniqueobject
 class_objinstr
 class_objinterncommon
 class_objinternkeyword
 class_objinternsymbol
 class_objlabelinstr
 class_objlocatedexpv
 class_objlocv
 class_objloop
 class_objmatchflagblock
 class_objmsend
 class_objmultiallocblock
 class_objmultiapply
 class_objmultiblock
 class_objmultimsend
 class_objnewclosure
 class_objnil
 class_objpredef
 class_objpurevalue
 class_objputclosednotnullv
 class_objputclosedv
 class_objputclosurout
 class_objputlist
 class_objputpair
 class_objputpairhead
 class_objputpairtail
 class_objputroutconst
 class_objputroutconstnotnull
 class_objputslot
 class_objputuple
 class_objputxtraresult
 class_objrawallocobj
 class_objsetpredef
 class_objtouch
 class_objvalue
 class_procroutineobj
 class_routineobj
 )					;end export_class

(export_synonym class_objblock class_objplainblock)
(export_synonym class_objcheckinterrupt class_objchecksignal)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; variadic function to make an objlocatedexpv out of a macrostring
(defun make_objlocatedexp (loc cty :rest)
  (debug "make_objlocatedexp loc=" loc " cty=" cty)
  (assert_msg "make_objlocatedexp check loc" (or (null loc)
						 (is_a loc discr_mixed_location)
						 (is_a loc discr_mixed_integer)))
  (assert_msg "make_objlocatedexp check cty" (is_a cty class_ctype))
  (let ( (arglist (make_list discr_list)) 
	 )
    (forever 
     argloop
     (variadic ( () 
		 (exit argloop))
	       ( (:long l)
		 (let ( (bl (make_integerbox discr_constant_integer l))
			)
		   (list_append arglist bl)))
	       ( (:cstring s)
		 (let ( (bs (make_stringconst discr_verbatim_string s)) 
			)
		   (list_append arglist bs)))
	       ( (:value v)
		 (cond ( (is_list v)
			 (list_append2list arglist v))
		       ( (is_multiple v)
			 (foreach_in_multiple
			  (v)
			  (curcomp :long ix)
			  (list_append arglist curcomp)))
		       (:else
			(list_append arglist v))))
	       ( :else
		 (debug "make_objlocatedexp varargctype=" (variadic_ctype 0))
		 (assert_msg "unexpected variable argument for make_objlocatedexp" ()))
	       ))
    (debug "make_objlocatedexp arglist=" arglist)
    (let ( (res
	    (instance  class_objlocatedexpv
		       :obv_type cty
		       :obx_cont (list_to_multiple arglist discr_multiple)
		       :obcx_loc loc))
	   )
      (debug "make_objlocatedexp res=" res)
      (return res)
      )))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; variadic function to make an objcompute out of a macrostring
(defun make_objcompute (loc ctyp :rest)
  (debug "make_objcompute loc=" loc)
  (assert_msg "make_objcompute check loc" (or (null loc) (is_a loc discr_mixed_location)))
  (assert_msg "make_objcompute check ctyp" (is_a ctyp class_ctype))
  (let ( (arglist (make_list discr_list)) 
	 )
    (forever 
     argloop
     (variadic ( () 
		 (exit argloop))
	       ( (:long l)
		 (let ( (bl (make_integerbox discr_constant_integer l))
			)
		   (list_append arglist bl)))
	       ( (:cstring s)
		 (let ( (bs (make_stringconst discr_verbatim_string s)) 
			)
		   (list_append arglist bs)))
	       ( (:value v)
		 (cond ( (is_list v)
			 (list_append2list arglist v))
		       ( (is_multiple v)
			 (foreach_in_multiple
			  (v)
			  (curcomp :long ix)
			  (list_append arglist curcomp)))
		       (:else
			(list_append arglist v))))
	       ( :else
		 (debug "make_objcompute varargctype=" (variadic_ctype 0))
		 (assert_msg "unexpected variable argument for make_objcompute" ()))
	       ))
    (debug "make_objcompute arglist=" arglist)
    (let ( (res
	    (instance  class_objcompute
		       :obdi_destlist (make_list discr_list)
		       :obcpt_expr (list_to_multiple arglist discr_multiple)
		       :obcpt_type ctyp
		       :obi_loc loc))
	   )
      (debug "make_objcompute res=" res)
      (return res)
      )))


;;;; selector to generate the declaration of an initial
;;; receiver some objinielem
;;; argument strbuf
(defselector output_c_declinit class_selector
  :doc #{$OUTPUT_C_DECLINIT is the selector to generate the
declaration of some initial element $RECV into the string-buffer
$SBUF.}#
  :formals (recv sbuf)
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to put a destination into an objcode
;;; receiver: the objcode
;;; argument: the destination value
;;; result: the (modified) receiving objcode or its replacement
(defselector put_objdest class_selector
  )

;;; selector to generate the c code for an object
;;; receiver: the object to output
;;; arguments: 
;;;; * DECLBUF the stringbuffer for the declarations
;;;; * IMPLBUF the stringbuffer for implementations
;;;; * DEPTH an unboxed integer for indentation...
;;; result is not used

(defselector output_c_code class_selector
  :doc #{$OUTPUT_C_CODE is the selector to generate C code. $RECV is
  the receiver, $DECLBUF is the string-buffer for declarations,
  $IMPLBUF is the string-buffer for implementations, $DEPTH is the raw
  integer depth.}#
  :formals (recv declbuf implbuf :long depth)
  )

;;;; selector to generate the initial fill of some objinit
;;; receiver some objinitelem
;;; argument a stringbuffer
(defselector output_c_initial_fill class_selector
  :doc #{$OUTPUT_C_INITIAL_FILL is the selector to generate the filling of
  some initalized object $RECV. $IMPLBUF is the string-buffer for
  implementations, $PTRSTR is the string value of the pointer to fill,
  and $DEPTH is the raw integer depth.}#
  :formals (recv implbuf ptrstr :long depth)
)

;;;; selector to generate the predef fill of some objinit
;;; receiver some objinitelem
;;; argument a stringbuffer
(defselector output_c_initial_predef class_selector
  :formals (recv sbuf prtrstr :long depth)
  )

(export_values
 output_c_code
 output_c_declinit
 output_c_initial_fill
 output_c_initial_predef 
 put_objdest
 )

;; a catchall method for nrep-s (normal representations) each should
;; be separately compiled with its own method so this should never be
;; called
(defun compilobj_catchall_nrep (recv gcx)
  (debug "class_nrep compile_obj recv=" recv " gcx=" gcx)
  (let ( (discr (discrim recv)) 
	 (discrname  (unsafe_get_field :named_name discr))
	 )
    (errormsg_strv "{Internal Error} COMPILE_OBJ sent to unexpected object of class" discrname)
    (assert_msg "@@compile_obj should be implemented in nrep-s subclasses" ())
))
(install_method class_nrep compile_obj compilobj_catchall_nrep)

(defun putobjdest_catchall_objcode (recv desto)
  (debug "putobjdest_catchall_objcode recv=" recv " desto=" desto)
  (let ( (discr (discrim recv)) 
	 (discrname  (unsafe_get_field :named_name discr))
	 )
    (errormsg_strv "{Internal Error} PUT_OBJDEST sent to unexpected C-generated object of class" discrname)
    (assert_msg "@@put_objdest should be implemented in nrep-s subclasses" ())
    ))
(install_method class_generated_c_code put_objdest putobjdest_catchall_objcode)


(defun putobjdest_catchall_anydiscr (recv desto)
  (debug "putobjdest_catchall_anydiscr recv=" recv " desto=" desto)
  (outcstring_err "* putobjdest unimplemented receiver discriminant ")
  (let ( (discr (discrim recv)) 
	 (discrname  (unsafe_get_field :named_name discr))
	 )
    (errormsg_strv "{Internal Error} PUT_OBJDEST sent to unexpected value of " discrname)
  (assert_msg "@@ unexpected catchall putobjdest anydiscr" ())))
(install_method discr_any_receiver put_objdest putobjdest_catchall_anydiscr)


(defun getctype_objvalue (recv env)
  (assert_msg "check recv objvalue" (is_a recv class_objvalue))
  (unsafe_get_field :obv_type recv))
(install_method class_objvalue get_ctype getctype_objvalue)





;; nil are ctype_value
(defun gectyp_objnil (recv env)  
  ctype_value)
(install_method class_objnil get_ctype gectyp_objnil)


;; initstring-s are ctype_value
(defun gectyp_objinitstring (recv env)
  (return ctype_value))
(install_method class_objinitstring get_ctype gectyp_objinitstring)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; in the debug output routineobj-s make huge output, so print the detail only when at toplevel
(defun dbgout_routineobj (self dbgi :long depth)
  (if (<=i depth 0)
      (dbgout_namedobject_method self dbgi 0)
    (dbgout_namedobject_method self dbgi 30))
  )
(install_method class_routineobj dbg_output dbgout_routineobj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; common put destination of objdestinstr....
(defun putobjdest_objdestinstr (recv desto)
  (assert_msg "putobjdest_objdestinstr check recv" (is_a recv class_objdestinstr))
  (debug "putobjdest_objdestinstr recv=" recv " desto=" desto)
  (let ( (destl (unsafe_get_field :obdi_destlist recv)) )
    (if (not (is_list destl))
	(progn 
	  (setq destl (make_list discr_list))
	  (unsafe_put_fields recv :obdi_destlist destl)))
    (let ( (firstd (pair_head (list_first destl))) )
      (if (== firstd desto)
	  (return recv)
	(progn
	  (list_append destl desto)
	  (return recv)
	  )))))
(install_method class_objdestinstr put_objdest putobjdest_objdestinstr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; notes about code generation
;;;
;;; in addition of the code structure generated by cold-melt we
;;; need to be able to import values (hence bindings) from a start
;;; environment which is the only argument given to the generated
;;; start routine of the module


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;







;; for some reason, final returns are sometimes putobjdest-ed - a NOP here
(defun putobjdest_objfinalreturn (recv desto)
  (assert_msg "check recv" (is_a recv class_objfinalreturn))
  recv
  )
(install_method class_objfinalreturn put_objdest putobjdest_objfinalreturn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; produce the verbatim string for of a variadic symbol with a given suffix
(defun variadic_idstr (variadsym :cstring suffix)
  (match variadsym
	 (?(as_null)
	   (return ()))
	 (?(instance class_cloned_symbol
		     :named_name ?nvarnam
		     :csym_urank ?(integerbox_of ?nvarurank))
	   (assert_msg "check nvarnam" (is_string nvarnam))
	   (let ( (sbuf (make_strbuf discr_strbuf))
		  )
	     (add2sbuf_strconst sbuf "variad_")
	     (add2sbuf_cident sbuf nvarnam)
	     (add2sbuf_strconst sbuf "_c")
	     (add2sbuf_longdec sbuf nvarurank)
	     (add2sbuf_strconst sbuf suffix)
	     (strbuf2string discr_verbatim_string sbuf)
	     ))
	 (?(instance class_symbol
		     :named_name ?nvarnam)
	   (assert_msg "check nvarnam" (is_string nvarnam))
	   (let ( (sbuf (make_strbuf discr_strbuf))
		  )
	     (add2sbuf_strconst sbuf "variad_")
	     (add2sbuf_cident sbuf nvarnam)
	     (add2sbuf_strconst sbuf suffix)
	     (strbuf2string discr_verbatim_string sbuf)
	     ))
	 (?_
	  (debug "variadic_idstr bad variadsym=" variadsym)
	  (assert_msg "variadic_idstr bad variadsym")
	  ())))

(defun variadic_index_idstr (variadsym)
  :doc #{Gives the verbatim string representing the index for variadic $VARIADSYM or else null.}# 
  (variadic_idstr variadsym "_ix"))

(defun variadic_length_idstr (variadsym)
  :doc #{Gives the verbatim string representing the length for variadic $VARIADSYM or else null.}# 
  (variadic_idstr variadsym "_len"))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compile a single procedure
(defun compile2obj_procedure (pro modctx compicache :long num)
  (debug "compile2obj_procedure pro=" pro " num=" num
	 "\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n")
  (assert_msg "check pro" (is_a pro class_nrep_routproc))
  (assert_msg "check compicache" (is_mapobject compicache))
  (assert_msg "check modctx" (is_a modctx class_module_context))
  (let ( (namsbuf (make_strbuf discr_strbuf)) 
	 (routfunam ())
	 (restnam ())
	 (mofuncount  (get_field :mocx_funcount modctx))
	 (mofiles (get_field :mocx_filetuple modctx))
	 (:long funum (+i 1 (get_int mofuncount)))
	 )
    (if (is_a pro class_nrep_defunroutproc)
	(put_int mofuncount funum))
    (add2sbuf_strconst namsbuf "meltrout_")
    (add2sbuf_longdec namsbuf num)
    (add2sbuf_strconst namsbuf "_")
    (add2sbuf_cident namsbuf (get_field :mocx_modulename modctx))
    (if (is_a pro class_nrep_routproc)
	(let ( (pronam (unsafe_get_field :nrpro_name pro)) 
	       (nvariadic (unsafe_get_field :nrpro_variadic pro))
	       )
	  (if (is_a pronam class_named)
	      (progn
		(setq routfunam (unsafe_get_field :named_name pronam))
		(add2sbuf_strconst namsbuf "_")
		(add2sbuf_cident namsbuf (unsafe_get_field :named_name pronam))
		(if (is_a pronam class_cloned_symbol)
		    (progn
		      (add2sbuf_strconst namsbuf "__")
		      (add2sbuf_longdec namsbuf (get_int (get_field :csym_urank pronam)))
		      (add2sbuf_strconst namsbuf "__")
		      ))
		))
	  (if nvariadic 
	      (setq restnam nvariadic))
	  ))
    (let ( 
	  (nbody (unsafe_get_field :nproc_body pro))
	  (nloc (unsafe_get_field :nrep_loc pro))
	  (nargb (if (is_a pro class_nrep_routproc) (unsafe_get_field :nrpro_argb pro)))
	  (obodylist (make_list discr_list))
	  ;; the number 25 below is the ratio of number of functions
	  ;; per secondary generated C file. Change it carefully!  the
	  ;; offset 20 helps to make the first file less big, since it
	  ;; already contains the huge initialization functions. 
	  (:long filenum (/iraw (+i funum 20) 25))
	  (:long nbfiles (multiple_length mofiles))
	  (obrout (instance class_procroutineobj
			    :named_name (strbuf2string discr_string namsbuf)
			    :obrout_proc pro
			    :obrout_body obodylist
			    :obrout_nbval (make_integerbox discr_integer 0)
			    :obrout_nblong (make_integerbox discr_integer 0)
			    :obrout_others (make_list discr_list)
			    :obrout_cntciter (make_integerbox discr_integer 0)
			    :obrout_cntletrec (make_integerbox discr_integer 0)
			    :oprout_loc nloc
			    :oprout_funam routfunam
			    :oprout_filenum (make_integerbox discr_constant_integer filenum)
			    :oprout_restnam restnam
			    )) 
	  (locmap (make_mapobject discr_map_objects (+i 20 (*i 3 (multiple_length nargb)))))
	  (gcx (instance class_c_generation_context
			 :gncx_objrout obrout
			 :gncx_locmap locmap
			 :gncx_freeptrlist (make_list discr_list)
			 :gncx_freelonglist (make_list discr_list)
			 :gncx_freeothermaps (make_mapobject discr_map_objects 20)
			 :gncx_compicache compicache
			 :gncx_modulcontext modctx
			 :gncx_matchmap (make_mapobject discr_map_objects 40)
			 ))
	  (retloc 
	   (let ( (retl (get_free_objlocptr gcx '_retval_)) )
	     (unsafe_put_fields gcx :gncx_retloc retl)
	     retl))
	  (gtatup 
	   (multiple_map 
	    nargb
	    (lambda (bnd :long ix)
	      (assert_msg "check bnd" (is_a bnd class_formal_binding))
	      (let ( (bctyp (unsafe_get_field :fbind_type bnd)) 
		     (bnam (unsafe_get_field :binder bnd))
		     (oloc 
		      (cond ( (== bctyp ctype_value)
			      (get_free_objlocptr gcx bnam) )
			    ( (== bctyp ctype_long)
			      (get_free_objloclong gcx bnam) )
			    (:else
			     (get_free_objloctyped gcx bnam bctyp)))
		      ) 
		     (ogarg
		      (if restnam
			  (instance class_objgetargrest
				    :obi_loc nloc
				    :obarg_obloc oloc
				    :obarg_bind bnd
				    :obarg_rest restnam)
			(instance class_objgetarg
				  :obi_loc nloc
				  :obarg_obloc oloc
				  :obarg_bind bnd)))
		     )
		(if (and (<=i ix 0) (!= bctyp ctype_value))
		    (error_plain nloc "first argument of function should be a value"))
		(debug "compile2obj_procedure formal bnd=" bnd " oloc=" oloc)
		(mapobject_put locmap bnd oloc)
		ogarg
		))
	    ))
	  )
;;; grow the file tuple if needed
      (if (>=i filenum nbfiles)
	  (let ( (:long newnbfiles (+i nbfiles (+i 2 (/iraw filenum 4))))
		 (newfiletup (make_multiple discr_multiple newnbfiles))
		 )
	    (put_fields modctx :mocx_filetuple newfiletup)
	    (foreach_in_multiple 
	     (mofiles)
	     (curfile :long curix)
	     (multiple_put_nth newfiletup curix curfile))
	    ))
      ;; associate the procedure with its objroutine in the compiler cache
      (mapobject_put compicache pro obrout)
      (unsafe_put_fields obrout :oprout_getargs gtatup)
      (debug obrout "compile2obj_procedure obrout=" obrout " nbody=" nbody)
      (assert_msg "check nbody" (is_a nbody class_nrep))
      (if (is_a pro class_nrep_routproc)
	  (let ( (pthuls (unsafe_get_field :nrpro_thunklist pro)) )
	    (debug "compile2obj_procedure pthuls=" pthuls)
	    (list_every 
	     pthuls
	     (lambda (pthu) 
	       (debug "compile2obj_procedure pthu=" pthu)
	       (assert_msg "compile2obj_procedure check pthu" (is_closure pthu))
	       (pthu gcx)
	       )
	     )))
      (let ( (obody (compile_obj nbody gcx)) 
	     )
	(debug "compile2obj_procedure obody=" obody)
	(list_append obodylist obody)
	)
      (debug "compile2obj_procedure return obrout=" obrout)
      obrout
      )))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  the initial routine uses the initial system data ...
(definstance initialsystemdata_objpredef class_objpredef
  :obv_type ctype_value
  :obpredef 'INITIAL_SYSTEM_DATA
  )

(defun append_comment (ilist comstr iloc)
  (list_append ilist (instance class_objcommentinstr :obi_loc iloc :obci_comment comstr)))
(defun append_commentconst (ilist :cstring comment :value iloc)
  (list_append ilist (instance class_objcommentinstr :obi_loc iloc :obci_comment (make_stringconst discr_string comment))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile the initial procedure into an object
(defun compile2obj_initproc (ipro modctx idata compicache procurmodenvlist importvalues)
  (debug "compile2obj_initproc ipro=" ipro 
	 "\n* modctx=" modctx "\n* compicache=" compicache
	 "\n* procurmodenvlist=" procurmodenvlist 
	 "\n* importvalues=" importvalues
	 "\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n"
	 )
  (assert_msg "check ipro" (is_a ipro class_nrep_initproc))
  (assert_msg "check idata" (is_list idata))
  (assert_msg "check modctx" (is_a modctx class_module_context))
  (assert_msg "check compicache" (is_mapobject compicache))
  (assert_msg "check importvalues" (is_list importvalues))
  (let ((locmap (make_mapobject discr_map_objects 50))
	(oiniprolog (make_list discr_list))
	(oinibody (make_list discr_list))
	(oinitrout
	 (instance class_initial_module_routineobj
		   ;; Change the "melt_start_this_module" name with
		   ;; great care, it is known by the MELT runtime, and
		   ;; some functions of warmelt-outobj.melt are
		   ;; hardwiring it, e.g. thru emission of struct
		   ;; frame_melt_start_this_module_st or elsewhere.
		   :named_name '"melt_start_this_module"
		   :obrout_proc ipro
		   :obrout_body oinibody
		   :obrout_nbval (make_integerbox discr_integer 0)
		   :obrout_nblong (make_integerbox discr_integer 0)
		   :obrout_others (make_list discr_list)
		   :obrout_cntciter (make_integerbox discr_integer 0)
		   :obrout_cntletrec (make_integerbox discr_integer 0)
		   :oirout_fill (make_list discr_list)
		   :oirout_prolog oiniprolog
		   :oirout_modulename (get_field :mocx_modulename modctx)
		   ))
	(importmap (make_mapobject discr_map_objects 50))
	(gcx (instance 
	      class_initial_generation_context
	      :gncx_objrout oinitrout
	      :gncx_locmap locmap
	      :gncx_freeptrlist (make_list discr_list)
	      :gncx_freelonglist (make_list discr_list)
	      :gncx_freeothermaps (make_mapobject discr_map_objects 20)
	      :gncx_compicache compicache
	      :gncx_modulcontext modctx
	      :gncx_matchmap (make_mapobject discr_map_objects 60)
	      :igncx_procurmodenvlist
	      (list_map 
	       procurmodenvlist
	       (lambda (curpro)
		 (debug "compile2obj_initproc procurmodenvlist curpro=" curpro)
		 (let ( (curou (mapobject_get compicache curpro)) )
		   (debug "compile2obj_initproc procurmodenvlist curou=" curou)
		   (assert_msg "check curou" (is_object curou))
		   curou)))
	      ;; perhaps we should store not a list of procedures, but their matching routines
	      :igncx_importmap importmap
	      ))
	(retinit 
	 (let ( (reti (get_free_objlocptr gcx '_retinit_)) )
	   (unsafe_put_fields gcx :gncx_retloc reti)
	   (unsafe_put_fields oinitrout :obrout_retval reti)
	   reti))
	(boxloc
	 (let ( (boxl (get_free_objlocptr gcx '_contenv_)) )
	   (put_fields gcx :igncx_contenvloc boxl)
	   boxl))
	(ofreshenv  (get_free_objlocptr gcx '_freshenv_))
	(oprevenv  (let ( (preve (get_free_objlocptr gcx '_prevenv_))
			  )
		     (put_fields gcx :igncx_prevenvloc preve)
		     preve))
	(ovalueexporter (get_free_objlocptr gcx '_valexport_)) 
	(ovalueimporter (get_free_objlocptr gcx '_valimport_))
	(inidefbinds (get_field :ninit_defbinds ipro))
	)
    (append_commentconst oinibody "start of oinibody")
    (debug boxloc "compile2obj_initproc boxloc=" boxloc " inidefbinds=" inidefbinds)
    ;;; reserve location for defined values
    (foreach_in_list
     (inidefbinds)
     (curpair curdefbind)
     (debug "compile2obj_initproc curdefbind=" curdefbind
	    " of discrim=" (discrim curdefbind))
     (let ( (inidefsymb (get_field :binder curdefbind))
	    (oinisym (get_field :fixbind_data curdefbind))
	    (oinidefloc (get_free_objlocptr gcx inidefsymb))
	   )
       (debug "compile2obj_initproc oinidefloc=" oinidefloc " oinisym=" oinisym
	      " of discrim:" (discrim oinisym)
	      " curdefbind=" curdefbind)
       ;;oinisym is often a class_nrep_locsymocc but can be a
       ;;class_nrep_defined_constant
       (assert_msg "check oinisym" (is_a oinisym class_nrep_simple))
       (mapobject_put locmap curdefbind oinidefloc)
     ))
    ;; create a commentedblock to compute the new environemnt box in boxloc if it is null 
    (let (
	  ;; block to compute boxloc
	  (ocomputboxloc
	   (let ( (bodfel (make_list discr_list)) 
		  )
	     (append_commentconst bodfel "start computing boxloc")
	     ;; retrieve the fresh_env from the systemdata
	     (list_append bodfel
			  (instance class_objgetslot
				    :obdi_destlist (list ofreshenv)
				    :ogetsl_obj initialsystemdata_objpredef 
				    :ogetsl_field sysdata_cont_fresh_env))
	     ;; always generate a test for fresh_env being a closure if the oprevenv exists
	     (list_append 
	      bodfel
	      (make_objcompute 
	       ()
	       ctype_void
	       ##{/*checkfreshenv*/ if (($OPREVENV)
					&& melt_magic_discr((melt_ptr_t)($OFRESHENV)) != MELTOBMAG_CLOSURE)
  	           warning(0, "MELT corruption: bad FRESH_ENV @%p in system data <%s:%d>",
			      (void*) ($OFRESHENV), __FILE__, __LINE__);}#
		   )
	      )
	     ;; generate the apply of ofreshenv
	     (list_append
	      bodfel
	      (instance class_objapply
			:obdi_destlist (list boxloc)
			:obapp_clos ofreshenv
			:obapp_args (tuple oprevenv)))
	     ;; ocomputboxloc is this block
	     (instance class_objcommentedblock
		       :oblo_bodyl bodfel
		       :oblo_epil ()
		       :ocomblo_comment (make_stringconst discr_string "compute fresh module environment")))
	   )
	  ;; cond to test boxloc & compute it if null and if the initial_system_data is a valid object
	  (otestcomputboxloc 
	   (instance class_objcond
		     :obcond_test
		     (instance
		      class_objexpv 
		      :obx_cont (tuple
				 boxloc
				 (make_stringconst discr_verbatim_string
						   " || melt_object_length((melt_ptr_t) MELT_PREDEF (INITIAL_SYSTEM_DATA))<MELTFIELD_SYSDATA_CONT_FRESH_ENV"
						   )
				 ))
		     :obcond_then ()
		     :obcond_else ocomputboxloc))
	  ;;
	  (limplocv
	   (list_map 
	    importvalues
	    (lambda (ival)
	      (debug "compile2obj_initproc imported ival=" ival)
	      (assert_msg "check ival" (is_a ival class_nrep_importedval))
	      (let ( (isym (unsafe_get_field :nimport_symb ival)) 
		     (ilocv (get_free_objlocptr gcx isym))
		     )
		(debug "compile2obj_initproc imported ilocv=" ilocv)
		(mapobject_put importmap isym ilocv)
		ilocv
		))))
	  )
      (debug "compile2obj_initproc otestcomputboxloc=" otestcomputboxloc)
      ;; the prologue starts by getting the previous environment from the
      ;; modargp_ unique argument
      (let ( (lisdest (make_list discr_list)) )
	(list_append lisdest oprevenv)
	(append_commentconst oiniprolog "get previous environment")
	(list_append oiniprolog
		     (instance class_objcompute
			       :obdi_destlist lisdest
			       :obcpt_type ctype_value
			       :obcpt_expr (make_stringconst discr_verbatim_string "/*getprevenv*/ (melt_ptr_t) modargp_"))
		     )
	)
      (append_commentconst oiniprolog "compute boxloc")
      ;; we compute the boxloc at first
      (list_append oiniprolog otestcomputboxloc)
      ;; the tuple to compile the body
      (let (
	    (odatatup 
	     (list_to_multiple
	      idata discr_multiple
	      (lambda (curdat)
		(assert_msg "check curdat" (is_a curdat class_nrep_bound_data))
		(let ( (curobd (compile_obj curdat gcx)) )
		  curobd))))
	    (toplis (unsafe_get_field :ninit_topl ipro)) 
	    )
	(unsafe_put_fields oinitrout
			   :oirout_data odatatup)
	(assert_msg "check toplis" (is_list_or_null toplis))
	;; compile the toplevels
	(let ( (objtoplis 
		(list_map
		 toplis
		 (lambda (curtop)
		   (let ( (otop (compile_obj curtop gcx)) )
		     (debug "compile2obj_initproc otop=" otop)
		     otop)))) 
	       )
	  ;; generate the getting of symbols & keywords
	  (append_commentconst oiniprolog "get symbols & keywords")
	  (multiple_every
	   odatatup
	   (lambda (curpdat :long curk) 
	     (if (is_a curpdat class_objinitobject)
		 (let ( (odat (unsafe_get_field :oie_data curpdat))
			)
		   (debug "compile2obj_initproc getting curpdat=" curpdat)
		   (cond 
		    ;; first  check for keywords, since they are also symbols (so order is important)
		    ( (is_a odat class_nrep_datakeyword)
		      (let ( (ogkw (instance class_objgetnamedkeyword
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogkw)
			(debug "compile2obj_initproc added keyword getting ogkw=" ogkw)
			))
		    ( (is_a odat class_nrep_datasymbol)
		      (let ( (ogsy (instance class_objgetnamedsymbol
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogsy)
			(debug "compile2obj_initproc added symbol getting ogsy=" ogsy)
			))
		    )))))
	  ;; get the value importer if needed
	  (if (>i (mapobject_count importmap) 0)
	      (progn
		(append_commentconst oiniprolog "get the value importer")
		(list_append oiniprolog
			     (instance class_objgetslot
				       :obdi_destlist (list ovalueimporter)
				       :ogetsl_obj initialsystemdata_objpredef 
				       :ogetsl_field sysdata_value_importer))
		))
	  (if (>i (list_length importvalues) 0)
	      (progn
		(append_commentconst oiniprolog "before getting imported values")
		;; generate the getting of imported values
		(list_every
		 importvalues
		 (lambda (curimport)
		   (debug "compile2obj_initproc curimport=" curimport)
		   (assert_msg "check curimport" (is_a curimport class_nrep_importedval))
		   (compile_warning "the generated import should have a cstring")
		   (let ( (impsym (unsafe_get_field :nimport_symb curimport)) 
			  (impsydat (unsafe_get_field :nimport_sydata curimport))
			  (impsymstr (get_field :named_name impsym))
			  (modulstr (get_field :mocx_modulename modctx)) 
			  (osymdat (compile_obj impsydat gcx))
			  (oimplocv (mapobject_get importmap impsym))
			  (oimpappl (instance class_objapply
					      :obdi_destlist (list oimplocv)
					      :obapp_clos ovalueimporter
					      :obapp_args (tuple osymdat oprevenv impsymstr modulstr)))
			  )
		     (list_append oiniprolog oimpappl)
		     )))
		(append_commentconst oiniprolog "after getting imported values")
		))
	  ;; append the compiled toplevel
	  (append_commentconst oinibody "before toplevel body")
	  (list_every 
	   objtoplis
	   (lambda (curobjt)
	     (list_append oinibody curobjt)))
	  (append_commentconst oinibody "after toplevel body")
	  ;; we compute the boxloc again
	  (append_commentconst oinibody "compute boxloc again")
	  (list_append oinibody otestcomputboxloc)
	  (append_commentconst oinibody "intern symbols")
	  ;; generate interning of symbols & keywords
	  (multiple_every
	   odatatup
	   (lambda (curpdat :long curk) 
	     (if (is_a curpdat class_objinitobject)
		 (let ( (odat (unsafe_get_field :oie_data curpdat))
			)
		   (debug "compile2obj_initproc interning curpdat=" curpdat)
		   (cond 
		    ;; first  check for keywords, since they are also symbols (so order is important)
		    ( (is_a odat class_nrep_datakeyword)
		      (let ( (oikw (instance class_objinternkeyword
					     :obintern_iobj curpdat))
			     )
			(list_append oinibody oikw)
			(debug "compile2obj_initproc added keyword interning oikw=" oikw)
			))
		    ( (is_a odat class_nrep_datasymbol)
		      (let ( (oisy (instance class_objinternsymbol
					     :obintern_iobj curpdat))
			     )
			(list_append oinibody oisy)
			(debug "compile2obj_initproc added symbol interning oisy=" oisy)
			))
		    )))))
	  )				;end of toplevels
	(append_commentconst oinibody "set retinit from boxloc")
	;; emit setting the retinit from the boxloc
	(let ( (osetretinit
		(make_objcompute () ctype_value
				 ##{/* finalfreshenvget */ melt_reference_value((melt_ptr_t)($BOXLOC))}#))
	       )
	  (put_objdest osetretinit retinit)
	  (debug "compile2obj_initproc adding osetretinit=" osetretinit)
	  (list_append oinibody osetretinit))
;;; ending
	(append_commentconst oinibody "end the initproc")
	(debug "compile2obj_initproc final oinibody=" oinibody " gcx=" gcx " oinitrout=" oinitrout)
	(return oinitrout)
	))))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; this function is similar to compile2obj_initproc but they are some differences
;; it compiles the initial routine for runtime evaluation
(defun compile2obj_initextendproc (ipro modctx idata compicache procurmodenvlist importvalues)
  (debug "compile2obj_initextendproc ipro=" ipro 
	 "\n* modctx=" modctx "\n* compicache=" compicache
	 "\n* procurmodenvlist=" procurmodenvlist 
	 "\n* importvalues=" importvalues
	 "\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n"
	 )
  (assert_msg "check ipro" (is_a ipro class_nrep_initextendproc))
  (assert_msg "check idata" (is_list idata))
  (assert_msg "check modctx" (is_a modctx class_module_context))
  (assert_msg "check compicache" (is_mapobject compicache))
  (assert_msg "check importvalues" (is_list importvalues))
  (let ( (locmap (make_mapobject discr_map_objects 50))
	 (oiniprolog (make_list discr_list))
	 (oinibody (make_list discr_list))
	 (oinitxrout 
	  (instance class_initial_extension_routineobj
		    ;; change carefully the name, since the runtime
		    ;; should know it, notably its
		    ;; meltgc_run_c_extension function
		    :named_name '"melt_start_run_extension"
		    :obrout_proc ipro
		    :obrout_body oinibody
		    :obrout_nbval (make_integerbox discr_integer 0)
		    :obrout_nblong (make_integerbox discr_integer 0)
		    :obrout_others (make_list discr_list)
		    :obrout_cntciter (make_integerbox discr_integer 0)
		    :obrout_cntletrec (make_integerbox discr_integer 0)
		    :oirout_fill (make_list discr_list)
		    :oirout_prolog oiniprolog
		    :oiroutx_extendname (get_field :mocx_modulename modctx)
		    ))
	 (importmap (make_mapobject discr_map_objects 10))
	 (valoclist (make_list discr_list))
	 ;; running expressions are usually smaller
	 (gcx (instance 
	       class_extension_generation_context
	       :gncx_objrout oinitxrout
	       :gncx_locmap locmap
	       :gncx_freeptrlist (make_list discr_list)
	       :gncx_freelonglist (make_list discr_list)
	       :gncx_freeothermaps (make_mapobject discr_map_objects 10)
	       :gncx_compicache compicache
	       :gncx_modulcontext modctx
	       :gncx_matchmap (make_mapobject discr_map_objects 20)
	       :igncx_procurmodenvlist
	       (list_map 
		procurmodenvlist
		(lambda (curpro)
		  (debug "compile2obj_initextendproc procurmodenvlist curpro=" curpro)
		  (let ( (curou (mapobject_get compicache curpro)) )
		    (debug "compile2obj_initextendproc procurmodenvlist curou=" curou)
		    (assert_msg "check curou" (is_object curou))
		    curou)))
	       ;; perhaps we should store not a list of procedures, but their matching routines
	       :igncx_importmap importmap
	       :egncx_valoclist valoclist
	       ))
	 ;; reserve stack location for the return value
	 (retinit 
	  (let ( (reti (get_free_objlocptr gcx '_retruninit_)) )
	    (put_fields gcx :gncx_retloc reti)
	    (put_fields oinitxrout :obrout_retval reti)
	    reti))
	 ;; reserve stack location for the current environment box container
	 (ocurenvboxloc
	  (let ( (boxl (get_free_objlocptr gcx '_ocurenvboxloc_)) )
	    (put_fields gcx :igncx_contenvloc boxl)
	    boxl))
	 ;; reserve stack location for the previous environment
	 (oprevenvloc
	  (let ( (boxl (get_free_objlocptr gcx '_prevenvloc_)) )
	    (put_fields gcx :igncx_prevenvloc boxl)
	    boxl))
	 ;; reserve stack location for the tuple of literal values
	 (olitvaluetuploc
	  (let ( (boxl (get_free_objlocptr gcx '_olitvaluetuploc_)) )
	    (put_fields gcx :egncx_litvaltuploc boxl)
	    boxl))
	 ;; stack location for the value exporter and importer
	 (ovalueexporter (get_free_objlocptr gcx '_valexport_)) 
	 (ovalueimporter (get_free_objlocptr gcx '_valimport_))
	 ;; initial defined bindings
	 (inidefbinds (get_field :ninit_defbinds ipro))
	 )
    (append_commentconst oinibody "start of oinibody")
    (debug "compile2obj_initextendproc ocurenvboxloc=" ocurenvboxloc " inidefbinds=" inidefbinds)
    ;; reserve location for defined values
    (foreach_in_list
     (inidefbinds)
     (curpair curdefbind)
     (debug "compile2obj_initextendproc curdefbind=" curdefbind
	    " of discrim=" (discrim curdefbind))
     (let ( (inidefsymb (get_field :binder curdefbind))
	    (oinisym (get_field :fixbind_data curdefbind))
	    (oinidefloc (get_free_objlocptr gcx inidefsymb))
	    )
       (debug "compile2obj_initextendproc oinidefloc=" oinidefloc " oinisym=" oinisym
	      " of discrim:" (discrim oinisym)
	      " curdefbind=" curdefbind)
       ;;oinisym is often a class_nrep_locsymocc but can be a
       ;;class_nrep_defined_constant
       (assert_msg "check oinisym" (is_a oinisym class_nrep_simple))
       (mapobject_put locmap curdefbind oinidefloc)
       ))
    (debug "compile2obj_initextendproc updated locmap=" locmap)
    (let (
	  (limplocv
	   (list_map 
	    importvalues
	    (lambda (ival)
	      (debug "compile2obj_initextendproc imported ival=" ival)
	      (assert_msg "check ival" (is_a ival class_nrep_importedval))
	      (let ( (isym (unsafe_get_field :nimport_symb ival)) 
		     (ilocv (get_free_objlocptr gcx isym))
		     )
		(debug "compile2obj_initextendproc imported ilocv=" ilocv)
		(mapobject_put importmap isym ilocv)
		ilocv
		))))
	  )
      (debug "compile2obj_initextendproc limplocv=" limplocv)
      ;;
      ;; the prologue start by getting the the current environment
      ;; reference and the raw value tuple
      (list_append oiniprolog
		   (make_objlocatedexp 
		    () ctype_void
		    ##{/*initextendproc get boxcurenv*/ $OCURENVBOXLOC = meltrunboxcurenv_p ;}#
		    ))
      (list_append oiniprolog
		   (make_objlocatedexp 
		    () ctype_void
		    ##{/*initextendproc get litvaluetup*/ $OLITVALUETUPLOC  = meltrunlitvaltup_p ;}#
		    ))
      (debug "compile2obj_initextendproc before body oiniprolog=" oiniprolog)
      ;; now handle the body
      ;; the tuple to compile the body
      (let (
	    (odatatup 
	     (list_to_multiple
	      idata discr_multiple
	      (lambda (curdat)
		(assert_msg "check curdat" (is_a curdat class_nrep_bound_data))
		(let ( (curobd (compile_obj curdat gcx)) )
		  curobd))))
	    (toplis (unsafe_get_field :ninit_topl ipro)) 
	    )
	(put_fields oinitxrout
		    :oirout_data odatatup)
	(assert_msg "check toplis" (is_list_or_null toplis))
	;; compile the toplevels
	(let ( (objtoplis 
		(list_map
		 toplis
		 (lambda (curtop)
		   (let ( (otop (compile_obj curtop gcx)) )
		     (debug "compile2obj_initextendproc otop=" otop)
		     otop)))) 
	       )
	  ;; generate the getting of symbols & keywords
	  (append_commentconst oiniprolog "get symbols & keywords")
	  (multiple_every
	   odatatup
	   (lambda (curpdat :long curk) 
	     (if (is_a curpdat class_objinitobject)
		 (let ( (odat (unsafe_get_field :oie_data curpdat))
			)
		   (debug "compile2obj_initextendproc getting curpdat=" curpdat)
		   (cond 
		    ;; first  check for keywords, since they are also symbols (so order is important)
		    ( (is_a odat class_nrep_datakeyword)
		      (let ( (ogkw (instance class_objgetnamedkeyword
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogkw)
			(debug "compile2obj_initextendproc added keyword getting ogkw=" ogkw)
			))
		    ( (is_a odat class_nrep_datasymbol)
		      (let ( (ogsy (instance class_objgetnamedsymbol
					     :obgnamed_iobj curpdat))
			     )
			(list_append oiniprolog ogsy)
			(debug "compile2obj_initextendproc added symbol getting ogsy=" ogsy)
			))
		    )))))
	  ;; get the value importer if needed
	  (if (>i (mapobject_count importmap) 0)
	      (progn
		(append_commentconst oiniprolog "get the value importer")
		(list_append oiniprolog
			     (instance class_objgetslot
				       :obdi_destlist (list ovalueimporter)
				       :ogetsl_obj initialsystemdata_objpredef 
				       :ogetsl_field sysdata_value_importer))
		))
	  (if (>i (list_length importvalues) 0)
	      (progn
		(append_commentconst oiniprolog "before getting imported values")
		;; generate the getting of imported values
		(list_every
		 importvalues
		 (lambda (curimport)
		   (debug "compile2obj_initextendproc curimport=" curimport)
		   (assert_msg "check curimport" (is_a curimport class_nrep_importedval))
		   (compile_warning "the generated import should have a cstring")
		   (let ( (impsym (unsafe_get_field :nimport_symb curimport)) 
			  (impsydat (unsafe_get_field :nimport_sydata curimport))
			  (impsymstr (get_field :named_name impsym))
			  (modulstr (get_field :mocx_modulename modctx)) 
			  (osymdat (compile_obj impsydat gcx))
			  (oimplocv (mapobject_get importmap impsym))
			  (oimpappl (instance class_objapply
					      :obdi_destlist (list oimplocv)
					      :obapp_clos ovalueimporter
					      :obapp_args (tuple osymdat oprevenvloc impsymstr modulstr)))
			  )
		     (list_append oiniprolog oimpappl)
		     )))
		(append_commentconst oiniprolog "after getting imported values")
		))
	  ;; append the compiled toplevel
	  (append_commentconst oinibody "before toplevel body")
	  (list_every 
	   objtoplis
	   (lambda (curobjt)
	     (list_append oinibody curobjt)))
	  (append_commentconst oinibody "after toplevel body")
	  ;;
	  (debug "compile2obj_initextendproc oinibody=" oinibody)
	  ;;
	  (assert_msg "@$@compile2obj_initextendproc unimplemented")
	  )))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values 
 compile2obj_initproc
 compile2obj_initextendproc
 compile2obj_procedure
 variadic_index_idstr
 variadic_length_idstr
 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;function to get a free local value pointer for some name
;; any free ptr is only reused for its offset. the objlocv is not reused...
(defun get_free_objlocptr (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "get_free_objlocptr start nam=" nam)
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freeptrlist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    (if (not (is_a orout class_routineobj))
	(debug "get_free_objlocptr bad orout=" orout))
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (debug "get_free_objlocptr pfree=" pfree)
	  (assert_msg "get_free_objlocptr check offpfree" (is_integerbox offpfree))
	  ;; check that pfree has no objnum so was unused 
	  (assert_msg "check pfree not used" (not (get_int pfree)))
	  (setq off (get_int offpfree)))
      (let ( (nbvalorout (unsafe_get_field :obrout_nbval orout)) )
	(setq off (get_int nbvalorout))
	))
    (assert_msg "check off" (>=i off 0))
    (let ( (nbvalbox (unsafe_get_field :obrout_nbval orout)) 
	   (:long nbval (get_int nbvalbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (let ( (namstr (unsafe_get_field :named_name nam)) )
		(add2sbuf_cident nambuf namstr)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam)))
      (add2sbuf_strconst nambuf "__V")
      (add2sbuf_longdec nambuf (+i nbval 1))
      (put_int nbvalbox (+i nbval 1))
      (let ( (namstr (strbuf2string discr_string nambuf))
	     (oldnbvalbox (make_integerbox discr_integer nbval))
	     (nloc (instance class_objlocv
			     :obv_type ctype_value
			     :obl_off (make_integerbox discr_integer off)
			     :obl_proc orout
			     :obl_cname namstr)) 
	     )
	(debug "get_free_objlocptr new nloc" nloc)
	(return nloc)
	))))



;;; function to get a free local long for some name
(defun get_free_objloclong (gcx nam)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "get_free_objloclong start nam=" nam)
  ;(shortbacktrace_dbg "get_free_objloclong start" 12)
  (let ( (orout (unsafe_get_field :gncx_objrout gcx))
	 (freeli (unsafe_get_field :gncx_freelonglist gcx)) 
	 (pfree (list_popfirst freeli))
	 (:long off -1)
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (if (is_a pfree  class_objlocv)
	(let ( (offpfree (unsafe_get_field :obl_off pfree)) )
	  (debug "get_free_objloclong pfree" pfree)
	  (assert_msg "check offpfree" (is_integerbox offpfree))
	  ;; check that pfree has no objnum so was unused 
	  (assert_msg "check pfree not used" (not (get_int pfree)))
	  (setq off (get_int offpfree)))
      (let ( (nblongorout (unsafe_get_field :obrout_nblong orout)) )
	(assert_msg "check nblongorout" (is_integerbox nblongorout))
	(setq off (get_int nblongorout))))
    (assert_msg "check off" (>=i off 0))
    (let ( (nblongbox (unsafe_get_field :obrout_nblong orout)) 
	   (:long nblong (get_int nblongbox))  
	   (nambuf (make_strbuf discr_strbuf))
	   )
      (cond ( (is_a nam class_named)
	      (add2sbuf_cident nambuf (unsafe_get_field :named_name nam)))
	    ( (is_string nam)
	      (add2sbuf_cident nambuf nam))
	    )
      (add2sbuf_strconst nambuf "__L")
      (add2sbuf_longdec nambuf (+i nblong 1))
      (put_int nblongbox (+i nblong 1))
      (let ( (nloc (instance class_objlocv
			     :obv_type ctype_long
			     :obl_off (make_integerbox discr_integer off)
			     :obl_proc orout
			     :obl_cname (strbuf2string discr_string nambuf))) )
	(debug "get_free_objloclong new nloc=" nloc)
	(return nloc)
	))))

;;; function to get a free local otherstuff for some name and ctype
(defun get_free_objloctyped (gcx nam ctyp)
  (debug "get_free_objloctyped nam=" nam " ctyp=" ctyp)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check ctyp" (is_a ctyp class_ctype))
  (cond ( (== ctyp ctype_long)
	  (return (get_free_objloclong gcx nam)))
	( (== ctyp ctype_value)
	  (return (get_free_objlocptr gcx nam)))
	;; return null for the void ctype
	( (== ctyp ctype_void)
	  (return ()))
	(:else 
	 (debug "get_free_objloctyped otherctyp nam=" nam " ctyp=" ctyp)
	 ;(shortbacktrace_dbg "get_free_objloctyped otherctyp" 15)
	 (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		(orout (unsafe_get_field :gncx_objrout gcx))
		(:long off -1)
		)
	   (assert_msg "check freemap" (is_mapobject freemap))
	   (assert_msg "check orout" (is_a orout class_routineobj))
	   (let ( (freeli (mapobject_get freemap ctyp)) )
	     (if (null freeli) 
		 (progn
		   (setq freeli (make_list discr_list))
		   (mapobject_put freemap ctyp freeli)))
	     (let ( (pfree (list_popfirst freeli)) )
	       (if (is_a pfree  class_objlocv)
		   (progn 
		     (debug  "get_free_objloctyped pfree=" pfree)
		     (assert_msg "check pfree was unused" (not (get_int pfree)))
		     (setq off (get_int (unsafe_get_field :obl_off pfree)))
		     )
		 (setq off  (list_length (unsafe_get_field :obrout_others orout))))
	       (let ( 
		     (nambuf (make_strbuf discr_strbuf)) 
		     (others (unsafe_get_field :obrout_others orout))
		     (:long nbothers (list_length others))
		     )
		 (assert_msg "check others" (is_list others))
		 (add2sbuf_strconst nambuf "loc_")
		 (add2sbuf_cident nambuf 
				  (get_field :named_name 
					     (get_field :ctype_keyword ctyp)))
		 (add2sbuf_strconst nambuf "__o")
		 (add2sbuf_longdec nambuf nbothers)
		 (let ( (nloc (instance class_objlocv
					:obv_type ctyp
					:obl_proc orout
					:obl_off (make_integerbox discr_integer off)
					:obl_cname (strbuf2string discr_string nambuf))) )
		   (debug  "get_free_objloctyped new nloc" nloc)
		   (list_append others nloc)
		   (return nloc)
		   )
		 )))))))




;; function to dispose, i.e. mark as free and reusable, an  objlocation
(defun dispose_objloc (oldloc gcx)
  (debug "dispose_objloc freeeing oldloc=" oldloc)
  (shortbacktrace_dbg "dispose_objloc" 7)
  (assert_msg "check oldloc" (is_a oldloc class_objlocv))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  ;; the obl_proc iff it has already been freed
  (assert_msg "check used oldloc" (unsafe_get_field :obl_proc oldloc))
  (let ( (oldcty (unsafe_get_field :obv_type oldloc)) )
    (assert_msg "check oldcty not void" (!= oldcty ctype_void))
    (assert_msg "check oldcty is ctype" (is_a oldcty class_ctype))
    (put_fields oldloc :obl_proc ())			;mark the objlocation as freed
    (debug " freed oldloc=" oldloc)
    (cond ( (== oldcty ctype_value)
	    (let  ( (freepl (unsafe_get_field :gncx_freeptrlist gcx)) )
	      (list_append freepl oldloc)))
	  ( (== oldcty ctype_long)
	    (let  ( (freenl (unsafe_get_field :gncx_freelonglist gcx)) )
	      (list_append freenl oldloc)))
	  (:else
	   (let ( (freemap (unsafe_get_field :gncx_freeothermaps gcx)) 
		  (orout (unsafe_get_field :gncx_objrout gcx))
		  )
	     (assert_msg "check freemap" (is_mapobject freemap))
	     (assert_msg "check orout" (is_a orout class_routineobj))
	     (let ( (freeli (mapobject_get freemap oldcty)) )
	       ;; since we are freeing, freeli should exist
	       (assert_msg "check freeli" (is_list freeli))
	       (list_append freeli oldloc))))))
  )

;; function to dispose, i.e. mark as free, a binding 
(defun dispose_bnd_obj (bnd gcx)
  (assert_msg "check bnd" (is_a bnd class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "dispose_bnd_obj start bnd=" bnd)
  (let ( (locmap (unsafe_get_field :gncx_locmap gcx))
	 (oldloc (mapobject_get locmap bnd)) )
    (if (null oldloc)
	(progn
	  ;; special hack to dispose a void let binding - return immediately in that case
	  (and (is_a bnd class_let_binding)
	       (== (unsafe_get_field :letbind_type bnd) ctype_void)
	       (return))
	  (debug "dispose_bnd_obj nulloldloc bnd=" bnd)
	  ))
    (assert_msg "check oldloc" (is_a oldloc class_objlocv))
    (dispose_objloc oldloc gcx)
    (mapobject_remove locmap bnd)
    (debug "dispose_bnd_obj end bnd=" bnd)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_chunk (nchk gcx)
  (assert_msg "check nchk" (is_a nchk class_nrep_chunk))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj nrepchunk nchk=" nchk)
  (let ( (loc (unsafe_get_field :nrep_loc nchk))
	 (nexp (unsafe_get_field :nchunk_expansion nchk))
	 (noper (unsafe_get_field :nchunk_oper nchk))
	 (ntyp (unsafe_get_field :nexpr_ctyp nchk))
	 )
    (assert_msg "check noper" (is_a noper class_named))
    (assert_msg "check nexp" (is_multiple nexp))
    (assert_msg "check ntyp" (is_a ntyp class_ctype))
    (let (  (otup (multiple_map
		   nexp
		   (lambda (comp :long ix)
		     (debug "compobj nrepchunk comp=" comp)
		     (if (== (discrim comp) discr_verbatim_string)
			 comp
		       (compile_obj comp gcx)))
		   ))
	    (oexp (if loc
		      (instance class_objlocatedexpv
				:obv_type ntyp
				:obx_cont otup
				:obcx_loc loc
				)
		    (instance class_objexpv
			      :obv_type ntyp
			      :obx_cont otup)
		    ))      
	    )
      (assert_msg "check ntyp" (is_a ntyp class_ctype))
      (debug "compilobj nrepchunk oexp=" oexp)
      oexp)
    ))
(install_method class_nrep_chunk compile_obj compilobj_nrep_chunk)


;;;;;;;;;;;;;;;;
(defun getctype_typexpr (recv env)
  (assert_msg "check recv" (is_a recv class_nrep_typed_expression))
   (unsafe_get_field :nexpr_ctyp recv))
(install_method class_nrep_typed_expression get_ctype getctype_typexpr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_nil (nilo gcx)
  (assert_msg "check nilo" (is_a nilo class_nrep_nil))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (obnil (instance class_objnil
			  :obv_type ctype_value)) )
    (return obnil))
  )

(install_method class_nrep_nil compile_obj compilobj_nrep_nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_comment (ncomm gcx)
  (debug "compilobj_nrep_comment start ncomm=" ncomm)
  (assert_msg "check ncomm" (is_a ncomm class_nrep_comment))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (coms (unsafe_get_field :ncomm_string ncomm))
	 (nloc (unsafe_get_field :nrep_loc ncomm))
	 (sbuf (make_strbuf discr_strbuf)) )
    (add2sbuf_strconst sbuf "/**!* ")
    (add2sbuf_ccomstring sbuf coms)
    (add2sbuf_strconst sbuf " *!**/")
    (let ( (ostr (strbuf2string discr_verbatim_string sbuf)) 
	   (res  (instance class_objcompute
			   :obi_loc nloc
			   :obdi_destlist ()
			   :obcpt_type ctype_void
			   :obcpt_expr ostr))
	   )  
      (debug "compilobj_nrep_comment ostr=" ostr " res=" res)
      (return res)
      )))
(install_method class_nrep_comment compile_obj compilobj_nrep_comment)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_locsymocc (lsyo gcx)
  (debug "compilobj locsymocc begin lsyo=" lsyo)
  (assert_msg "check nchk" (is_a lsyo class_nrep_locsymocc))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc lsyo))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (sym (unsafe_get_field :nocc_symb lsyo))
	 (oty (unsafe_get_field :nocc_ctyp lsyo))
	 (sbnd (unsafe_get_field :nocc_bind lsyo))
	 (ovar (mapobject_get locmap sbnd))
	 )
    (if (null sbnd)
	(progn
	  (debug "compilobj_nrep_locsymocc null sbnd lsyo=" lsyo " sym=" sym)
	  (assert_msg "locsymocc without binding" ())
	  ))
    (if (null ovar) 
	(progn
	  (debug "compilobj locsymocc null ovar sbnd=" sbnd " locmap=" locmap " lsyo=" lsyo)
	  (assert_msg "compilobj locsymocc null ovar without ctype_void" (== oty ctype_void))
	  )
      (assert_msg "compilobj locsymocc check ovar"  (is_a ovar class_objlocv)))
    (debug "compilobj locsymocc end lsyo=" lsyo " gives ovar=" ovar)
    (return ovar)
    ))
(install_method class_nrep_locsymocc compile_obj compilobj_nrep_locsymocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_closedocc (nclo gcx)
  (debug "compilobj closedocc nclo=" nclo)
  (assert_msg "check nclo" (is_a nclo class_nrep_closedocc))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb nclo))
	(obind (unsafe_get_field :nocc_bind nclo))
	(cprocs (unsafe_get_field :ncloc_procs nclo))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc nclo))
	)
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cloblis (unsafe_get_field :nrpro_closedb lastcproc)) 
	   (:long clorank -1)
	   )
      (assert_msg "check cloblis" (is_list cloblis))
      (let ( (curpair (list_first cloblis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curbind (pair_head curpair)) )
	   (if (== curbind obind)
	       (progn
		 (setq clorank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good closed rank" (>=i clorank 0))
	(let ( 
	      (nclotyp (unsafe_get_field :nocc_ctyp nclo))
	      (ocloccv 
	       (instance class_objcloccv
			 :obv_type nclotyp
			 :obc_off (make_integerbox discr_integer
						   clorank)
			 :obc_proc lastcproc
			 :obc_name (unsafe_get_field :named_name osym)))
	      )
	  (assert_msg "check nclotyp" (is_a nclotyp class_ctype))
	  (debug "compilobj closedocc result ocloccv=" ocloccv)
	  ocloccv
	  )))))

(install_method class_nrep_closedocc compile_obj compilobj_nrep_closedocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_constocc (ncnst gcx)
  (debug "compilobj_nrep_constocc ncnst=" ncnst)
  (assert_msg "check ncnst" (is_a ncnst class_nrep_constocc))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( 
	(orout (unsafe_get_field :gncx_objrout gcx))
	(osym (unsafe_get_field :nocc_symb ncnst))
	(cprocs (unsafe_get_field :ncloc_procs ncnst))
	(lastcproc (pair_head (list_last cprocs)))
	(nloc (unsafe_get_field :nrep_loc ncnst))
	)
    (assert_msg "check lastcproc" (is_a lastcproc class_nrep_routproc))
    (let ( (cnstlis (unsafe_get_field :nrpro_const lastcproc)) 
	   (:long cnstrank -1)
	   )
      (assert_msg "check cnstlis" (is_list cnstlis))
      (let ( (curpair (list_first cnstlis)) 
	     (:long curank 0)
	     )
	(forever 
	 looplis
	 (if (not (is_pair curpair)) (exit looplis))
	 (let ( (curelem (pair_head curpair)) )
	   (if (== curelem ncnst)
	       (progn
		 (setq cnstrank curank)
		 (exit looplis)))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   ))
	(assert_msg "check good const rank" (>=i cnstrank 0))
	(let ( 
	      (cnstyp (unsafe_get_field :nocc_ctyp ncnst))
	      (oconstv 
	       (instance class_objconstv
			 :obv_type cnstyp
			 :obc_off (make_integerbox discr_integer
						   cnstrank)
			 :obc_proc lastcproc
			 :obc_name (unsafe_get_field :named_name osym))) )
	  (assert_msg "check cnstyp" (is_a cnstyp class_ctype))
	  (debug "compilobj constocc result oconstv=" oconstv)
	  oconstv
	  )))))

(install_method class_nrep_constocc compile_obj compilobj_nrep_constocc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_importedval (nsva gcx)
  (debug "compilobj_nrep_importedval nsva=" nsva)
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (assert_msg "check nsva" (is_a nsva class_nrep_importedval))
  (let ( (var (unsafe_get_field :nimport_symb nsva))
	 (olocv (mapobject_get (unsafe_get_field :igncx_importmap gcx) var))
	 )
    (debug "compilobj_nrep_importedval result olocv=" olocv)
    (assert_msg "check var" (is_a var class_symbol))
    (assert_msg "check olocv" (is_a olocv class_objlocv))
    (return olocv)
    ))
(install_method class_nrep_importedval compile_obj compilobj_nrep_importedval)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_definedconstant (ndconst gcx)
  (debug "compilobj definedconstant ndconst=" ndconst " gcx=" gcx)
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (assert_msg "check ndconst" (is_a ndconst class_nrep_defined_constant))
  (let ( (nsval (unsafe_get_field :nconst_sval ndconst))
	 (nloc (unsafe_get_field :nrep_loc ndconst))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (ndefbnd (unsafe_get_field :nconst_defbind ndconst))
	 (ovloc (mapobject_get locmap ndefbnd))
	 (nproc (unsafe_get_field :nconst_proc ndconst))
	 )
    (debug "compilobj definedconstant ndefbnd=" ndefbnd " nloc=" nloc " ovloc=" ovloc " nproc=" nproc)
    (assert_msg "compilobj definedconstant check ovloc" ovloc)
    (return ovloc)
    ))
(install_method class_nrep_defined_constant compile_obj compilobj_nrep_definedconstant)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a quasiconstant
(defun compilobj_nrep_quasiconstant (nconst gcx)
  (debug "compilobj quasiconstant nconst=" nconst)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nconst" (is_a nconst class_nrep_quasiconstant))
  (let ( (nloc (unsafe_get_field :nrep_loc nconst))
	 (sval (unsafe_get_field :nconst_sval nconst))
	 (data (unsafe_get_field :nconst_data nconst))
	 (proc (unsafe_get_field :nconst_proc nconst))
	 )
    (if (is_a proc class_nrep_routproc)
	(let ( (constlist (unsafe_get_field :nrpro_const proc)) 
	       (curpair (list_first constlist))
	       (:long coff -1)
	       (:long curank 0)
	       (nambuf (make_strbuf discr_strbuf))
	       )
	  (forever 
	   constloop
	   (if (is_pair curpair)
	       (let ((curconst (pair_head curpair)))
		 (if (== curconst data)
		     (progn
		       (setq coff curank)
		       (exit constloop)))
		 )
	     (exit constloop))
	   (setq curpair (pair_tail curpair))
	   (setq curank (+i curank 1))
	   )
	  (assert_msg "check coff" (>=i coff 0))
	  (add2sbuf_strconst nambuf "konst_")
	  (add2sbuf_longdec nambuf coff)
	  (if (is_a sval class_named)
	      (progn
		(add2sbuf_strconst nambuf "_")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name sval))
		)
	    )
	  (let ( (constv 
		  (instance class_objconstv
			    :obv_type ctype_value
			    :obc_off (make_integerbox discr_integer coff)
			    :obc_proc proc
			    :obc_name (strbuf2string discr_string nambuf)
			    )) )
	    (debug "compilobj quasiconstant constv=" constv)
	    (return constv)
	    )
	  )
      (let ( (odata (compile_obj data gcx)) )
	;; not inside a proc, just return the compiled data
	(debug "compilobj quasiconstant odata=" odata)
	(return odata)
	)
      )
    )
  )
(install_method class_nrep_quasiconstant compile_obj compilobj_nrep_quasiconstant)

(defun compilobj_nrep_quasiconst_current_module_environment_container (nqcme gcx)
  (debug "compilobj_nrep_quasiconst_current_module_environment_container start nqcme=" nqcme)
  (assert_msg "check nqme" (is_a nqcme class_nrep_quasiconst_current_module_environment_container))
  (let ( (onres (compilobj_nrep_quasiconstant nqcme gcx))
	 (scomm (unsafe_get_field :nqcmec_comment nqcme))
	 (str (let ( (sbuf (make_strbuf discr_strbuf)) )
		(add2sbuf_strconst sbuf "/*quasi.cur.mod.env.cont ")
		(add2sbuf_ccomstring sbuf scomm)
		(add2sbuf_strconst sbuf "*/\n")
		(strbuf2string discr_verbatim_string sbuf)
		)
	      )
	 (ores (instance class_objlocatedexpv
			 :obv_type ctype_value
			 :obcx_loc (unsafe_get_field :nrep_loc nqcme)
			 :obx_cont (tuple
				    str
				    onres
				    )
			 ))
	 )
    (debug "compilobj_nrep_quasiconstant_current_module_environment_container result ores=" ores)
    (return ores)
    ))
(install_method class_nrep_quasiconst_current_module_environment_container compile_obj
		compilobj_nrep_quasiconst_current_module_environment_container)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a forever
(defun compilobj_nrep_forever (nfor gcx)
  (debug "compilobj_nrep_forever nfor=" nfor)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nfor" (is_a nfor class_nrep_forever))
  (let ( (nloc (unsafe_get_field :nrep_loc nfor))
	 (nbind (unsafe_get_field :nforever_bind nfor))
	 (nbody (unsafe_get_field :nforever_body nfor))
	 (nres (unsafe_get_field :nforever_result nfor)) 
	 (oresv (get_free_objlocptr gcx nres))
	 )
    (assert_msg "check nbind" (is_a nbind class_label_binding))
    (debug "compilobj_nrep_forever oresv=" oresv)
    (assert_msg "check oresv" (is_a oresv class_objlocv))
    (unsafe_put_fields nbind :labind_res oresv)
    (assert_msg "check again nbind" (is_object nbind))
    (debug "compilobj_nrep_forever updated nbind=" nbind)
    (let ( (closy (unsafe_get_field :labind_clonsy nbind)) 
	   (bodyl (make_list discr_list))
	   (epilogl (make_list discr_list))
	   (oloop (instance class_objloop
			    :obi_loc nloc
			    :oblo_bodyl bodyl
			    :oblo_epil epilogl
			    :obloop_label closy
			    :obloop_resv oresv))
	   )
      (assert_msg "check closy" (is_a closy class_cloned_symbol))
      (multiple_every
       nbody
       (lambda (ncomp :long ix)
	 (list_append bodyl (compile_obj ncomp gcx))))
      (debug "compilobj forever result oloop=" oloop)
      oloop
      )
    )  
  )
(install_method class_nrep_forever compile_obj compilobj_nrep_forever)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an exit
(defun compilobj_nrep_exit (nexi gcx)
  (debug "compilobj_nrep_exit nexi=" nexi)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nexi" (is_a nexi class_nrep_exit))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nexi))
	(nbindx (unsafe_get_field :nexit_bind nexi))
	(nval (unsafe_get_field :nexit_val nexi)) 
	)
    (assert_msg "check nbindx" (is_a nbindx class_label_binding))
    (let ( 
	  (inslist (make_list discr_list)) 
	  (epilist (make_list discr_list)) 
	  (destlist (make_list discr_list))
	  (oval (compile_obj nval gcx))
	  (bxres (unsafe_get_field :labind_res nbindx))
	  (obloc (instance class_objplainblock
			   :obi_loc nloc
			   :oblo_bodyl inslist
			   :oblo_epil epilist
			   ))
	  (obex (instance class_objexit
			  :obi_loc nloc
			  :obexit_label (unsafe_get_field :labind_clonsy nbindx)
			  )) 
	  (obcom (instance class_objcompute
			   :obi_loc nloc
			   :obdi_destlist destlist
			   :obcpt_type ctype_value
			   :obcpt_expr oval))
	  )
      (list_append inslist obcom)
      (list_append epilist obex)
      (list_append destlist bxres)
      (debug "compilobj_nrep_exit return obloc=" obloc)
      (return obloc)
      )))
(install_method class_nrep_exit compile_obj compilobj_nrep_exit)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile an again
(defun compilobj_nrep_again (nag gcx)
  (debug "compilobj_nrep_again nag=" nag)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nag" (is_a nag class_nrep_again))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nag))
	(nlabind (unsafe_get_field :nagain_bind nag))
	(oagain (instance class_objagain
			  :obi_loc nloc 
			  :obagain_label (get_field :labind_clonsy nlabind)
			  ))
	)
    (assert_msg "check nlabind" (is_a nlabind class_label_binding))
    (debug "compilobj_nrep_again return oagain=" oagain)
    (return oagain)
))
(install_method class_nrep_again compile_obj compilobj_nrep_again)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_discrany (anyv gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  anyv
  )
(install_method discr_any_receiver compile_obj compilobj_discrany)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_let (rlet gcx)
  (assert_msg "check rlet" (is_a rlet class_nrep_let))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc rlet))
	 (bnds (unsafe_get_field :nlet_bindings rlet))
	 (bdy (unsafe_get_field :nlet_body rlet))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 )
    (debug "compilobj_nrep_let initial rlet=" rlet " loc=" loc)
    ;; for each normalexp in the bnds tuple
    ;; add the binding and the setting in the body and the clear in the epilogue
    (assert_msg "compilobj_nrep_let check bnds multiple" (is_multiple_or_null bnds))
    ;; iterate on normal bindings
    (multiple_every
     bnds
     (lambda (nlbnd :long ix)
       (debug "compilobj_nrep_let current normbinding loc=" loc " nlbnd=" nlbnd " locmap=" locmap)
       (assert_msg "check nlbnd in compilobj_nrep_let" (is_a nlbnd class_normal_let_binding))
       (let ( (bder (unsafe_get_field :binder nlbnd))
	      (cty (unsafe_get_field :letbind_type nlbnd))
	      (nexp (unsafe_get_field :letbind_expr nlbnd))
	      (obva (get_free_objloctyped gcx bder cty))
	      )
	 (debug "compilobj_nrep_let current normbinding obva=" obva " nexp=" nexp)
	 (let ( (obnx (compile_obj nexp gcx)) )
	   (debug "compilobj_nrep_let current normbinding obnx=" obnx)
	   (if (is_a nexp class_sexpr) 
	       (if (not (is_object obnx))
		   (progn 
		     (debug "compilobj_nrep_let current normbinding faulty nexp=" nexp " obnx=" obnx)
		     (assert_msg "compilobj_nrep_let check obnx" (is_object obnx)))))
	   (if obva
	       ;; non void cty
	       (progn
		 (mapobject_put locmap nlbnd obva)
		 (let ( (obpd (put_objdest obnx obva)) 
			(obmy (or obpd obnx))
			)
		   (debug "compilobj_nrep_let current obpd=" obpd " obmy=" obmy)
		   (list_append obodl obmy)
		   ))
	     (progn
	       ;; obva is nil when cty is void type 
	       (debug "compilobj_nrep_let append obnx=" obnx)
	       (list_append obodl obnx)
	       ))
	   ;; add clearing of obva to epilogue part of oblock
	   (if obva 
	       (let ( (obcl (instance class_objclear
				      :obi_loc loc
				      :oclr_vloc obva)) 
		      )
		 (list_append oepil obcl)
		 ))))))
    (debug "compilobj_nrep_let after iterate normbind loc=" loc " locmap=" locmap)
    ;; compile each body component
    (multiple_every
     bdy
     (lambda (bdycomp :long ix)
       (debug"compilobj_nrep_let body loc=" loc " bdycomp=" bdycomp " ix=" ix)
       (let ( (objcomp  (compile_obj bdycomp gcx)) 
	      )
	 (debug "compilobj_nrep_let body objcomp=" objcomp)
	 ;; objcomp is null when compiling a locvar of ctype_void;
	 ;; this happens with primitive of :void type
	 (if (null objcomp) (return objcomp)) ;return from the inner lambda
	 (list_append obodl objcomp))))
    (debug "compilobj_nrep_let after iterate body loc=" loc)
    ;; dispose each binding
    (multiple_every
     bnds
     (lambda (obnd :long ix)
       (debug "compilobj_nrep_let dispose loc=" loc " obnd=" obnd " ix=" ix)
       (dispose_bnd_obj obnd gcx)))
    (debug "compilobj_nrep_let final loc=" loc " locmap=" locmap " oblock=" oblock)
    (return oblock)			;return it
    ))

(install_method class_nrep_let compile_obj compilobj_nrep_let)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to compile the fill inside a letrec
;;; receiver: the normalized constructrive binding
;;; arguments: 
;;;; * GCX the code generation context
;;; result = the obj instruction or value

(defselector compile_letrec_fill class_selector
  :doc #{The selector $COMPILE_LETREC_FILL is used to compile the fill
  for a $LETREC. The $RECV is usually a constructive binding. $OBVA is
  the object variable, and $OBODL is the list for the body, $GCX being
  the generation context. $SLOC is the source location.}#
  :formals (recv obva obodl gcx sloc)
  )
(export_values compile_letrec_fill)

(defun fail_compiletrecfill (recv obva obodl gcx sloc)
  (debug "fail_compiletrecfill recv=" recv " obva=" obva)
  (let ( (d (discrim recv)) )
    (error_strv sloc "unimplemented discriminant for compile_letrec_fill"
		(get_field :named_name d))
    (assert_msg "fail_compiletrecfill unexpected" ())
))
(install_method discr_any_receiver compile_letrec_fill fail_compiletrecfill)

;;;;;;;;;;;;;;;;
;; generate inside the body list the code for filling lambda in letrecs
(defun compiletrec_lambda (recv obva obodl gcx sloc)
  (debug "compiletrec_lambda recv=" recv " obva=" obva)
  (assert_msg "check recv" (is_a recv class_normal_constructed_lambda_binding))
  (assert_msg "check obva" (is_a obva class_objlocv))
  (assert_msg "check obodl" (is_list obodl))
  (let ( (loc (or (get_field :nconsb_loc recv) sloc))
	 (nclosed (get_field :nlambdab_nclosed recv))
	 (nconstrout (get_field :nlambdab_constrout recv))
	 (otouch (instance class_objtouch
			   :obi_loc loc
			   :otouch_val obva
			   ))
	 (ocrout (compile_obj nconstrout gcx))
	 (oputrout (instance class_objputclosurout
			     :obi_loc loc
			     :opclor_clos obva
			     :opclor_rout ocrout
			     ))
	 )
    (debug "compiletrec_lambda oputrout=" oputrout)
    (list_append obodl oputrout)
    ;;
    (debug "compiletrec_lambda nclosed=" nclosed)
    (foreach_in_multiple 
     (nclosed) 
     (curclosed :long curix)
     (debug "compiletrec_lambda curclosed=" curclosed " curix=" curix)
     (let ( (oclosed (compile_obj curclosed gcx)) 
	    )
       (debug "compiletrec_lambda oclosed=" oclosed)
       (cond ( (or (is_not_a oclosed class_objpurevalue)
		   (is_a oclosed class_objinstr))
	       (if (>i curix 0)
		   (list_append obodl otouch))
	       (list_append obodl oclosed) 
	       )
	     (:else
	      (debug "compiletrec_lambda ignored generated code oclosed=" oclosed))
	     )
       (let ( 	    
	     (oputclo (instance class_objputclosedv
				:obi_loc loc
				:opclov_clos obva
				:opclov_off (make_integerbox discr_integer curix)
				:opclov_cval oclosed
				)) 
	     )
	 (debug "compiletrec_lambda oputclo=" oputclo)
	 (list_append obodl oputclo)
	 ))
     )
    (list_append obodl otouch)
    (debug "compiletrec_lambda final obodl=" obodl)
    ))
(install_method class_normal_constructed_lambda_binding compile_letrec_fill compiletrec_lambda)



;; generate inside the body list the code for filling tuple in letrecs
(defun compiletrec_tuple (recv obva obodl gcx sloc)
  (debug "compiletrec_tuple recv=" recv " obva=" obva)
  (assert_msg "check recv" (is_a recv class_normal_constructed_tuple_binding))
  (assert_msg "check obva" (is_a obva class_objlocv))
  (assert_msg "check obodl" (is_list obodl))
  (let ( (loc (or (get_field :nconsb_loc recv) sloc))
	 (ncomptup (get_field :ntupb_comp recv))
	 (otouch (instance class_objtouch
			   :obi_loc loc
			   :otouch_val obva
			   ))
	 )
    (debug "compiletrec_tuple ncomptup=" ncomptup)
    (foreach_in_multiple
     (ncomptup)
     (ncurcomp :long ix)
     (debug "compiletrec_tuple ncurcomp=" ncurcomp " ix=" ix)
     (let ( (ocomp (compile_obj ncurcomp gcx)) 
	    (oputn (instance class_objputuple
			     :obi_loc loc
			     :oputu_tupled obva
			     :oputu_offset (make_integerbox discr_integer ix)
			     :oputu_value ocomp
			     ))
	    )
       (debug "compiletrec_tuple ocomp=" ocomp)
       (cond ( (or (is_not_a ocomp class_objpurevalue)
		   (is_a ocomp class_objinstr))
	       (list_append obodl otouch)
	       (list_append obodl ocomp)
	       )
	     (:else 
	      (debug "compiletrec_tuple ignored generated code ocomp=" ocomp))
	     )
       (list_append obodl oputn)
       ))
    (list_append obodl otouch)
    (debug "compiletrec_tuple final obodl=" obodl)
    ))
(install_method class_normal_constructed_tuple_binding compile_letrec_fill compiletrec_tuple)


;; generate inside the body list the code for filling pair in letrecs
(defun compiletrec_pair (recv obva obodl gcx sloc)
  (debug "compiletrec_pair recv=" recv " obva=" obva)
  (assert_msg "check recv" (is_a recv class_normal_constructed_pair_binding))
  (assert_msg "check obva" (is_a obva class_objlocv))
  (assert_msg "check obodl" (is_list obodl))
  (let ( (loc (or (get_field :nconsb_loc recv) sloc))
	 (nhead (get_field :npairb_head recv))
	 (ntail (get_field :npairb_tail recv))
	 (ohead (compile_obj nhead gcx))
	 (otail (if ntail (compile_obj ntail gcx)))
	 (oputhead (instance class_objputpairhead
			     :obi_loc loc
			     :oputp_pair obva
			     :oputp_head ohead))
	 (oputtail (if otail (instance class_objputpairtail
				       :obi_loc loc
				       :oputp_pair obva
				       :oputp_tail otail)))
	 (otouch (instance class_objtouch
			   :obi_loc loc
			   :otouch_val obva
			   ))
	 )
    (debug "compiletrec_pair nhead=" nhead " ohead=" ohead
	   " ntail=" ntail " otail=" otail)
    (if (or (is_not_a ohead class_objpurevalue) 
	    (is_a ohead class_objinstr))
	(list_append obodl ohead)
      (debug "compiletrec_pair ohead ignored generated code ohead=" ohead))
    (if (and otail (or (is_not_a otail class_objpurevalue) 
		       (is_a otail class_objinstr)))
	(list_append obodl otail)
      (debug "compiletrec_pair otail ignored generated code otail=" otail))
    (list_append obodl oputhead)
    (if oputtail (list_append obodl oputtail))
    (list_append obodl otouch)
    ))
(install_method class_normal_constructed_pair_binding compile_letrec_fill compiletrec_pair)

;; generate inside the body list the code for filling pair in letrecs
(defun compiletrec_list (recv obva obodl gcx sloc)
  (debug "compiletrec_list recv=" recv " obva=" obva)
  (assert_msg "check recv" (is_a recv class_normal_constructed_list_binding))
  (assert_msg "check obva" (is_a obva class_objlocv))
  (assert_msg "check obodl" (is_list obodl))
  (let ( (loc (or (get_field :nconsb_loc recv) sloc))
	 (nfirst (get_field :nlistb_first recv))
	 (nlast (get_field :nlistb_last recv))
	 (ofirst (if nfirst (compile_obj nfirst gcx)))
	 (olast (if nlast (compile_obj nlast gcx)))
	 (oputl (if (or ofirst olast)
		    (instance class_objputlist
			      :obi_loc loc
			      :oputl_list obva
			      :oputl_first ofirst
			      :oputl_last olast
			      )))
	 (otouch (instance class_objtouch
			   :obi_loc loc
			   :otouch_val obva
			   ))
	 )
    (if (and ofirst (or (is_not_a ofirst class_objpurevalue) (is_a ofirst class_objinstr)))
	(list_append obodl ofirst)
      (debug "compiletrec_list ignored generated code ofirst=" ofirst)
      )
    (if (and olast (or  (is_not_a olast class_objpurevalue)
			(is_a olast class_objinstr)))
	(list_append obodl olast)
      (debug "compiletrec_list olast ignored generated code olast=" olast)
      )
    (if oputl 
	(progn 
	  (list_append obodl oputl)
	  (list_append obodl otouch)
	  ))
    ))
(install_method class_normal_constructed_list_binding compile_letrec_fill compiletrec_list)


;; generate inside the body list the code for filling instance in letrecs
(defun compiletrec_instance (recv obva obodl gcx sloc)
  (debug recv "compiletrec_instance recv=" recv " obva=" obva " obodl=" obodl)
  (assert_msg "check recv" (is_a recv class_normal_constructed_instance_binding))
  (assert_msg "check obva" (is_a obva class_objlocv))
  (assert_msg "check obodl" (is_list obodl))
  (let ( (loc (or (get_field :nconsb_loc recv) sloc))
	 (nslots (get_field :ninstb_slots recv))
	 (nclabind (get_field :ninstb_clabind recv))
	 (otouch (instance class_objtouch
			   :obi_loc loc
			   :otouch_val obva
			   ))
	 (clas (cond ( (is_a nclabind class_value_binding)
		       (unsafe_get_field :vbind_value nclabind))
		     ( (is_a nclabind class_class_binding)
		       (unsafe_get_field :cbind_class nclabind))
		     (:else
		      (debug "compiletrec_instance bad nclabind=" nclabind)
		      (assert_msg "unexpected class binding" ()))))
	 (flds (get_field :class_fields clas))
	 )
    (debug "compiletrec_instance clas=" clas " nslots=" nslots)
    (assert_msg "check clas" (is_a clas class_class))
    (foreach_in_multiple
     (nslots)
     (curnslot :long slix)
     (debug "compiletrec_instance curnslot=" curnslot " slix=" slix)
     (if curnslot
	 (let ( (curfld (multiple_nth flds slix)) 
		(oslot (compile_obj curnslot gcx))
		)
	   (debug "compiletrec_instance curfld=" curfld " oslot=" oslot)
	   (if (or (is_not_a oslot class_objpurevalue)
		   (is_a oslot class_objinstr))
	       (progn
		 (if (>i slix 0) (list_append obodl otouch))
		 (list_append obodl oslot))
	     (debug "compiletrec_instance ignored generated code oslot=" oslot))
	   (let ( (oputs (instance class_objputslot
				   :obi_loc loc
				   :oslot_odata obva
				   :oslot_offset (make_integerbox discr_integer slix)
				   :oslot_field curfld
				   :oslot_value oslot))
		  )
	     (debug "compiletrec_instance oputs=" oputs)
	     (list_append obodl oputs)
	     )))) 
    (list_append obodl otouch)
    (debug "compiletrec_instance final obodl=" obodl)
    ))
(install_method class_normal_constructed_instance_binding compile_letrec_fill compiletrec_instance)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile of LETREC
(defun compilobj_nrep_letrec (rlet gcx)
  (debug "compilobj_nrep_letrec initial rlet=" rlet)
  (assert_msg "check rlet" (is_a rlet class_nrep_letrec))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc rlet))
	 (bnds (unsafe_get_field :nlet_bindings rlet))
	 (fillbnds (unsafe_get_field :nletrec_fill_bindings rlet))
	 (bodybnds (unsafe_get_field :nletrec_body_bindings rlet))
	 (:long nbbnds (multiple_length bnds))
	 (nlocsyms (unsafe_get_field :nletrec_locsyms rlet))
	 (:long nblocsym (multiple_length nlocsyms))
	 (tuploc (make_multiple discr_multiple nblocsym))
	 (nbdy (unsafe_get_field :nlet_body rlet))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (ofreelocs (make_list discr_list))
	 (obrout (get_field :gncx_objrout gcx))
	 (obcntletrec (get_field :obrout_cntletrec obrout))
	 (:long cntletrec (+i 1 (get_int obcntletrec)))
	 (oallstruct (make_multiple discr_multiple nbbnds))
	 (namstr 
	  (let ( (nambuf (make_strbuf discr_strbuf)) )
	    (add2sbuf_strconst nambuf "meltletrec_")
	    (add2sbuf_longdec nambuf cntletrec)
	    (strbuf2string discr_verbatim_string nambuf)
	    ))
	 (oblock (instance class_objmultiallocblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil
			   :omalblo_allstruct oallstruct
			   :omalblo_name namstr
			   ))
	 )
    (debug "compilobj_nrep_letrec initial loc=" loc " nlocsyms=" nlocsyms 
	   " fillbnds=" fillbnds " bodybnds=" bodybnds)
    (assert_msg "check fillbnds is list" (is_list_or_null fillbnds))
    (assert_msg "check bodybnds is list" (is_list_or_null bodybnds))
    (put_int obcntletrec cntletrec)
    (debug "compilobj_nrep_letrec updated obcntletrec=" obcntletrec)
    (foreach_in_multiple
     (nlocsyms)
     (curlocsym :long symix)
     (debug "compilobj_nrep_letrec curlocsym=" curlocsym " symix=" symix)
     (assert_msg "check curlocsym" (is_a curlocsym class_nrep_locsymocc))
     (let ( (curobva (get_free_objloctyped gcx (get_field :nocc_symb curlocsym) ctype_value))
	    (ocurclear (instance class_objclear
				 :obi_loc loc
				 :oclr_vloc curobva))
	    (cursbnd (multiple_nth bnds symix))
	    )
       (debug "compilobj_nrep_letrec again curlocsym=" curlocsym 
	      " curobva=" curobva " cursbnd=" cursbnd " ocurclear=" ocurclear " symix=" symix)
       (multiple_put_nth tuploc symix curobva)
       (mapobject_put locmap cursbnd curobva)
       (list_append oepil ocurclear)
       (list_append ofreelocs curobva)
       )
     )
    ;;
    (debug "compilobj_nrep_letrec locmap=" locmap " oblock=" oblock " ofreelocs=" ofreelocs " bnds=" bnds)
    (foreach_in_multiple
     (bnds)
     (curbnd :long bndix)
     (debug "compilobj_nrep_letrec curbnd=" curbnd " bndix=" bndix)
     (let ( (obnd (compile_obj curbnd gcx)) 
	    )
       (debug "compilobj_nrep_letrec obnd=" obnd)
       (multiple_put_nth oallstruct bndix obnd)
       (list_append obodl obnd)
       (debug "compilobj_nrep_letrec updated obodl=" obodl)
       )
     )
    ;; 
    ;; maybe we should reserve the recobva before compiling nrecexp
    (debug "compilobj_nrep_letrec fillbnds" fillbnds)
    (assert_msg "check fillbnds" (is_list_or_null fillbnds))
    ;; first loop to reserve the recobva
    (foreach_in_list
     (fillbnds)
     (curecpair curecbnd)
     (debug "compilobj_nrep_letrec  get_free_objloc curecbnd=" curecbnd)
     (assert_msg "check curecbnd" (is_a curecbnd class_normal_let_binding))
     (let ( (rbder (unsafe_get_field :binder curecbnd))
	    (rcty (unsafe_get_field :letbind_type curecbnd))
	    (rloc (unsafe_get_field :letbind_loc curecbnd))
	    (recobva (get_free_objloctyped gcx rbder rcty))
	    )
       (debug "compilobj_nrep_letrec current normbinding recobva=" recobva)
       ;; recobva can be nil when rcty is :void
       (if recobva
	   (let (
		 (oreclear (instance class_objclear
				     :obi_loc (or rloc loc)
				     :oclr_vloc recobva
				     ))
		 )
	     (assert_msg "check recobva" (is_a recobva class_objlocv))
	     (mapobject_put locmap curecbnd recobva)
	     (debug "compilobj_nrep_letrec oreclear=" oreclear)
	     (list_append oepil oreclear)
	     (list_append ofreelocs recobva)
	     ))))
    (debug "compilobj_nrep_letrec again locmap=" locmap " ofreelocs=" ofreelocs " fillbnds=" fillbnds)
    ;;
    ;; loop to compile the fillbindings
    (foreach_in_list
     (fillbnds)
     (curecpair curfilbnd)
     (debug "compilobj_nrep_letrec compil curfilbnd=" curfilbnd)
     (assert_msg "check curfilbnd" (is_a curfilbnd class_normal_let_binding))
     (let ( (rbder (unsafe_get_field :binder curfilbnd))
	    (rcty (unsafe_get_field :letbind_type curfilbnd))
	    (nrecexp (unsafe_get_field :letbind_expr curfilbnd))
	    (recobva (mapobject_get locmap curfilbnd))
	    )
       (debug "compilobj_nrep_letrec current recbinding nrecexp=" nrecexp)
       (let ( (robnx (compile_obj nrecexp gcx)) 
	      (rnewob ())
	      )
	 (debug "compilobj_nrep_letrec robnx=" robnx)
	 (if recobva
	     (setq rnewob (put_objdest robnx recobva))
	   (setq rnewob robnx))
	 (debug "compilobj_nrep_letrec rnewob=" rnewob)
	 (if (or (is_not_a rnewob class_objpurevalue)
		 (is_a rnewob class_objinstr))
	     (list_append obodl rnewob)
	   (debug "compilobj_nrep_letrec ignored generated code rnewob=" rnewob)
	   )
	 ))
     )
;;;
     (debug "compilobj_nrep_letrec after fillbinding obodl=" obodl)
;;;
;;; generate the fill of the letrec-ed constructions
    (foreach_in_multiple
     (bnds)
     (curbnd :long bndix)
     (let ( (obva (multiple_nth tuploc bndix))
	    )
       (debug "compilobj_nrep_letrec again obva=" obva " curbnd=" curbnd " bndix=" bndix)
       (compile_letrec_fill curbnd obva obodl gcx loc)
       (debug "compilobj_nrep_letrec letrecfilled obodl=" obodl)
       ))
    ;;
    (debug "compilobj_nrep_letrec oallstruct=" oallstruct " obodl=" obodl)
    ;; loop to compile the bodybindings
    (foreach_in_list
     (bodybnds)
     (cubdypair curbdybnd)
     (debug "compilobj_nrep_letrec compil curbdybnd=" curbdybnd)
     (assert_msg "check curbdybnd" (is_a curbdybnd class_normal_let_binding))
     (let ( (rbder (unsafe_get_field :binder curbdybnd))
	    (rcty (unsafe_get_field :letbind_type curbdybnd))
	    (nbdyexp (unsafe_get_field :letbind_expr curbdybnd))
	    (bdyobva (get_free_objloctyped gcx rbder rcty))
	    (rloc (unsafe_get_field :letbind_loc curbdybnd))
	    )
       (debug "compilobj_nrep_letrec body bdyobva="bdyobva " nbdyexp=" nbdyexp)
       (mapobject_put locmap curbdybnd bdyobva)
       (let ( (robnx (compile_obj nbdyexp gcx)) 
	      (rnewob ())
	      )
	 (if (and bdyobva rcty (!= rcty ctype_void))
	     (progn
	       (list_append ofreelocs bdyobva)
	       (setq rnewob (put_objdest robnx bdyobva))
	       )
	   (setq rnewob robnx))
	 (debug "compilobj_nrep_letrec rnewob=" rnewob)
	 (if (or (is_not_a rnewob class_objpurevalue)
		 (is_a rnewob class_objinstr))
	     (list_append obodl rnewob)
	   (debug "compilobj_nrep_letrec ignored generated code rnewob=" rnewob)
	   )
	 ))
     )
    ;;
    ;; compile the body
    (debug  "compilobj_nrep_letrec nbdy= "nbdy)
    (assert_msg "check nbdy" (is_multiple_or_null nbdy))
    (foreach_in_multiple
     (nbdy)
     (curbdy :long bdix)
     (debug "compilobj_nrep_letrec curbdy=" curbdy " bdix=" bdix)
     (let ( (ocurb (compile_obj curbdy gcx)) )
       (debug "compilobj_nrep_letrec ocurb=" ocurb)
       (list_append obodl ocurb)))
    (debug "compilobj_nrep_letrec final obodl=" obodl " ofreelocs=" ofreelocs)
    ;; should clear and free our objlocs...
    (foreach_in_list
     (ofreelocs)
     (curlpair curlocva)
     (debug "compilobj_nrep_letrec disposing curlocva=" curlocva)
     (assert_msg "check curlocva" (is_a curlocva class_objlocv))
     (let ( (oclear (instance class_objclear
			      :obi_loc loc
			      :oclr_vloc curlocva))
	    )
       (list_append oepil oclear)
       (dispose_objloc curlocva gcx)
       (debug "compilobj_nrep_letrec final oclear=" oclear)
       ))
    ;;
    (debug "compilobj_nrep_letrec final oblock=" oblock " oallstruct= "oallstruct
	   " gcx=" gcx)
    oblock
    ))
(install_method class_nrep_letrec compile_obj compilobj_nrep_letrec)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun compilobj_nrep_citeration (nciter gcx)
  (assert_msg "check nciter" (is_a nciter class_nrep_citeration))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_citeration nciter=" nciter)
  (let ( (loc (unsafe_get_field :nrep_loc nciter))
	 (obrout (unsafe_get_field :gncx_objrout gcx))
	 (citer (unsafe_get_field :nciter_citerator nciter))
	 (nlocbind (unsafe_get_field :nciter_locbindings nciter))
	 (nchkbef (unsafe_get_field :nciter_chunkbefore nciter))
	 (nstatocc (let ( (ns (unsafe_get_field :nciter_statocc nciter)) ) 
		     (assert_msg "check nstatocc" (is_a ns class_nrep_locsymocc))
		     (debug "compilobj_nrep_citeration nstatocc=" ns)
		     ns))
	 (nbody (unsafe_get_field :nciter_body nciter))
	 (nbodbind (unsafe_get_field :nciter_bodbindings nciter))
	 (nchkaft (unsafe_get_field :nciter_chunkafter nciter))
	 (nstatbind (let ( (bi (unsafe_get_field :nocc_bind nstatocc)) )
		      (assert_msg "check nstatbind" (is_a bi class_normal_let_binding))
		      bi))
	 (nstatsy (unsafe_get_field :binder nstatbind))
	 (ostat (get_free_objloctyped gcx nstatsy (unsafe_get_field :nocc_ctyp nstatocc)))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (ocblock (instance class_objciterblock
			    :obi_loc loc
			    :oblo_bodyl obodl
			    :oblo_epil oepil
			    :obciter_citer citer
			    :obciter_before ()
			    :obciter_after ()
			    ))
	 (locmap  (unsafe_get_field  :gncx_locmap gcx))
	 )
    (debug "compilobj_nrep_citeration ostat=" ostat " nlocbind=" nlocbind)
    (assert_msg "check citer" (is_a citer class_citerator))
    (assert_msg "check locmap" (is_mapobject locmap))
    (assert_msg "check nlocbind" (is_multiple_or_null nlocbind))
    (multiple_every
     nlocbind
     (lambda (nlbnd :long ix)
       (debug "compilobj_nrep_citeration current nlocbinding nlbnd=" nlbnd " ix=" ix)
       (assert_msg "check nlbnd in compilobj_nrep_citeration" (is_a nlbnd class_normal_let_binding))
       (let ( (bder (unsafe_get_field :binder nlbnd))
	      (cty (unsafe_get_field :letbind_type nlbnd))
	      (nexp (unsafe_get_field :letbind_expr nlbnd))
	      (oblva (get_free_objloctyped gcx bder cty))
	      )
	 (debug "compilobj_nrep_citeration current local bder=" bder " oblva=" oblva)
	 (if (!= cty ctype_void)
	     (let ( (oclr (instance class_objclear
				    :obi_loc loc
				    :oclr_vloc oblva) ) )
	       (list_append oepil oclr)
	       (mapobject_put locmap nlbnd oblva)
	       (debug "compilobj_nrep_citeration added clear for nlbnd=" nlbnd)
	       ))
	 )))
    (debug "compilobj_nrep_citeration start ocblock=" ocblock)
    (let ( (boxcntciter (unsafe_get_field :obrout_cntciter obrout))
	   (:long cnt (+i 1 (get_int boxcntciter)))
	   (statstr 
	    (let ( (sbu (make_strbuf discr_strbuf)) )
	      (put_int boxcntciter cnt)
	      (add2sbuf_strconst sbu "meltcit")
	      (add2sbuf_longdec sbu cnt)
	      (add2sbuf_strconst sbu "__")
	      (add2sbuf_cident sbu (unsafe_get_field :named_name nstatsy))
	      (strbuf2string discr_verbatim_string sbu)
	      ))
	   )
      (unsafe_put_fields 
       ocblock
       :obciter_before (multiple_map 
			nchkbef 
			(lambda (cbef :long ix)
			  (cond 
			   ((is_string cbef) cbef)
			   ((== cbef nstatocc) statstr)
			   (:else
			    (let ( (obef (compile_obj cbef gcx)) )
			      obef
			      )))))
       :obciter_after (multiple_map
		       nchkaft 
		       (lambda (caft :long ix)
			 (cond 
			  ((is_string caft) caft)
			  ((== caft nstatocc) statstr)
			  (:else
			   (let ( (oaft (compile_obj caft gcx)) )
			     oaft
			     )))))
       )
      )
    (debug "compilobj_nrep_citeration filled before&after chunks ocblock=" ocblock)
    (assert_msg "check nbodbind" (is_list_or_null nbodbind))
    (list_every
     nbodbind
     (lambda (nbbnd :long ix)
       (assert_msg "check nbbnd in compilobj_nrep_citeration" (is_a nbbnd class_normal_let_binding))
       (let ( (bder (unsafe_get_field :binder nbbnd))
	      (cty (unsafe_get_field :letbind_type nbbnd))
	      (nexp (unsafe_get_field :letbind_expr nbbnd))
	      (obbva (get_free_objloctyped gcx bder cty))
	      )
	 (if (!= cty ctype_void)
	     (let ( (oclr (instance class_objclear
				    :obi_loc loc
				    :oclr_vloc obbva)) 
		    )
	       (list_append oepil oclr)
	       (mapobject_put locmap nbbnd obbva)
	       )
	   )
	 (let ( (ocur (compile_obj nexp gcx)) )
	   (if (!= cty ctype_void)
	       (progn
		 (let ( (newocur (put_objdest ocur obbva)) )
		   (if newocur 
		       (list_append obodl newocur)
		     (list_append obodl ocur))
		   ))
	     (progn
	       (list_append obodl ocur)
	       )))
	 )))
    (debug "compilobj_nrep_citeration nbody=" nbody)
    (multiple_every
     nbody
     (lambda (ncurbod :long ix)
       (let ( (ocbod (compile_obj ncurbod gcx)) )
	 (list_append obodl ocbod)
	 )))
    (debug "compilobj_nrep_citeration final ocblock=" ocblock)
    (return ocblock) 
    )
  )

(install_method class_nrep_citeration compile_obj compilobj_nrep_citeration)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a setq
(defun compilobj_nrep_setq (nsq gcx)
  (assert_msg "check nsq" (is_a nsq class_nrep_setq))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_setq nsq=" nsq)
  (let ( (loc (unsafe_get_field :nrep_loc nsq))
	 (var (unsafe_get_field :nstq_var nsq))
	 (exp (unsafe_get_field :nstq_exp nsq))
	 )
    (debug "compilobj_nrep_setq loc=" loc " var=" var " exp=" exp)
    (let (
	 (cexp (compile_obj exp gcx))
	 (cvar (compile_obj var gcx))
	 (cres (put_objdest cexp cvar))
	 )
    (debug "compilobj_nrep_setq loc=" loc " left var=" var " cvar=" cvar
	   "\n right exp=" exp " cexp=" cexp " cres=" cres)
    (and (is_a cres class_objinstr)
	 (null (unsafe_get_field :obi_loc cres))
	 (unsafe_put_fields cres :obi_loc loc))
    (debug "compilobj_nrep_setq cres=" cres)
    cres
    )))
(install_method class_nrep_setq compile_obj compilobj_nrep_setq)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a progn
(defun compilobj_nrep_progn (npro gcx)
  (debug "compilobj_nrep_progn npro=" npro)
  (assert_msg "check npro" (is_a npro class_nrep_progn))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc npro))
	 (nseq (unsafe_get_field :nprogn_seq npro))
	 (nlast (unsafe_get_field :nprogn_last npro))
	 (bodyl (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc loc
			   :oblo_bodyl bodyl
			   ;; :oblo_epil is left null
			   ))
	 )
    (multiple_every
     nseq
     (lambda (ncomp :long ix)
       (let ( (ocomp (compile_obj ncomp gcx)) )
	 (list_append bodyl ocomp)
	 )))
    (let ( (olast (compile_obj nlast gcx)) )
      (list_append bodyl olast))
    (debug "compilobj_nrep_progn oblock=" oblock)
    (return oblock)
    ))
(install_method class_nrep_progn compile_obj compilobj_nrep_progn)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multacc [data multiple accessor]
(defun compilobj_nrep_multacc (nma gcx)
  (assert_msg "check nma" (is_a nma class_nrep_multacc))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_multacc nma=" nma)
  (let ( (loc (unsafe_get_field :nrep_loc nma))
	 (mul (unsafe_get_field :naccm_mul nma))
	 (ix (unsafe_get_field :naccm_ix nma))
	 (cmul (compile_obj mul gcx))
	 ;; we factor the case when the tuple access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let (
		  (tcont 
		   (tuple
		    (make_stringconst discr_verbatim_string "/*multacc*/(melt_multiple_nth((")
		    cmul
		    (make_stringconst discr_verbatim_string "), (")
		    ix
		    (make_stringconst discr_verbatim_string ")))")
		    ))
		  (res 
		   (instance class_objexpv
			     :obv_type ctype_value
			     :obx_cont tcont))
		  )
	      (debug "compilobj_nrep_multacc makecompute res=" res)
	      res
	      ))
	  )
	 )
    (debug "compilobj_nrep_multacc cmul=" cmul " nma=" nma)
    (if (and
	 (is_a cmul class_objinitmultiple)
	 (is_integerbox ix))
	(let ( (comptup (unsafe_get_field :oim_tupval cmul)) )
	  (if (is_multiple comptup)
	      (let (
		    (curval (multiple_nth comptup (get_int ix))) 
		    )
		(debug "compilobj_nrep_multacc returning curval=" curval)
		(return curval)
		)
	    (makecompute)
	    ))
      (makecompute)
      )))
(install_method class_nrep_multacc compile_obj compilobj_nrep_multacc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a fieldacc [data field accessor]
(defun compilobj_nrep_fieldacc (nfa gcx)
  (assert_msg "check nfa" (is_a nfa class_nrep_fieldacc))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_fieldacc nfa=" nfa)
  (let ( (loc (unsafe_get_field :nrep_loc nfa))
	 (obj (unsafe_get_field :naccf_obj nfa))
	 (fld (unsafe_get_field :naccf_fld nfa))
	 (:long fldoff (get_int fld))
	 (boxfldoff (make_integerbox discr_integer fldoff))
	 (cobj (compile_obj obj gcx))
	 ;; we factor the case when the field access cannot be done at
	 ;; compile time
	 (makecompute 
	  (lambda ()
	    (let ( 
		  (tcont 
		   (tuple  
		    (make_stringconst discr_verbatim_string "/*fieldacc*/(melt_field_object((melt_ptr_t)(")
		    cobj
		    (make_stringconst discr_verbatim_string "),")
		    boxfldoff
		    (make_stringconst discr_verbatim_string "))")
		    )) 
		  (res 
		   (instance class_objexpv
			     :obv_type ctype_value
			     :obx_cont tcont))
		  )
	      (debug "compilobj_nrep_fieldacc makecompute res=" res)
	      res
	      )))
	 )
    (assert_msg "compilobj_nrep_fieldacc check fld" (is_a fld class_field))
    (debug "compilobj_nrep_fieldacc cobj=" cobj " fld=" fld)
    (if (is_a cobj class_objinitobject)
	(let ( (cdata (unsafe_get_field :oie_data cobj)) 
	       )
	  (if (is_a cdata class_nrep_datainstance)
	      (let ( (slotup (unsafe_get_field :ninst_slots cdata)) 
		     (ourslot (multiple_nth slotup fldoff)) 
		     )
		(if (is_a ourslot class_nrep_bound_data)
		    (let ( (cslot (compile_obj ourslot gcx)) )
		      (debug "compilobj_nrep_fieldacc returning cslot=" cslot)
		      (return cslot))
		  (return (makecompute))))
	    (return (makecompute)))
	  )
      (return (makecompute))
      )))
(install_method class_nrep_fieldacc compile_obj compilobj_nrep_fieldacc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe get field access
(defun compilobj_nrep_unsafe_get_field (nugf gcx)
  (assert_msg "check nugf" (is_a nugf class_nrep_unsafe_get_field))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_unsafe_get_field nugf=" nugf)
  (let ( (loc (unsafe_get_field :nrep_loc nugf)) 
	 (nobj (unsafe_get_field :nuget_obj nugf))
	 (nfield (unsafe_get_field :nuget_field nugf))
	 (dlist (make_list discr_list))
	 (oobj (compile_obj nobj gcx))
	 (ogetslot (instance class_objgetslot
			     :obi_loc loc
			     :obdi_destlist dlist
			     :ogetsl_obj oobj
			     :ogetsl_field nfield))
	 )
    (return ogetslot)
    ))
(install_method class_nrep_unsafe_get_field compile_obj compilobj_nrep_unsafe_get_field)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe put fields
(defun compilobj_nrep_unsafe_put_fields (nupf gcx)
  (assert_msg "check nupf" (is_a nupf class_nrep_unsafe_put_fields))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_unsafe_put_fields nupf=" nupf)
  (let ( (loc (unsafe_get_field :nrep_loc nupf)) 
	 (nobj (unsafe_get_field :nuput_obj nupf))
	 (nfldass (unsafe_get_field :nuput_fields nupf))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (oobj (compile_obj nobj gcx))
	 )
    (multiple_every 
     nfldass
     (lambda (nfa :long ix)
       (assert_msg "check nfa" (is_a nfa class_nrep_fieldassign))
       (let ( (aloc (unsafe_get_field :nrep_loc nfa)) 
	      (afield (unsafe_get_field :nfla_field nfa))
	      (aval (unsafe_get_field :nfla_val nfa))
	      (:long aoff (get_int afield))
	      )
	 (assert_msg "check afield" (is_a afield class_field))
	 (let ( 
	       (oval (compile_obj aval gcx)) 
	       (opuf (instance class_objputslot
			       :obi_loc (if aloc aloc loc)
			       :oslot_odata oobj
			       :oslot_field afield
			       :oslot_offset (make_integerbox discr_integer aoff)
			       :oslot_value oval)) )
	   (assert_msg "compilobj_nrep_unsafe_put_fields check oval not nrep" (not (is_a oval class_nrep)))
	   (list_append obodl opuf))
	 )))
    (list_append obodl (instance class_objtouch
				 :obi_loc loc
				 :otouch_val oobj))
    ;; emit debugtrace of written object
    (list_append obodl (instance class_objdbgtracewriteobj
				 :obi_loc loc
				 :obdtw_writtenobj oobj
				 :obdtw_message '"put-fields"))
    ;; add the updated obj to the block
    (list_append obodl oobj)
    (return oblock)
    ))
(install_method class_nrep_unsafe_put_fields compile_obj compilobj_nrep_unsafe_put_fields)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_checksignal (nchint gcx)
  (debug "compilobj_nrep_checksignal nchint=" nchint)
  (assert_msg "check nchint" (is_a nchint class_nrep_checksignal))
  (let (
	(nloc (unsafe_get_field :nrep_loc nchint))
	(ochint (instance class_objchecksignal
			  :obi_loc nloc))
	)
    (debug "compilobj_nrep_checksignal ochint=" ochint)
    (return ochint)
    ))

(install_method class_nrep_checksignal compile_obj compilobj_nrep_checksignal)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile an unsafe nth component
(defun compilobj_nrep_unsafe_nth_component (nunc gcx)
  (assert_msg "check nunc" (is_a nunc class_nrep_unsafe_nth_component))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_unsafe_nth_component nunc=" nunc)
  (let ( (nloc (unsafe_get_field :nrep_loc nunc))
	 (ntup (unsafe_get_field :nunth_tuple nunc))
	 (nidx (unsafe_get_field :nunth_index nunc))
	 (otup (compile_obj ntup gcx))
	 (oidx (compile_obj nidx gcx))
	 (ounc (make_objcompute nloc ctype_value ##{/*unsafenthcomp*/((meltmultiple_ptr_t)($OTUP))->tabval[$OIDX]}#
				))
	)
    (debug "compilobj_nrep_unsafe_nth_component otup=" otup " oidx=" oidx " ounc=" ounc)
    (return ounc)
  ))
(install_method class_nrep_unsafe_nth_component compile_obj compilobj_nrep_unsafe_nth_component)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple application
(defun compilobj_nrep_apply (napp gcx)
  (assert_msg "check napp" (is_a napp class_nrep_apply))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc napp))
	 (fun (unsafe_get_field :napp_fun napp))
	 (args (unsafe_get_field :nexpr_args napp))
	 )
    (debug "compilobj_nrep_apply napp=" napp)
    (let ( (oclos (compile_obj fun gcx)) 
	   (oargs (multiple_map
		   args
		   (lambda (comp :long ix)
		     (let ( (ocomp (compile_obj comp gcx)) )
		       (assert_msg "compilobj_nrep_apply check ocomp not objinstr"
				   (not (is_a ocomp class_objinstr)))
		       ocomp))))
	   (dlist (make_list discr_list))
	   (oapp 
	    (instance 
	     class_objapply
	     :obi_loc loc
	     :obdi_destlist dlist
	     :obapp_clos oclos
	     :obapp_args oargs))
	   )
      (debug "compilobj_nrep_apply return oapp=" oapp)
      oapp
      )))
(install_method class_nrep_apply compile_obj compilobj_nrep_apply)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_multiapply (nmapp gcx)
  (assert_msg "check napp" (is_a nmapp class_nrep_multiapply))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_multiapply nmapp=" nmapp)
  (let ( (loc (unsafe_get_field :nrep_loc nmapp))
	 (rbinds (unsafe_get_field :nmulapp_bindings nmapp))
	 (fun (unsafe_get_field :napp_fun nmapp))
	 (args (unsafe_get_field :nexpr_args nmapp))
	 (nbody (unsafe_get_field :nmulapp_body nmapp))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (assert_msg "compilobj_nrep_multiapply check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multiapply check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       obva
	       ))))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (oxres (if (>i nbres 1) (make_multiple discr_multiple (-i nbres 1)) ()))
	 (firstres (multiple_nth reslocs 0))
	 (ofun (compile_obj fun gcx))
	 (reslist (make_list discr_list))
	 (oargs (multiple_map args
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (omapp (instance class_objmultiapply
			  :obi_loc loc
			  :obdi_destlist reslist
			  :obapp_clos (compile_obj fun gcx)
			  :obapp_args oargs
			  :obmultapp_xres oxres))
	 )
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (multiple_every 
     oargs
     (lambda (ocurarg :long ix)
       (if (and ocurarg (or (is_not_a ocurarg class_objpurevalue) (is_a ocurarg class_objinstr)))
	   (list_append obodl ocurarg))))
    ;; add the multiapply to the block
    (list_append obodl omapp)
    ;; add the compiled body to the block
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0) 
	   (let ( (oclear (instance class_objclear 
				    :obi_loc loc
				    :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)
	     ))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug "compilobj_nrep_multiapply final oblock=" oblock)
    oblock
    ))
(install_method class_nrep_multiapply compile_obj compilobj_nrep_multiapply)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a simple message send
(defun compilobj_nrep_msend (nsnd gcx)
  (assert_msg "check nsnd" (is_a nsnd class_nrep_msend))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc nsnd))
	 (nsel (unsafe_get_field :nsend_sel nsnd))
	 (nrecv (unsafe_get_field :nsend_recv nsnd))
	 (nargs (unsafe_get_field :nexpr_args nsnd))
	 )
    (debug "compilobj_nrep_msend nsnd=" nsnd)
    (assert_msg "check nrecv" (is_object nrecv))
    (let ( (osel (compile_obj nsel gcx))
	   (orecv (compile_obj nrecv gcx))
	   (oargs (multiple_map 
		   nargs
		   (lambda (ncurarg :long ix)
		     (debug "compilobj_nrep_msend ncurarg=" ncurarg " ix=" ix)
		     (let ( (ocurarg (compile_obj ncurarg gcx)) 
			    )
		       (debug "compilobj_nrep_msend ocurarg=" ocurarg)
		       (assert_msg "check ocurarg not tuple" (not (is_multiple ocurarg)))
		       ocurarg
		       ))))
	   (osend
	    (instance 
	     class_objmsend
	     :obi_loc loc
	     :obdi_destlist (make_list discr_list)
	     :obmsnd_sel osel
	     :obmsnd_recv orecv
	     :obmsnd_args oargs
	     ))
	   )
      (debug "compilobj_nrep_msend osend=" osend)
      (assert_msg "check orecv" (is_object orecv))
      osend
      )))
(install_method class_nrep_msend compile_obj compilobj_nrep_msend)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a multiresult message send
(defun compilobj_nrep_multimsend (nmsnd gcx)
  (assert_msg "check nmsnd" (is_a nmsnd class_nrep_multimsend))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_multimsend nmsnd=" nmsnd)
  (let ( (loc (unsafe_get_field :nrep_loc nmsnd)) 
	 (rbinds (unsafe_get_field :nmulsend_bindings nmsnd))
	 (nbody (unsafe_get_field :nmulsend_body nmsnd)) ; a single normalized expression
	 (nsel (unsafe_get_field :nsend_sel nmsnd))
	 (nrecv (unsafe_get_field :nsend_recv nmsnd))
	 (nargs (unsafe_get_field :nexpr_args nmsnd))
	 (locmap (unsafe_get_field :gncx_locmap gcx))
	 (:long nbres (multiple_length rbinds))
	 (reslocs 
	  (multiple_map
	   rbinds
	   (lambda (bind :long ix)
	     (assert_msg "compilobj_nrep_multimsend check bind" 
			 (is_a bind class_formal_binding))
	     (let ( (bder (unsafe_get_field :binder bind))
		    (cty (unsafe_get_field :fbind_type bind)) 
		    (obva (get_free_objloctyped gcx bder cty))
		    )
	       (assert_msg "compilobj_nrep_multimsend check cty" 
			   (is_a cty class_ctype))
	       ;; link nlbnd to obva in locmap
	       (if obva (mapobject_put locmap bind obva))
	       obva
	       ))))
	 (oxres (if (>i nbres 1) 
		    (make_multiple discr_multiple  (-i nbres 1))))
	 (firstres (multiple_nth reslocs 0))
	 (osel (compile_obj nsel gcx))
	 (reslist (make_list discr_list))
	 (orecv (compile_obj nrecv gcx))
	 (oargs (multiple_map nargs
			      (lambda (comp :long ix)
				(compile_obj comp gcx))))
	 (obody (compile_obj nbody gcx))
	 (obodl (make_list discr_list))
	 (oepil (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc loc
			   :oblo_bodyl obodl
			   :oblo_epil oepil))
	 (omsend (instance class_objmultimsend
			   :obi_loc loc
			   :obdi_destlist reslist
			   :obmsnd_sel osel
			   :obmsnd_recv orecv
			   :obmsnd_args oargs
			   :obmultsnd_xres oxres))
	 )
    (assert_msg "check orecv" (is_object orecv))
    (if firstres (list_append reslist firstres))
    ;; add every compiled argument to the resulting block unless it is a pure value
    (foreach_in_multiple 
     (oargs)
     (ocurarg :long ix)
     (if (and ocurarg (or (is_not_a ocurarg class_objpurevalue) (is_a ocurarg class_objinstr)))
	 (list_append obodl ocurarg)))
    ;; add the multisend to the block
    (list_append obodl omsend)
    ;; add the compiled body to the block
    (list_append obodl obody)
    ;; add the clearing of each result to epilog
    (multiple_every 
     reslocs
     (lambda (rloc :long ix)
       (if (>i ix 0)
	   (let ( (oclear (instance class_objclear 
				    :obi_loc loc
				    :oclr_vloc rloc)) )
	     (list_append oepil oclear)
	     (multiple_put_nth oxres (-i ix 1) rloc)))))
    ;; dispose the local bindings
    (multiple_every 
     rbinds
     (lambda (bind :long ix) (dispose_bnd_obj bind gcx)))
    (debug  "compilobj_nrep_multimsend final oblock=" oblock)
    oblock
    ))

(install_method class_nrep_multimsend compile_obj compilobj_nrep_multimsend)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile bindings
(defun compilobj_any_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_any_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_any_binding bind=" bind)
  (outcstring_err "* compilobj unimplemented receiver binding class ")
  (let ( (discr (discrim bind)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_obj should be implemented in anybinding-s subclasses" ()))
  
(install_method class_any_binding compile_obj compilobj_any_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile value bindings
(defun compilobj_value_binding  (bind gcx)
  (assert_msg "check bind" (is_a bind class_value_binding))
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (debug "compilobj_value_binding bind=" bind)
  (let ( (sym (get_field :binder bind))
	 (importmap (get_field :igncx_importmap gcx))
	 (olocv (mapobject_get importmap sym))
	 )
    (debug "compilobj_value_binding olocv=" olocv " importmap=" importmap)
    (assert_msg "check olocv" (is_a olocv class_objlocv))
    (return olocv)
    )
  )
(install_method class_value_binding compile_obj compilobj_value_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_fixed_binding (bind gcx)
  (assert_msg "check bind" (is_a bind class_fixed_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_fixed_binding bind=" bind)
  (let ( (sbdata (unsafe_get_field :fixbind_data bind)) 
	 (osdata (compile_obj sbdata gcx)) )
    (debug "compilobj_fixed_binding sbdata=" sbdata " osdata=" osdata)
    (return osdata)
    )
  )
(install_method class_fixed_binding compile_obj compilobj_fixed_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_normal_let_binding (bind gcx)
  (assert_msg "check bind" (is_a bind class_normal_let_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_normal_let_binding bind=" bind)
  (let ( (nexpr (unsafe_get_field :letbind_expr bind)) 
	 (ctyp (unsafe_get_field :letbind_type bind))
	 (bnder (unsafe_get_field :binder bind))
	 (oexpr (compile_obj nexpr gcx)) )
    (debug "compilobj_normal_let_binding oexpr=" oexpr)
    (assert_msg "compilobj_normal_let_binding got here" ())
    (return oexpr)
    )
  )
(install_method class_normal_let_binding compile_obj compilobj_normal_let_binding)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_conslambdabind (bind gcx)
  (assert_msg "check bind" (is_a bind class_normal_constructed_lambda_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_conslambdabind bind=" bind)
  (let ( (symb (unsafe_get_field :binder bind))
	 (loc (unsafe_get_field :nconsb_loc bind))
	 (ndiscr (unsafe_get_field :nconsb_discr bind))
	 (nclosed (unsafe_get_field :nlambdab_nclosed bind))
	 (ndatarout (unsafe_get_field :nlambdab_datarout bind))
	 (nconstrout (unsafe_get_field :nlambdab_constrout bind))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (odiscr (compile_obj ndiscr gcx))
	 (nambuf (make_strbuf discr_strbuf))
	 (nlocsyms (get_field :nletrec_locsyms nletrec))
	 (:long bindnum (get_int bind))
	 (:long nbclosed (multiple_length nclosed))
	 (locsymocc (multiple_nth nlocsyms bindnum))
	 )
    (let ( 
	  (orout (compile_obj nconstrout gcx))
	  (oloc (compile_obj locsymocc gcx))
	  )
      (add2sbuf_strconst nambuf "rclo_")
      (add2sbuf_longdec nambuf bindnum)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cident nambuf (unsafe_get_field :named_name symb))
      (if (is_a symb class_cloned_symbol)
	  (progn
	    (add2sbuf_strconst nambuf "_x")
	    (add2sbuf_longdec nambuf (get_int (get_field :csym_urank symb)))))
      (let ( (iniclos (instance class_objinitclosure
				:obv_type ctype_value
				:oie_discr odiscr
				:oie_locvar oloc
				:oie_cname (strbuf2string discr_string nambuf)
				:oiclo_rout orout
				))
	     )
	(put_int iniclos nbclosed)
	(debug "compilobj_conslambdabind returning iniclos=" iniclos)
	iniclos
	))))
(install_method class_normal_constructed_lambda_binding compile_obj compilobj_conslambdabind)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_constuplebind (bind gcx)
  (debug "compilobj_constuplebind bind=" bind)
  (assert_msg "check bind" (is_a bind class_normal_constructed_tuple_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (symb (unsafe_get_field :binder bind))
	 (nloc (unsafe_get_field :nconsb_loc bind))
	 (ndiscr (unsafe_get_field :nconsb_discr bind))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (ntupb (unsafe_get_field :ntupb_comp bind))
	 (odiscr (compile_obj ndiscr gcx))
	 (nambuf (make_strbuf discr_strbuf))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (nlocsyms (get_field :nletrec_locsyms nletrec))
	 (:long bindnum (get_int bind))
	 (:long lentup (multiple_length ntupb))
	 (locsymocc (multiple_nth nlocsyms bindnum))
	 )
      (add2sbuf_strconst nambuf "rtup_")
      (add2sbuf_longdec nambuf bindnum)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cident nambuf (unsafe_get_field :named_name symb))
      (if (is_a symb class_cloned_symbol)
	  (progn
	    (add2sbuf_strconst nambuf "_x")
	    (add2sbuf_longdec nambuf (get_int (get_field :csym_urank symb)))))
      (let ( 
	    (oloc (compile_obj locsymocc gcx))
	    (tupval (make_multiple discr_multiple lentup))
	    (initup (instance class_objinitmultiple
			       :obv_type ctype_value
			       :oie_discr odiscr
			       :oie_locvar oloc
			       :oie_cname (strbuf2string discr_string nambuf)
			       :oim_tupval tupval
			       ))
	    )
	(put_int initup lentup)
	(debug "compilobj_constuplebind result initup=" initup)
	initup
	)
    ))
(install_method class_normal_constructed_tuple_binding compile_obj compilobj_constuplebind)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_conspairbind (bind gcx)
  (debug "compilobj_conspairbind bind=" bind)
  (assert_msg "check bind" (is_a bind class_normal_constructed_pair_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (symb (unsafe_get_field :binder bind))
	 (nloc (unsafe_get_field :nconsb_loc bind))
	 (ndiscr (unsafe_get_field :nconsb_discr bind))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (nhead (unsafe_get_field :npairb_head bind))
	 (ntail (unsafe_get_field :npairb_tail bind))
	 (nlocsyms (get_field :nletrec_locsyms nletrec))
	 (odiscr (compile_obj ndiscr gcx))
	 (nambuf (make_strbuf discr_strbuf))
	 (:long bindnum (get_int bind))
	 (locsymocc (multiple_nth nlocsyms bindnum))
	 )
    (assert_msg "check nletrec" nletrec)
    (add2sbuf_strconst nambuf "rpair_")
    (add2sbuf_longdec nambuf bindnum)
    (add2sbuf_strconst nambuf "__")
    (add2sbuf_cident nambuf (unsafe_get_field :named_name symb))
    (if (is_a symb class_cloned_symbol)
	(progn
	  (add2sbuf_strconst nambuf "_x")
	  (add2sbuf_longdec nambuf (get_int (get_field :csym_urank symb)))))
    (let ( 
	  (oloc (compile_obj locsymocc gcx))
	  (inipair (instance class_objinitpair
			     :obv_type ctype_value
			     :oie_discr odiscr
			     :oie_locvar oloc
			     :oie_cname (strbuf2string discr_string nambuf)))
	  )
      (debug "compilobj_conspairbind return inipair=" inipair)
      (return inipair)
      )))
(install_method class_normal_constructed_pair_binding compile_obj compilobj_conspairbind)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_conslistbind (bind gcx)
  (debug "compilobj_conslistbind bind=" bind)
  (assert_msg "check bind" (is_a bind class_normal_constructed_list_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (symb (unsafe_get_field :binder bind))
	 (nloc (unsafe_get_field :nconsb_loc bind))
	 (ndiscr (unsafe_get_field :nconsb_discr bind))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (nfirst (unsafe_get_field :nlistb_first bind))
	 (nlast (unsafe_get_field :nlistb_last bind))
	 (nlocsyms (get_field :nletrec_locsyms nletrec))
	 (odiscr (compile_obj ndiscr gcx))
	 (nambuf (make_strbuf discr_strbuf))
	 (:long bindnum (get_int bind))
	 (locsymocc (multiple_nth nlocsyms bindnum))
	 )
    (add2sbuf_strconst nambuf "rlist_")
    (add2sbuf_longdec nambuf bindnum)
    (add2sbuf_strconst nambuf "__")
    (add2sbuf_cident nambuf (unsafe_get_field :named_name symb))
    (let ( 
	  (oloc (compile_obj locsymocc gcx))
	  (inilist (instance class_objinitlist
			     :obv_type ctype_value
			     :oie_discr odiscr
			     :oie_locvar oloc
			     :oie_cname (strbuf2string discr_string nambuf)
			     ))
	  )
      (debug "compilobj_conslistbind return inilist=" inilist)
      (return inilist)
      )))
(install_method class_normal_constructed_list_binding compile_obj compilobj_conslistbind)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_consinstancebind (bind gcx)
  (debug  "compilobj_consinstancebind bind=" bind)
  (assert_msg "check bind" (is_a bind class_normal_constructed_instance_binding))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (symb (unsafe_get_field :binder bind))
	 (nloc (unsafe_get_field :nconsb_loc bind))
	 (ndiscr (unsafe_get_field :nconsb_discr bind))
	 (nletrec (unsafe_get_field :nconsb_nletrec bind))
	 (nslots (unsafe_get_field :ninstb_slots bind))
	 (nambuf (make_strbuf discr_strbuf))
	 (odiscr (compile_obj ndiscr gcx))
	 (nlocsyms (get_field :nletrec_locsyms nletrec))
	 (:long bindnum (get_int bind))
	 (locsymocc (multiple_nth nlocsyms bindnum))
	 (nclabind (get_field :ninstb_clabind bind))
	 )
    (add2sbuf_strconst nambuf "rinst_")
    (add2sbuf_longdec nambuf bindnum)
    (add2sbuf_strconst nambuf "__")
    (add2sbuf_cident nambuf (unsafe_get_field :named_name symb))
    (let ( 
	  (oloc (compile_obj locsymocc gcx))
	  (clas (cond ( (is_a nclabind class_value_binding)
		       (unsafe_get_field :vbind_value nclabind))
		     ( (is_a nclabind class_class_binding)
		       (unsafe_get_field :cbind_class nclabind))
		     (:else
		      (debug "compilobj_consinstancebind bad nclabind=" nclabind)
		      (assert_msg "unexpected class binding" ()))))
	  (ininst (instance class_objinitobject
			    :obv_type ctype_value
			    :oie_discr odiscr
			    :oie_locvar oloc
			    :oie_cname (strbuf2string discr_string nambuf)
			    :oio_class clas
			    ))
	  )
      ;; set the length of the instance
      (put_int ininst (multiple_length (get_field :class_fields clas)))
      (debug "compilobj_consinstancebind return ininst=" ininst)
      (return ininst)
      )))
(install_method class_normal_constructed_instance_binding compile_obj compilobj_consinstancebind)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objvalue (recv desto)
  (assert_msg "check recv" (is_a recv class_objvalue))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (typrecv (unsafe_get_field :obv_type recv))
	 (typdesto (get_field :obv_type desto)) 
	 )
    (cond
     ;; special case when receiver is void
     ( (== typrecv ctype_void)
       (if (== typdesto ctype_void)
	   (return recv)
	 ;; if recv is void we just create a block with recv and the
	 ;; clear of desto
	 (let ( 
	       (obodl (make_list discr_list))
	       (oblk (instance class_objplainblock
			       ;; dont fill :obi_loc
			       :oblo_bodyl obodl
			       :oblo_epil ()
			       )
		     )
	       (oclr (instance class_objclear
			       ;; dont fill :obi_loc
			       :oclr_vloc desto
			       ))
	       )
	   (list_append obodl recv)
	   (list_append obodl oclr)
	   ;; the last of the block is the destination location, to
	   ;; avoid latter putobjdest-s on the objclear
	   (list_append obodl desto)
	   (return oblk)
	   )))
     ;; common case when desto & recv have same type
     ( (== typrecv typdesto)
       (assert_msg "check same typrecv&rtpdesto" (is_a typrecv class_ctype))
       (let ( (destlis (make_list discr_list))
	      (explis (make_list discr_list))
	      (obc (instance class_objcompute
			     ;; dont fill :obi_loc
			     :obdi_destlist destlis
			     :obcpt_expr explis
			     :obcpt_type typrecv
			     )) 
	      )
	 (list_append destlis desto)
	 (list_append explis recv)
	 (return obc)))
     ;; error case: type mismatch
     (:else
      (debug "putobjdest_objvalue mismatching recv=" recv " typrecv=" typrecv " desto=" desto " typdesto=" typdesto)
      (outcstring_err "putobjdest_objvalue type mismatch : recv <")
      (let ( (discr (discrim recv)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err "> & desto<") 
      (let ( (discr (discrim desto)) ) (outstr_err (unsafe_get_field :named_name discr)))
      (outcstring_err ">")
      (outnewline_err)
      (assert_msg "putobjdest_objvalue type mismatch" ())
      (return recv)))
    ))

(install_method class_objvalue  put_objdest  putobjdest_objvalue)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_integer (recv desto)
  (debug "putobjdest_integer recv=" recv "\n* desto=" desto
	 "\n* of discrim:" (discrim desto) "\n* class_objlocv=" class_objlocv)
  (assert_msg "check recv" (is_integerbox recv))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (get_field :obv_type desto))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlis
			:obcpt_expr explis
			:obcpt_type ctype_long
			)) 
	 )
    (assert_msg "check typdesto" (== typdesto ctype_long))
    (list_append destlis desto)
    (list_append explis recv)
    (debug "putobjdest_integer return obc=" obc)
    obc
    ))
(install_method discr_integer put_objdest putobjdest_integer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; put obj destination inside a string
;;; useful to compile (let ( (:cstring foo "abc") ) ...)
(defun putobjdest_string (recv desto)
  (assert_msg "check recv" (is_string recv))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (debug "putobjdest_string recv=" recv " desto=" desto)
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlis
			:obcpt_expr explis
			:obcpt_type ctype_cstring
			)) 
	 )
    (assert_msg "check typdesto" (== typdesto ctype_cstring))
    (list_append destlis desto)
    (list_append explis recv)
    (debug "putobjdest_string return obc=" obc)
    obc
    ))
(install_method discr_string put_objdest putobjdest_string)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_null (recv desto)
  (assert_msg "check recv" (null recv))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (debug "putobjdest_null recv=" recv " desto=" desto)
  (if (melt_need_dbg 0) (shortbacktrace_dbg "putobjdest_null" 15))
  (let ( (destlis (make_list discr_list))
	 (explis (make_list discr_list))
	 (typdesto (unsafe_get_field :obv_type desto))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlis
			:obcpt_expr explis
			:obcpt_type typdesto
			)) 
	 )
    (list_append destlis desto)
    (if (== typdesto ctype_long)
	(list_append explis (make_integerbox discr_integer 0))
      (list_append explis recv))
    (debug "putobjdest_null return obc=" obc)
    obc
    ))
(install_method discr_null_receiver put_objdest putobjdest_null)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objanyblock (recv desto)
  (assert_msg "check recv" (is_a recv class_objanyblock))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (obl (unsafe_get_field :oblo_bodyl recv))
	 (oep (unsafe_get_field :oblo_epil recv))
	 )
    (assert_msg "check obl" (is_list_or_null obl))
    (assert_msg "check oep" (is_list_or_null oep))
    ;; maybe we should remove in the epilogue any clear of same ctype & offset
    (let ( (lpby (list_last obl))
	   (lasbp (pair_head lpby))
	   )
      (if lasbp 
	  (let ( (uplasb (put_objdest lasbp desto)) )
	    (pair_set_head lpby uplasb)
	    )
	)
      )
    recv
    ))

(install_method class_objanyblock  put_objdest  putobjdest_objanyblock)


;;;;;;;;;;
(defun putobjdest_objmultiblock (recv desto)
  (assert_msg "check recv" (is_a recv class_objmultiblock))
  (debug "putobjdest_objmultiblock recv=" recv " desto=" desto)
  (let ( (osubcomp (unsafe_get_field :omulblo_subcomp recv)) )
    (assert_msg "check osubcomp" (is_multiple_or_null osubcomp))
    (foreach_in_multiple
     (osubcomp)
     (cursubcomp :long curix)
     (put_objdest cursubcomp desto))
    (debug  "putobjdest_objmultiblock done recv=" recv)
))
(install_method class_objmultiblock put_objdest putobjdest_objmultiblock)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun putobjdest_objloop (recv desto)
  (assert_msg "check recv" (is_a recv class_objloop))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (epil (unsafe_get_field :oblo_epil recv)) 
	 (resv (unsafe_get_field :obloop_resv recv))
	 (destlist (make_list discr_list))
	 (obc (instance class_objcompute
			;; dont fill :obi_loc
			:obdi_destlist destlist
			:obcpt_expr resv
			:obcpt_type ctype_value
			))
	 )
    (list_append destlist desto)
    (assert_msg "check epil" (is_list epil))
    (assert_msg "check resv" (is_a resv class_objlocv))
    (list_append epil obc)
    )
  (debug "putobjdest loop updated recv=" recv)
  recv
  )
(install_method class_objloop  put_objdest  putobjdest_objloop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; do nothing when puting a destination into an objexit
(defun putobjdest_objexit (recv desto)
  (assert_msg "check recv" (is_a recv class_objexit))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  recv
  )
(install_method class_objexit put_objdest putobjdest_objexit)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_if (rif gcx)
  (assert_msg "check rif" (is_a rif class_nrep_if))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_if rif=" rif)
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (ntest (unsafe_get_field :nif_test rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nctyp (unsafe_get_field :nexpr_ctyp rif))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (let ( (otest (compile_obj ntest gcx))
	   (othen (compile_obj nthen gcx))
	   (oelse (if (is_not_a nelse class_nrep_nil) 
		      (compile_obj nelse gcx)))
	   (obif (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	   )
      (debug "compilobj_nrep_if ntest=" ntest " otest=" otest)
      (debug "compilobj_nrep_if nthen=" nthen " otest=" othen)
      (debug "compilobj_nrep_if nthen=" nelse " otest=" oelse)
      (debug "compilobj_nrep_if obif=" obif)
      (assert_msg "check otest" (notnull otest))
      obif
      )))
(install_method class_nrep_if compile_obj compilobj_nrep_if)


;;;;;;;;;;;;;;;;
(defun compilobj_nrep_ifisa (rif gcx)
  (debug "compilobj_nrep_ifisa rif=" rif)
  (assert_msg "check rif" (is_a rif class_nrep_ifisa))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nctyp (unsafe_get_field :nexpr_ctyp rif))
	 (nval (get_field :nif_testval rif))
	 (ncla (unsafe_get_field :nifa_class rif))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (let ( (othen (compile_obj nthen gcx))
	   (oval (compile_obj nval gcx))
	   (ocla (compile_obj ncla gcx))
	   (oelse (if (is_not_a nelse class_nrep_nil) 
		      (compile_obj nelse gcx)))
	   (otest (make_objlocatedexp loc ctype_long
				      ##{/*ifisa*/ melt_is_instance_of((melt_ptr_t)($OVAL), 
                                                                       (melt_ptr_t)($OCLA))
				      }#))
	   (obif (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	   )
      (debug "compilobj_nrep_ifisa obif=" obif)
      obif
      )))
(install_method class_nrep_ifisa compile_obj compilobj_nrep_ifisa)


;;;;;;;;;;;;;;;;
(defun compilobj_nrep_iftuplesized (rif gcx)
  (debug "compilobj_nrep_ifisa rif=" rif)
  (assert_msg "check rif" (is_a rif class_nrep_iftuplesized))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nval (get_field :nif_testval rif))
	 (ntsz (get_field :nif_tupsiz rif))
	 )
    (debug "compilobj_nrep_iftuplesized nval=" nval " ntsz=" ntsz)
    (let (  (othen (compile_obj nthen gcx))
	    (oval (compile_obj nval gcx))
	    (oelse (compile_obj nelse gcx))
	    (oval (compile_obj nval gcx))
	    (otsz (compile_obj ntsz gcx))
	    (otest
	     (make_objlocatedexp loc ctype_long
				 ##{/*iftuplesized*/ melt_magic_discr((melt_ptr_t)($OVAL)) == MELTOBMAG_MULTIPLE
				 && ((meltmultiple_ptr_t)($OVAL))->nbval == (int)($OTSZ)}#))
	   (obif (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	  )
      (debug "compilobj_nrep_iftuplesized obif=" obif)
      obif
)))
(install_method class_nrep_iftuplesized compile_obj compilobj_nrep_iftuplesized)

;;;;;;;;;;;;;;;;
(defun compilobj_nrep_ifvariadic (rif gcx)
  (assert_msg "check rif" (is_a rif class_nrep_ifvariadic))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug  "compilobj_nrep_ifvariadic rif=" rif)
  (let ( (loc (unsafe_get_field :nrep_loc rif))
	 (nthen (unsafe_get_field :nif_then rif))
	 (nelse (unsafe_get_field :nif_else rif))
	 (nvariadic (unsafe_get_field :nifv_variadic rif))
	 (nvctypes (unsafe_get_field :nifv_ctypes rif))
	 (:long nbvararg (multiple_length nvctypes))
	 )
    (assert_msg "check nvctypes" (is_multiple_or_null nvctypes))
    (assert_msg "check nvariadic" (is_a nvariadic class_symbol))
    (debug "compilobj_nrep_ifvariadic nthen=" nthen " nelse=" nelse " nvariadic=" nvariadic)
    (let ( 
	  (ovariadicindex (variadic_index_idstr nvariadic))
	  (ovariadiclength (variadic_length_idstr nvariadic))
	  (otestchklist 
	   (if (<=i nbvararg 0) 
	       (list
		(make_stringconst discr_verbatim_string "/*ifvariadic nomore*/ ")
		ovariadicindex
		(make_stringconst discr_verbatim_string " == ")
		ovariadiclength
		)
	     (let ( (ovlist
		     (list
		      (make_stringconst discr_verbatim_string "/*ifvariadic arg#")
		      (make_integerbox discr_constant_integer nbvararg)
		      (make_stringconst discr_verbatim_string "*/ ")
		       ovariadicindex
		      (make_stringconst discr_verbatim_string ">=0 && ")
		      ovariadicindex
		      (make_stringconst discr_verbatim_string " + ")
		      (make_integerbox discr_constant_integer nbvararg)
		      (make_stringconst discr_verbatim_string " <= ")
		      ovariadiclength
		      ))
		    )
	       (foreach_in_multiple
		(nvctypes)
		(curctyp :long ix)
		(debug "compilobj_nrep_ifvariadic curctyp" curctyp " ix=" ix)
		(assert_msg "check curctyp" (is_a curctyp class_ctype))
		(list_append ovlist (make_stringconst discr_verbatim_string " && meltxargdescr_["))
		(list_append ovlist ovariadicindex)
		(if ix
		    (progn
		      (list_append ovlist (make_stringconst discr_verbatim_string " + "))
		      (list_append ovlist (make_integerbox discr_constant_integer ix))))
		(list_append ovlist (make_stringconst discr_verbatim_string "]== "))
		(list_append ovlist 
			     (make_string discr_verbatim_string 
					  (get_field :ctype_parchar curctyp)))
		)
	       (debug "compilobj_nrep_ifvariadic ovlist=" ovlist)
	       ovlist))
	   )
	  (otest (instance  class_objexpv
			    :obx_cont (list_to_multiple otestchklist discr_multiple)))
	  (othen 
	   (progn 
	     (debug "compilobj_nrep_ifvariadic before compiling nthen=" nthen)
	     (let ( (objthen (compile_obj nthen gcx))
		    )
	       (debug "compilobj_nrep_ifvariadic after compiling nthen=" nthen 
		      " objthen=" objthen)
	       objthen)))
	  (oelse 
	   (progn 
	     (debug "compilobj_nrep_ifvariadic before compiling nelse=" nelse)
	     (let ( (objelse (compile_obj nelse gcx))
		    )
	       (debug "compilobj_nrep_ifvariadic after compiling nelse=" nelse
		      " objelse=" objelse)
	       objelse)))
	  (ocond (instance class_objcond
			   :obi_loc loc
			   :obcond_test otest
			   :obcond_then othen
			   :obcond_else oelse))
	  )
      (debug "compilobj_nrep_ifvariadic ocond=" ocond)
      (return ocond))))
(install_method class_nrep_ifvariadic compile_obj compilobj_nrep_ifvariadic)

(defun getctype_ifvariadic (rif env)
  (assert_msg "check ifvariadic" (is_a rif class_nrep_ifvariadic))
  ctype_void)
(install_method class_nrep_ifvariadic get_ctype getctype_ifvariadic)


;;;;;;;;;;;;;;;;

(defun compilobj_nrep_variadic_argument (nvarg gcx)
  (debug "compilobj_nrep_variadic_argument nvarg=" nvarg)
  (assert_msg "check nvarg" (is_a nvarg class_nrep_variadic_argument))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (nloc (unsafe_get_field :nrep_loc nvarg))
	 (nvariadic (unsafe_get_field :nvarg_variadic nvarg))
	 (nctyp (unsafe_get_field :nvarg_ctyp nvarg))
	 (noffset (unsafe_get_field :nvarg_offset nvarg))
	 (ovariadicindex (variadic_index_idstr nvariadic))
	 (ovariadiclength (variadic_length_idstr nvariadic))
	 )
    (assert_msg "check nctyp" (is_a nctyp class_ctype))
    (assert_msg "check noffset" (is_integerbox noffset))
    (let (
	  (otuple 
	   (if (== nctyp ctype_value)
	       (tuple
		(make_stringconst discr_verbatim_string "/*variadic argument value*/ ((meltxargtab_[")
		ovariadicindex
		(make_stringconst discr_verbatim_string " + ")
		noffset
		(make_stringconst discr_verbatim_string "].meltbp_aptr) ? (*(meltxargtab_[")
		ovariadicindex
		(make_stringconst discr_verbatim_string " + ")
		noffset
		(make_stringconst discr_verbatim_string "].meltbp_aptr)) : NULL)")
		)
	     (tuple
	      (make_stringconst discr_verbatim_string "/*variadic argument stuff*/ meltxargtab_[")
	      ovariadicindex
	      (make_stringconst discr_verbatim_string " + ")
	      noffset
	      (make_stringconst discr_verbatim_string "].")
	      (make_string discr_verbatim_string (get_field :ctype_argfield nctyp))
	      )))
	  (ocomp (instance 
		  class_objcompute
		  :obi_loc nloc
		  :obcpt_type nctyp
		  :obcpt_expr otuple))
	  )
      (debug "compilobj_nrep_variadic_argument ocomp=" ocomp)
      (return ocomp)
      )))
(install_method class_nrep_variadic_argument compile_obj compilobj_nrep_variadic_argument)


;;;;;;;;;;;;;;;;
(defun compilobj_nrep_consumevariadic (rcv gcx)
  (assert_msg "check rcv" (is_a rcv class_nrep_consume_variadic))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_consumevariadic rcv=" rcv)
  (let ( (nloc (unsafe_get_field :nrep_loc rcv))
	 (nvariadic (unsafe_get_field :nconsva_variadic rcv))
	 (nctypes (unsafe_get_field :nconsva_ctypes rcv))
	 (olist (make_list discr_list))
	 (ovariadicindex (variadic_index_idstr nvariadic))
	 (ovariadiclength (variadic_length_idstr nvariadic))
	 )
    (assert_msg "check nctypes" (is_multiple_or_null nctypes))
    (list_append olist (make_stringconst discr_verbatim_string "/*consume variadic "))
    (foreach_in_multiple 
     (nctypes)
     (curctyp :long typix)
     (assert_msg "check curctyp" (is_a curctyp class_ctype))
     (if (== curctyp ctype_value)
	 (list_append olist (make_stringconst discr_verbatim_string "Value"))
       (list_append olist (make_string discr_verbatim_string (get_field :named_name (get_field :ctype_keyword curctyp))))))
    (list_append olist (make_stringconst discr_verbatim_string " !*/ "))
    (list_append olist ovariadicindex)
    (list_append olist (make_stringconst discr_verbatim_string " += "))
    (list_append olist (make_integerbox discr_integer (multiple_length nctypes)))
    (let (
	  (otuple (list_to_multiple olist))
	  (ocomp (instance 
		  class_objcompute
		  :obi_loc nloc
		  :obcpt_type ctype_void
		  :obcpt_expr otuple))
	  )
      (debug "compilobj_nrep_consumevariadic ocomp=" ocomp)
      (return ocomp)
      )))
(install_method class_nrep_consume_variadic compile_obj compilobj_nrep_consumevariadic)

;;;;;;;;;;;;;
(defun putobjdest_objcond (recv desto)
  (assert_msg "check recv" (is_a recv class_objcond))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (othen (unsafe_get_field :obcond_then recv))
	 (oelse (unsafe_get_field :obcond_else recv)) 
	 )
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
      (unsafe_put_fields recv
			 :obcond_then dthen
			 :obcond_else delse)
      recv
      )))

(install_method class_objcond  put_objdest  putobjdest_objcond)
;;;;;;;;;;;;;;;;

(defun compilobj_nrep_cppif (pif gcx)
  (assert_msg "check pif" (is_a pif class_nrep_cppif))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (loc (unsafe_get_field :nrep_loc pif))
	 (ncond (unsafe_get_field :nifp_cond pif))
	 (nthen (unsafe_get_field :nifp_then pif))
	 (nelse (unsafe_get_field :nifp_else pif))
	 (ctyp (unsafe_get_field :nifp_ctyp pif))
	 (scond (cond
		 ( (is_a ncond class_symbol) (unsafe_get_field :named_name ncond))
		 ( (is_string ncond) ncond)
		 (:else (assert_msg "invalid ncond in nrep_cppif" ()))))
	 (othen (compile_obj nthen gcx))
	 (oelse (compile_obj nelse gcx))
	 (res (instance class_objcppif
			:obi_loc loc
			:obifp_cond scond
			:obifp_then othen
			:obifp_else oelse))
	 )
    (return res)
    ))
(install_method class_nrep_cppif compile_obj compilobj_nrep_cppif)


;;;;;;;;;;;;;
(defun putobjdest_objcppif (recv desto)
  (assert_msg "check recv" (is_a recv class_objcppif))
  (assert_msg "check desto" (is_a desto class_objpurevalue))
  (let ( (othen (unsafe_get_field :obifp_then recv))
	 (oelse (unsafe_get_field :obifp_else recv)) 
	 )
    (let ( (dthen (put_objdest othen desto))
	   (delse (put_objdest oelse desto)) )
      (unsafe_put_fields recv
			 :obifp_then dthen
			 :obifp_else delse)
      recv
      )))

(install_method class_objcppif  put_objdest  putobjdest_objcppif)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_nrep_return (nret gcx)
  (assert_msg "check nret" (is_a nret class_nrep_return))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_return nret=" nret)
  (let ( (rloc (unsafe_get_field :nrep_loc nret))
	 (rmain (unsafe_get_field :nret_main nret))
	 (rrest (unsafe_get_field :nret_rest nret)) ;; a tuple or nil
	 (retloc (unsafe_get_field :gncx_retloc gcx))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc rloc
			   :oblo_bodyl olis))
	 (omainv (compile_obj rmain gcx))
	 )
    (assert_msg "check orout" (is_a orout class_routineobj))
    (assert_msg "check rrest" (is_multiple_or_null rrest))
    (if (null (unsafe_get_field :obrout_retval orout))
	(unsafe_put_fields orout :obrout_retval retloc))
    (list_append olis (put_objdest omainv retloc))
    (foreach_in_multiple
     (rrest)
     (rxtra :long ix)
     (debug "compilobj_nrep_return rxtra=" rxtra " ix=" ix)
     (let ( (oxres 
	     (instance class_objputxtraresult
		       :obi_loc rloc
		       :obxres_rank (make_integerbox discr_integer ix)
		       :obxres_obloc (compile_obj rxtra gcx))) 
	    )
       ;; maybe we need to compute the ctype of the extra result....
       (list_append olis oxres)))
    ;; if no secondary results are returned, emit a check that no
    ;; secondary actual results are expected
    (if (==i (multiple_length rrest) 0)
	(let ( (ochecknores 
		(make_objlocatedexp rloc ctype_void		
				    ##{ /*ochecknores compilobj_nrep_return*/
#if MELT_HAVE_DEBUG
    if (meltxresdescr_ && meltxresdescr_[0] && meltxrestab_)  melt_warn_for_no_expected_secondary_results();
     /* we warned when secondary results are expected but not returned. */
#endif /*MELT_HAVE_DEBUG*/
}#
	     ))
	     )
	(debug "compilobj_nrep_return ochecknores=" ochecknores)
	(list_append olis ochecknores)
      ))
    (list_append olis 
		 (instance class_objfinalreturn
			   :obi_loc rloc))
    (debug "compilobj_nrep_return final oblock=" oblock)
    oblock
    ))
 
(install_method class_nrep_return compile_obj compilobj_nrep_return)

(install_method class_nrep_return get_ctype 
		(lambda (recv env) ctype_value))
;; all the closures generated by lambda share the same ...
(definstance discrclosure_objpredef class_objpredef
  :obv_type ctype_value
  :obpredef 'DISCR_CLOSURE
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_lambda (nlam gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nlam" (is_a nlam class_nrep_lambda))
  (debug "compilobj_nrep_lambda nlam=" nlam)
  (let ( (nloc (unsafe_get_field :nrep_loc nlam))
	 (npro (let 
		   ( (checkpro (unsafe_get_field :nlambda_proc nlam)) )
		 (assert_msg "check checkpro" (is_a checkpro class_nrep_routproc))
		 checkpro))
	 (nam (unsafe_get_field :nrpro_name npro))
	 (nclovtup (unsafe_get_field :nlambda_closedv nlam))
	 (:long nbclosed (multiple_length nclovtup))
	 (locv (get_free_objlocptr gcx nam))
	 (nrou (unsafe_get_field :nlambda_constrout nlam))
	 (orout (unsafe_get_field :gncx_objrout gcx))
	 (olis (make_list discr_list))
	 (oblock (instance class_objplainblock
			   :obi_loc nloc
			   :oblo_bodyl olis))
	 (destlist (make_list discr_list))
	 )
    (list_append destlist locv)
    (list_append olis 
		 (instance 
		  class_objnewclosure
		  :obi_loc nloc
		  :obnclo_discr discrclosure_objpredef
		  :obnclo_rout 
		  (progn 
		    (let ( (crou (compile_obj nrou gcx)) )
		      crou)
		    )
		  :obnclo_len (make_integerbox discr_integer nbclosed)
		  :obdi_destlist destlist))
    (multiple_every
     nclovtup
     (lambda (clov :long ix)
       (list_append 
	olis
	(instance class_objputclosedv
		  :obi_loc nloc
		  :opclov_clos locv
		  :opclov_off (make_integerbox discr_integer ix)
		  :opclov_cval (compile_obj clov gcx)))))
    ;; we don't need to add any objtouch because the nlam was normalized!
    (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
    (debug "compilobj_nrep_lambda result oblock=" oblock)
    oblock
    ))
(install_method class_nrep_lambda compile_obj compilobj_nrep_lambda)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_makeinst (nmki gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check nmki" (is_a nmki class_nrep_instance))
  (debug "compilobj_nrep_makeinst nmki=" nmki)
  (let ( (nloc (unsafe_get_field :nrep_loc nmki))
	 (ncla (unsafe_get_field :nmins_class nmki))
	 (ncladat (unsafe_get_field :nmins_cladata nmki))
	 (nfields (unsafe_get_field :nmins_fields nmki)) 
	 )
    (assert_msg "check ncla" (is_a ncla class_class))
    (let ( (:long nbfld (multiple_length (unsafe_get_field :class_fields ncla)))
	   (destlist (make_list discr_list))
	   (locv (get_free_objlocptr gcx 'inst))
	   (olis (make_list discr_list))
	   (ocladat (compile_obj ncladat gcx))
	   (oblock (instance class_objplainblock
			     :obi_loc nloc
			     :oblo_bodyl olis))
	   (orallobj (instance class_objrawallocobj
			       :obi_loc nloc
			       :obrallobj_class ocladat
			       :obrallobj_len (make_integerbox discr_integer nbfld)
			       :obrallobj_classname (unsafe_get_field :named_name  ncla)
			       :obdi_destlist destlist))
	   )
      (list_append destlist locv)
      (list_append olis orallobj)
      ;; handle each field assign
      (multiple_every
       nfields
       (lambda (cfla :long ix)
	 (assert_msg "compilobj_nrep_makeinst check cfla" (is_a cfla class_nrep_fieldassign))
	 (let ( (cfloc (unsafe_get_field :nrep_loc cfla))
		(cfield (unsafe_get_field :nfla_field cfla))
		(cval (unsafe_get_field :nfla_val cfla)) )
	   (assert_msg "compilobj_nrep_makeinst check cfield" (is_a cfield class_field))
	   (list_append 
	    olis
	    (let ( (oval (compile_obj cval gcx)) )
	      (assert_msg "compilobj_nrep_makeinst check oval not nrep" (not (is_a oval class_nrep)))
	      (instance class_objputslot 
			:obi_loc (if cfloc cfloc nloc)
			:oslot_odata locv
			:oslot_field cfield
			:oslot_offset (make_integerbox discr_integer (get_int cfield))
			:oslot_value oval)
	      )))))
      ;; since nmki was normalized, the new object was allocated in
      ;; the birth zone so don't need to be touched.  
      ;; 
      ;; add the debugtracing
      (let ( (odbgtr (instance class_objdbgtracewriteobj
			       :obi_loc nloc
			       :obdtw_writtenobj locv
			       :obdtw_message '"newly made instance"
			       ))
		     )
	(list_append olis odbgtr)
	)
      (list_append olis locv) ;;; last instruction is just the value, which can be set to some dest
      (debug "compilobj_nrep_makeinst result oblock=" oblock)
      oblock
      ))
  )
(install_method class_nrep_instance compile_obj compilobj_nrep_makeinst)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compile a procedure should not be called
(defun compilobj_routproc (npro gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check npro" (is_a npro class_nrep_routproc))
  (debug "compilobj_routproc npro=" npro " gcx=" gcx)
  (assert_msg "UNEXPECTED CALL TO compilobj_routproc" ())
  )
(install_method class_nrep_routproc compile_obj compilobj_routproc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
(defun compilobj_predef (npr gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (opr (instance class_objpredef
			:obv_type ctype_value
			:obpredef (unsafe_get_field :nrpredef npr))) )
    opr)
  )

(install_method class_nrep_predef compile_obj compilobj_predef)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; common code to compilobj_datasymbol & compilobj_datainstance
;;; to add the initial data fill and the slots filling
;;; return a tuple of bindings to be disposed
(defun compil_data_and_slots_fill (ndat obj odiscr irout gcx)
  (assert_msg "compil_data_and_slots_fill check ndat" (is_a ndat class_nrep_bound_data))
  (assert_msg "compil_data_and_slots_fill check obj" (is_a obj class_objinitobject))
  (assert_msg "compil_data_and_slots_fill check odiscr" (is_a odiscr class_objvalue))
  (assert_msg "compil_data_and_slots_fill check irout" (is_a irout class_initialroutineobj))
  (assert_msg "compil_data_and_slots_fill check gcx" (is_a gcx class_c_generation_context))
  (debug "compil_data_and_slots_fill start ndat=" ndat " obj=" obj " odiscr=" odiscr " irout=" irout)
  (let (
	(ipredef (if (is_a ndat class_nrep_datainstance) (unsafe_get_field :ninst_predef ndat)))
	(ibodylis (unsafe_get_field :obrout_body irout))
	(ifilllis (unsafe_get_field :oirout_fill irout))
	(locvar (get_free_objlocptr gcx '_valdata_))
	(comm (unsafe_get_field :named_name '_valuedata_))
	(nloc (unsafe_get_field :nrep_loc ndat))
	(dlocbind (unsafe_get_field :ndata_locbind ndat))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	(istmtlis ibodylis) ;the statement list to which the putslots are appended
	;; a tuple to store the objvar for localbinds to be able to clear them later
	(tupvar (make_multiple discr_multiple (multiple_length locmap)))
	)
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
    (assert_msg "compil_data_and_slots_fill check fresh obj" (null (unsafe_get_field :oie_locvar obj)))
    (unsafe_put_fields obj :oie_locvar locvar)
    (assert_msg "compil_data_and_slots_fill check ifilllis" (is_list ifilllis))
    (assert_msg "compil_data_and_slots_fill check ibodylis" (is_list ibodylis))
    ;; if the data is predefined, we fill it conditionally on !meltpredefinited[..]
    (if ipredef
	(let ( 
	      (otestpredef 
	       (cond 
		( (is_a ipredef class_symbol)
		  (instance 
		   class_objexpv
		   :obx_cont (tuple
			      (make_stringconst discr_verbatim_string 
						"MELTPREDEFIX(meltpredefinited,")
			      (make_string discr_verbatim_string 
					   (unsafe_get_field :named_name ipredef))
			      (make_stringconst discr_verbatim_string 
						")")
			      ))
		  )
		( (is_integerbox ipredef)
		  (instance
		   class_objexpv
		   :obx_cont (tuple
			      (make_stringconst discr_verbatim_string 
						"predefinited[")
			      ipredef
			      (make_stringconst discr_verbatim_string 
						"]")
			      ))
		  )
		))
	      (initlis (make_list discr_list))
	      (oblockpredef (instance 
			     class_objcommentedblock
			     :oblo_bodyl initlis
			     :ocomblo_comment '"fill predef slots"))
	      (ocondpredef (instance
			    class_objcond
			    :obi_loc nloc
			    :obcond_test otestpredef
			    :obcond_then ()
			    :obcond_else oblockpredef))
	      )
	  (setq istmtlis initlis)
	  (list_append ibodylis ocondpredef)
	  ))
    (multiple_every
     dlocbind
     (lambda (lbind :long bindrk)
       (assert_msg "compil_data_and_slots_fill check lbind" (is_a lbind class_normal_let_binding))
       (let ( (bder (unsafe_get_field :binder lbind))
	      (cty (unsafe_get_field :letbind_type lbind))
	      (nexp (unsafe_get_field :letbind_expr lbind))
	      (obva (get_free_objloctyped gcx bder cty))
	      (obnx (compile_obj nexp gcx)) 
	      )
	 (if obva (mapobject_put locmap lbind obva))
	 (let ( (obmy (if obva (put_objdest obnx obva) obnx)) )
	   ;; add the modified obmy in the ibodylis
	   (list_append istmtlis obmy)
	   )
	 (if obva (multiple_put_nth tupvar bindrk obva))
	 )))
    ;; for every non nil slot, append its initialization to istmtlis
    (multiple_every
     (unsafe_get_field :ninst_slots ndat)
     (lambda (sloval :long slork)
       (if sloval
;;; add to list inifill the filling in dai of slot#slork by slobj
	   (let ( (slobj (compile_obj sloval gcx)) 
		  )
	     (assert_msg "compil_data_and_slots_fill check slobj not nrep" (not (is_a slobj class_nrep)))
	     (let (
		   (ooff (make_integerbox discr_integer slork))
		   (oput 
		    (instance class_objputslot
			      :obi_loc  nloc
			      :oslot_odata obj
			      :oslot_offset ooff
			      :oslot_value slobj
			      )) 
		   )
	       (list_append istmtlis oput)
	       )))))
    ;; touch the object
    (list_append istmtlis 
		 (instance class_objtouch
			   :obi_loc (if nloc nloc (unsafe_get_field :nrep_loc ndat))
			   :otouch_comment comm
			   :otouch_val obj))
    ;; debugwrite the object		;
    (list_append istmtlis
    (instance class_objdbgtracewriteobj
    :obi_loc (if nloc nloc (unsafe_get_field :nrep_loc ndat))
    :obdtw_writtenobj obj
    :obdtw_message '"new static instance"))
    ;; for every non nil local obvar, clear it
    (multiple_every
     tupvar
     (lambda (obva :long ix)
       (if obva
	   (progn
	     (list_append ibodylis
			  (instance class_objclear 
				    :obi_loc nloc
				    :oclr_vloc obva))
	     ))))
;;; add the obj as the last instr of the block
    (list_append ibodylis obj)
    ;;
    (debug "compil_data_and_slots_fill final dlocbind=" dlocbind)
    ;; the caller is supposed to do
    ;; dispose_dlocbind_after_data_and_slots_fill with the result if
    ;; needed but in practice this is never needed
    (return dlocbind)
    )
  (return)				;force a nil return
  )


;; probably useless function
(defun dispose_dlocbind_after_data_and_slots_fill (dlocbind gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "dispose_dlocbind_after_data_and_slots_fill dlocbind=" dlocbind)
  (multiple_every
   dlocbind
   (lambda (bnd :long ix) (dispose_bnd_obj bnd gcx)))
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_datasymbol (syv gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check syv" (is_a syv class_nrep_datasymbol))
  (debug "compilobj_datasymbol syv=" syv)
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache syv))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datasymbol compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug "compilobj_datasymbol found chobj=" chobj)
	  (return chobj)))
    (let (
	  (odiscr  (compile_obj (unsafe_get_field :ndata_discrx syv) gcx))
	  (obsym 
	   ;;; symbols should be unique objects, to avoir recreating
	   ;;; them when they already exist.
	   (instance class_objinituniqueobject
		     :obv_type ctype_value
		     :oie_data syv
		     :oie_discr odiscr
		     :oio_class ()
		     )) 
	  )
      (mapobject_put compicache syv obsym)
      ;; make a cname
      (let ( (nambuf (make_strbuf discr_strbuf))
	     (:long syrk (get_int (unsafe_get_field :ndata_rank syv)))
	     )
	(add2sbuf_strconst nambuf "dsym_")
	(add2sbuf_longdec nambuf syrk)
	(add2sbuf_strconst nambuf "__")
	(add2sbuf_cident nambuf (unsafe_get_field :ndsy_namestr syv))
	(unsafe_put_fields obsym
			   :oie_cname (strbuf2string discr_string nambuf)))
      ;; put the length as obj_num of obsym
      (put_int obsym (multiple_length (unsafe_get_field :ninst_slots syv)))
      (let ( (dlocbind (compil_data_and_slots_fill syv obsym odiscr inirout gcx)) ) 
	(debug "compilobj_datasymbol dlocbind=" dlocbind)
	;;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	)
      (debug "compilobj_datasymbol final obsym=" obsym)
      (return obsym)
      )))
(install_method class_nrep_datasymbol compile_obj compilobj_datasymbol)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compilobj of datainstance
(defun compilobj_datainstance (dai gcx)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_datainstance dai=" dai)
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache dai))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datainstance compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug "compilobj_datainstance return found chobj=" chobj)
	  (return chobj)))
    (let ( (loc (unsafe_get_field :nrep_loc dai))
	   (nam (unsafe_get_field :ndata_name dai))
	   ;; nam is a symbol, not a string
	   (disx (unsafe_get_field :ndata_discrx dai))
	   (drank (unsafe_get_field :ndata_rank dai))
	   (dhash (unsafe_get_field :ninst_hash dai))
	   (dpredef (unsafe_get_field :ninst_predef dai))
	   (dslots (unsafe_get_field :ninst_slots dai)) 
	   (ininsl (unsafe_get_field :ninit_topl inirout))
	   (inifill (unsafe_get_field :oirout_fill inirout))
	   )
      ;; if the drank is invalid or nil, the data has never been added
      ;; with add_nctx_data (should not happen)
      (assert_msg "compilobj_datainstance check drank" (is_integerbox drank))
      (let ( (cdisx (compile_obj disx gcx)) 
	     )
	(let (
	      ;; make a cname
	      (oini (if dpredef ;; if predefined, make it unique!
			(instance class_objinituniqueobject
			      :obv_type ctype_value
			      :oie_data dai
			      :oie_discr cdisx
			      :oio_predef dpredef
			      :oio_class ()
			      )
		      ;; othewise, don't bother make it unique
			(instance class_objinitobject
			      :obv_type ctype_value
			      :oie_data dai
			      :oie_discr cdisx
			      :oio_predef dpredef
			      :oio_class ()
			      )
		      ))
	      (nambuf (make_strbuf discr_strbuf))
	      (:long drk (get_int drank))
	      )
	  (mapobject_put compicache dai oini)
	  (add2sbuf_strconst nambuf "dobj_")
	  (add2sbuf_longdec nambuf drk)
	  (if nam (progn
		    (add2sbuf_strconst nambuf "__")
		    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	  (let ( (cnam (strbuf2string discr_string nambuf)) )
	    (unsafe_put_fields oini :oie_cname cnam)
	    )
	  (put_int oini (multiple_length dslots))
	  (let ( (dlocbind (compil_data_and_slots_fill dai oini cdisx inirout gcx)) )
	    (debug "compil_data_and_slots_fill dlocbind=" dlocbind)
	    ;;(dispose_dlocbind_after_data_and_slots_fill dlocbind gcx)
	    )
	  (debug "compilobj_datainstance final oini=" oini)
	  oini
	  )  
	)
      )
    )
  )
(install_method class_nrep_datainstance compile_obj compilobj_datainstance)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data tuple
(defun compilobj_datatuple (nti gcx)
  (assert_msg "check nti" (is_a nti class_nrep_datatuple))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_datatuple nti=" nti)
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (chobj (mapobject_get compicache nti))
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 )
    ;; datatuples compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug "compilobj_datatuple found chobj=" chobj)
	  (return chobj)))
    (let ( (ncompi (unsafe_get_field :ntup_comp nti))
	   (ocompi (multiple_map 
		    ncompi
		    (lambda (c :long ix) (if c (compile_obj c gcx)))))
	   (disx (unsafe_get_field :ndata_discrx nti))
	   (drank (unsafe_get_field :ndata_rank nti))
	   (odiscr (compile_obj disx gcx)) 
	   (nam (unsafe_get_field :ndata_name nti))
	   (nambuf (make_strbuf discr_strbuf))
	   (locvar (get_free_objlocptr gcx '_valtup_))
	   (:long drk (get_int drank))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (comm (unsafe_get_field :named_name '_initup_))
	   )
      (add2sbuf_strconst nambuf "dtup_")
      (add2sbuf_longdec nambuf drk)
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (let ( (otup (instance class_objinitmultiple
			     :obv_type ctype_value
			     :oie_discr odiscr
			     :oie_locvar locvar
			     :oie_cname (strbuf2string discr_string nambuf)
			     :oim_tupval ocompi
			     ))
	     )
	(mapobject_put compicache nti otup)
	(put_int otup (multiple_length ncompi))
	(multiple_every
	 ncompi
	 (lambda (scomp :long srk)
	   (if scomp 
	       (let ( (ocomp (multiple_nth ocompi srk)) )
		 (list_append inibody
			      (instance class_objputuple
					:oputu_tupled otup
					:oputu_offset (make_integerbox discr_integer srk)
					:oputu_value ocomp)))
	     )))
	(list_append inibody
		     (instance class_objtouch
			       :otouch_val otup
			       :otouch_comment comm))
	(debug "compilobj datatuple otup=" otup)
	(return otup)
	)
      )
    )
  )

(install_method class_nrep_datatuple compile_obj compilobj_datatuple)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data string
(defun compilobj_datastring (nds gcx)
  (assert_msg "check nds" (is_a nds class_nrep_datastring))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache nds))
	 )
    ;; datastring compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (return chobj)))
    (let (
	  (nambuf (make_strbuf discr_strbuf))
	  (ndisx (unsafe_get_field :ndata_discrx nds))
	  (odiscr (compile_obj ndisx gcx))
	  (odata (unsafe_get_field :nstr_string nds))
	  (drank (unsafe_get_field :ndata_rank nds))
	  (nam (unsafe_get_field :ndata_name nds))
	  (locvar (get_free_objlocptr gcx '_valstr_))
	  (:long drk (get_int drank))
	  (ostr (instance class_objinitstring
			  :obv_type ctype_value
			  :oie_data odata
			  :oie_discr odiscr
			  :oie_locvar locvar
			  )) 
	  )
      (mapobject_put compicache nds ostr)
      (add2sbuf_strconst nambuf "dstr_")
      (add2sbuf_longdec nambuf drk)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cidentprefix nambuf odata 16)
      (put_int ostr (string_length odata))
      (if nam 
	  (progn
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (unsafe_put_fields ostr :oie_cname (strbuf2string discr_string nambuf))
      ostr
      )
    ))
(install_method class_nrep_datastring compile_obj compilobj_datastring)

;;;;;;;;;;;;;;;; compile a data boxed integer
(defun compilobj_databoxedinteger (ndi gcx)
  (assert_msg "check ndi" (is_a ndi class_nrep_databoxedinteger))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache ndi))
	 )
    ;; datastring compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (return chobj)))
    (let (
	  (nambuf (make_strbuf discr_strbuf))
	  (ndisx (unsafe_get_field :ndata_discrx ndi))
	  (odiscr (compile_obj ndisx gcx))
	  (odata (unsafe_get_field :nboxint_num ndi))
	  (drank (unsafe_get_field :ndata_rank ndi))
	  (nam (unsafe_get_field :ndata_name ndi))
	  (locvar (get_free_objlocptr gcx '_valbxint_))
	  (:long drk (get_int drank))
	  (oint (instance class_objinitboxinteger
			  :obv_type ctype_value
			  :oie_data odata
			  :oie_discr odiscr
			  :oie_locvar locvar
			  )) 
	  )
      (mapobject_put compicache ndi oint)
      (add2sbuf_strconst nambuf "dint_")
      (add2sbuf_longdec nambuf drk)
      (add2sbuf_strconst nambuf "__")
      (add2sbuf_cidentprefix nambuf odata 16)
      (if nam 
	  (progn
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (unsafe_put_fields oint :oie_cname (strbuf2string discr_string nambuf))
      oint
      )
    ))
(install_method class_nrep_databoxedinteger compile_obj compilobj_databoxedinteger)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data closure
(defun compilobj_dataclosure (ncl gcx)
  (assert_msg "check ncl" (is_a ncl class_nrep_dataclosure))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_dataclosure ncl=" ncl)
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (inibody (unsafe_get_field :obrout_body inirout))
	 (chobj (mapobject_get compicache ncl))
	 )
    (assert_msg  "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (debug  "compilobj_dataclosure found chobj=" chobj)
	  (return chobj)))
    (let ( 
	  (nam (unsafe_get_field :ndata_name ncl))
	  (discx (unsafe_get_field :ndata_discrx ncl))
	  (nrank (unsafe_get_field :ndata_rank ncl))
	  (nloc (unsafe_get_field :nrep_loc ncl))
	  (npro (unsafe_get_field :ndclo_proc ncl))
	  (nclov (unsafe_get_field :ndclo_closv ncl))
	  (:long nbclos (multiple_length nclov))
	  (nambuf (make_strbuf discr_strbuf))
	  (odiscr (compile_obj discx gcx))
	  (locvar (get_free_objlocptr gcx '_valclo_))
	  (comm (unsafe_get_field :named_name '_dataclosure_))
	  )
      (assert_msg "check npro" (is_a npro class_nrep_routproc))
      (add2sbuf_strconst nambuf "dclo_")
      (add2sbuf_longdec nambuf (get_int nrank))
      (if nam (progn
		(add2sbuf_strconst nambuf "__")
		(add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
      (let (
	    (ndatarou (unsafe_get_field :nrpro_datarout npro))
	    (oiclo
	     (instance class_objinitclosure
		       :obv_type ctype_value
		       :oie_discr odiscr
		       :oie_data ncl
		       :oie_locvar locvar
		       :oie_cname (strbuf2string discr_string nambuf)
		       )) 
	    )
	(put_int oiclo nbclos)
	(mapobject_put compicache ncl oiclo)
	(assert_msg "check ndatarou" (is_a ndatarou class_nrep_dataroutine))
	(let (
	      ;; npro should already have been compiled, so should be in the compiler cache
	      (ocrout (mapobject_get compicache npro))
	      (odatrout (compile_obj ndatarou gcx))
	      (ocputrout (instance  class_objputclosurout
				    :obi_loc nloc
				    :opclor_clos oiclo
				    :opclor_rout odatrout
				    ;;@@OLDBUGGY :opclor_rout (mapobject_get compicache ndatarou)
				    ))
	      (bxoff (make_integerbox discr_integer 0))
	      )
	  (assert_msg "check ocrout" (is_a ocrout class_procroutineobj))
	  (list_append inibody ocputrout)
	  (multiple_every
	   nclov
	   (lambda (clov :long ix)
	     (let ( (cloval (compile_obj clov gcx)) 
		    (ocputclos (instance class_objputclosedv
					 :obi_loc nloc
					 :opclov_clos oiclo
					 :opclov_off (make_integerbox discr_integer (get_int bxoff))
					 :opclov_cval cloval))
		    )
	       (list_append inibody ocputclos)
	       )
	     (put_int bxoff (+i (get_int bxoff) 1))))
	  (list_append inibody (instance class_objtouch
					 :obi_loc nloc
					 :otouch_comment comm
					 :otouch_val oiclo))
	  oiclo
	  ))
      ))
  )
(install_method class_nrep_dataclosure compile_obj compilobj_dataclosure)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; compile a data routine
(defun compilobj_dataroutine (ndrou gcx)
  (assert_msg "check ndrou" (is_a ndrou class_nrep_dataroutine))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (compicache (unsafe_get_field :gncx_compicache gcx)) 
	 (inirout (unsafe_get_field :gncx_objrout gcx))
	 (chobj (mapobject_get compicache ndrou))
	 (unused_stuff ())	  ;to circumvent a bug in cold-melt
	 )
    ;; dataroutine compiled only in initial routines
    (assert_msg "check inirout" (is_a inirout class_initialroutineobj))
    (if chobj
	(progn
	  (return chobj)))
    (let ( (nam (unsafe_get_field :ndata_name ndrou))
	   (disx (unsafe_get_field :ndata_discrx ndrou))
	   (nloc (unsafe_get_field :nrep_loc ndrou))
	   (drank (unsafe_get_field :ndata_rank ndrou))
	   (nam (unsafe_get_field :ndata_name ndrou))
	   (npro (unsafe_get_field :ndrou_proc ndrou))
	   (inibody (unsafe_get_field :obrout_body inirout))
	   (locvar (get_free_objlocptr gcx '_valrout_))
	   )
      (if (null nloc)
	  (if (is_a npro class_nrep)
	      (setq nloc (unsafe_get_field :nrep_loc npro))))
      (assert_msg "check compicache" (is_mapobject compicache))
      (let (
	    (nambuf (make_strbuf discr_strbuf))
	    (:long drk (get_int drank))
	    (odiscr (compile_obj disx gcx))
	    )
	(add2sbuf_strconst nambuf "drout_")
	(add2sbuf_longdec nambuf drk)
	(if nam (progn
		  (add2sbuf_strconst nambuf "__")
		  (add2sbuf_cident nambuf (unsafe_get_field :named_name nam))))
	(let (
	      (oirout 
	       (instance class_objinitroutine
			 :obv_type ctype_value
			 :oie_discr odiscr
			 :oie_data ndrou
			 :oie_locvar locvar
			 :oie_cname (strbuf2string discr_string nambuf)
			 :oir_procroutine (mapobject_get compicache npro)
			 )) 
	      )
	  (mapobject_put compicache ndrou oirout)
	  (if (is_a npro class_nrep_routproc)
	      (let ( (pconstl (unsafe_get_field :nrpro_const npro)) 
		     (:long nbconst (list_length pconstl))
		     (bxoff (make_integerbox discr_integer 0))
		     (comm (unsafe_get_field :named_name '_iroutval_))
		     )
		(put_int oirout nbconst)
		(list_every
		 pconstl
		 (lambda (constx)
		   (cond
		    ( (is_a constx class_nrep_constocc)
		      (let ( (cnstbind (unsafe_get_field :nocc_bind constx)) )
			(assert_msg "compilobj_dataroutine check cnstbind" (is_a cnstbind class_any_binding))
			(let ( 
			      (oconstx (compile_obj cnstbind gcx)) 
			      (:long off (get_int bxoff))
			      ) 
			  (if oconstx 
			      (let (
				    (iput
				     (if (is_a cnstbind class_fixed_binding)
					 (instance class_objputroutconstnotnull
						   :obi_loc nloc
						   :oprconst_rout oirout
						   :oprconst_off (make_integerbox discr_integer off)
						   :oprconst_cval oconstx)
				       (instance class_objputroutconst
						 :obi_loc nloc
						 :oprconst_rout oirout
						 :oprconst_off (make_integerbox discr_integer off)
						 :oprconst_cval oconstx)
				       )) 
				    ) 
				(list_append inibody iput)
				(put_int bxoff (+i off 1))))))
		      )
		    ( (is_a constx class_nrep_quasidata)
		      (let ( 
			    (oconstx (compile_obj constx gcx)) 
			    (:long off (get_int bxoff))
			    ) 
			(if oconstx 
			    (let ( (iput (instance class_objputroutconst
						   :obi_loc nloc
						   :oprconst_rout oirout
						   :oprconst_off (make_integerbox discr_integer off)
						   :oprconst_cval oconstx)) ) 
			      (list_append inibody iput)
			      (put_int bxoff (+i off 1))))))
		    (:else
		     (assert_msg "compilobj_dataroutine unexepected constx" ())
		     )
		    )
		   )
		 )
		(if (>i (get_int bxoff) 0)
		    (list_append inibody (instance class_objtouch
						   :obi_loc nloc
						   :otouch_val oirout
						   :otouch_comment comm
						   )))
		(debug "compilobj_dataroutine final oirout=" oirout)
		oirout)
	    ))))
    )
  )
(install_method class_nrep_dataroutine compile_obj compilobj_dataroutine)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_quasidata_current_module_environment_container (qdcm gcx)
  (assert_msg "check qdcm" (is_a qdcm class_nrep_quasidata_current_module_environment_container))
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (let ( (locbox (get_field :igncx_contenvloc gcx)) 
	 )
    (return locbox)))
(install_method class_nrep_quasidata_current_module_environment_container compile_obj compilobj_quasidata_current_module_environment_container)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_quasidata_parent_module_environment (qdpm gcx)
  (assert_msg "check qdpm" (is_a qdpm class_nrep_quasidata_parent_module_environment))
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (let ( (prevenvloc (get_field :igncx_prevenvloc gcx)) 
	 )
    (return prevenvloc)))
(install_method class_nrep_quasidata_parent_module_environment compile_obj compilobj_quasidata_parent_module_environment)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilobj_nrep_store_predefined (nspr gcx)
  (assert_msg "check nspr" (is_a nspr class_nrep_store_predefined))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_store_predefined start nspr=" nspr)
  (let ( (nloc (unsafe_get_field :nrep_loc nspr))
	 (npred (unsafe_get_field :nstpd_predef nspr))
	 (nval (unsafe_get_field :nstpd_value nspr))
	 (oval (compile_obj nval gcx)) 
	 (res ())
	 )
    (cond 
     ( (is_a npred class_symbol)
       (let ( (namepred (make_string discr_verbatim_string (get_field :named_name npred))) )
	 (setq res 
	       (make_objcompute 
		nloc
		ctype_void
		##{MELT_STORE_PREDEF($NAMEPRED, (melt_ptr_t) ($OVAL))}#)))
       )
     ( (is_integerbox npred)
       (setq res 
	     (make_objcompute
	      nloc
	      ctype_void
	      ##{melt_store_predefined($NPRED, (melt_ptr_t) ($OVAL))}#))
       )
     (:else
      (debug "compilobj_nrep_store_predefined bad npred=" npred)
      (assert_msg "compilobj_nrep_store_predefined invalid npred" ())
      (return))
     )
    (debug "compilobj_nrep_store_predefined result res=" res)
    res
    ))
(install_method class_nrep_store_predefined compile_obj compilobj_nrep_store_predefined)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun compilobj_nrep_update_current_module_environment_container (nucmeb gcx)
  (assert_msg "check nucmeb" (is_a nucmeb class_nrep_update_current_module_environment_container))
  (assert_msg "check gcx" (is_a gcx class_initial_generation_context))
  (debug "compilobj_nrep_update_current_module_environment_container nucmeb=" nucmeb)
  (let ( (nloc (unsafe_get_field :nrep_loc nucmeb))
	 (ncomm (unsafe_get_field :ncumeb_comment nucmeb))
	 (nex (unsafe_get_field :nucmeb_expr nucmeb))
	 (pcml (unsafe_get_field :igncx_procurmodenvlist gcx))
	 (ocontenvloc (get_field :igncx_contenvloc gcx))
	 (csbuf (let ( (sb (make_strbuf discr_strbuf)) 
		       )
		  (add2sbuf_strconst sb "upd.cur.mod.env.cont")
		  (if (is_string ncomm)
		      (progn
			(add2sbuf_strconst sb " : ")
			(add2sbuf_string sb ncomm)))
		  sb
		  ))
	 (obodl (make_list discr_list))
	 (ocblo (instance class_objcommentedblock
			  :obi_loc nloc
			  :oblo_bodyl obodl
			  :ocomblo_comment 
			  (strbuf2string discr_string csbuf)))
	 (oex (compile_obj nex gcx))
	 )
    ;; get the igncx_procurmodenvlist from gcx
    ;; for each routine of class_procroutineobj  get its nrpro_const list and
    ;; for each CLASS_NREP_QUASIDATA_CURRENT_MODULE_ENVIRONMENT_CONTAINER there do ....
    (list_every 
     pcml
     (lambda (curout)
       (if (is_a curout class_procroutineobj)
	   (let (
		 (curproc (unsafe_get_field :obrout_proc curout))
		 (cnslis (unsafe_get_field :nrpro_const curproc)) 
		 (datarout (unsafe_get_field :nrpro_datarout curproc))
		 (odatarout (compile_obj datarout gcx))
		 (boxcount (make_integerbox discr_integer 0))
		 (oroutlocvar (unsafe_get_field :oie_locvar odatarout))
		 )
	     (assert_msg "check odatarout" (is_a odatarout class_objinitroutine))
	     (list_every 
	      cnslis
	      (lambda (curconst)
		(let (
		      (:long curcount (get_int boxcount))
		      )
		  (if (is_a curconst class_nrep_quasidata_current_module_environment_container)
		      ;; set into oroutlocvar  the constant ranked curcount to oex
		      ;; and touch it
		      (let (
			    (oputrout (instance class_objputroutconst
						:obi_loc nloc
						:oprconst_rout oroutlocvar
						:oprconst_off  (make_integerbox discr_integer curcount)
						:oprconst_cval oex
						))
			    (otouchrout (instance class_objtouch
						  :obi_loc nloc
						  :otouch_val oroutlocvar
						  :otouch_comment '"compobj.upd.mod.env.box"
						  ))
			    (ocopy (instance class_objcompute
					     :obi_loc nloc
					     :obdi_destlist (list ocontenvloc)
					     :obcpt_expr oex
					     :obcpt_type ctype_value
					     ))
			    )
			(list_append obodl oputrout)
			(list_append obodl otouchrout)
			(list_append obodl ocopy)
			)
		    )
		  )
		))
	     (put_int boxcount (+i (get_int boxcount) 1))
	     ))))
    (debug "compobj.upd.mod.env.box result ocblo=" ocblo)
    (return ocblo)
    ))
(install_method class_nrep_update_current_module_environment_container compile_obj compilobj_nrep_update_current_module_environment_container)






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; selector to compile a matcher
;; receiver: some indirect instance of class_any_matcher
;; arguments:
;;; * the match compilation context
;;; * the generation context
;;;   
(defselector compile_matcher class_selector
)

(export_values compile_matcher)
(defclass class_matchcompilcontext 
  :super class_proped
  :fields (mcx_loc			;the location of the matcher
	   mcx_normtester		;the normtester
	   mcx_gotothen			;the goto then part
	   mcx_gotoelse 		;the goto else part
	   mcx_olist			;the objcode list to be filled
	   mcx_suffix			;the suffix for state expansion
	   mcx_statecounter		;boxed counter for state expansion
	   ))
(export_class class_matchcompilcontext)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; selector to compile a tester
;;;; receiver: the tester
;;;; first argument: the generator context gcx
;;;; second argument: the tester context tcx
;;;; return values: primary, the objcode or lists; secondary the destination objcode
(defselector compile_tester class_selector
  :doc #{Compile a tester $RECV for matching with generator context
  $GCX and tester context $TCX. Return the compiled tester and
  secondarily the destination.}#
  :formals (recv gcx tcx)
 )
(export_values compile_tester)
(defclass class_testercompilcontext
  :super class_proped
  :fields (tcx_nrmatch			;the nrep_matcher
	   tcx_freelist			;the list of free objloc
	   tcx_nextest			;the next test
))
(export_class class_testercompilcontext)


;;;; catch all
(defun compiltst_anytester (ntester gcx tcx)
  (assert_msg "check ntester" (is_a ntester class_normtester_any))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (debug ntester "compiltst_anytester ntester=" ntester)
  (outcstring_err "* compiltst unimplemented receiver class ")
  (let ( (discr (discrim ntester)) ) (outstr_err (unsafe_get_field :named_name discr)))
  (outnewline_err)
  (assert_msg "@@compile_tester should be implemented in normtesters-s subclasses" ())
)
(install_method class_normtester_any compile_tester compiltst_anytester)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; compilation of old matches
(defun compilobj_nrep_match (nmat gcx)
  (assert_msg "check nmat" (is_a nmat class_nrep_match))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug  "compilobj_nrep_match nmat=" nmat)
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nmat))
	(nctyp (unsafe_get_field :nexpr_ctyp nmat))
	(ntests (unsafe_get_field :nmatch_tests nmat))
	(stuffmap (unsafe_get_field :nmatch_stuffmap nmat))
	(nmatched (get_field :nmatch_matched nmat))
	(matmap (unsafe_get_field :gncx_matchmap gcx))
	(matlabel (let ( (:long nbmat (mapobject_count matmap))
			 (labuf (make_strbuf discr_strbuf))
			 )
		    (add2sbuf_strconst labuf "mtch")
		    (add2sbuf_longdec labuf (+i nbmat 1))
		    (add2sbuf_strconst labuf "_")
		    (let ( (labstr (strbuf2string discr_verbatim_string labuf)) )
		      (mapobject_put matmap  nmat labstr)
		      (debug "compilobj_nrep_match matlabel labstr=" labstr)
		      labstr
		      )))
	(endlabel (let (
			(labuf (make_strbuf discr_strbuf))
			)
		    (add2sbuf_string labuf matlabel)
		    (add2sbuf_strconst labuf "_end")
		    (strbuf2string discr_verbatim_string labuf)))
	;; the list of suborders for putobjdest dispatch...
	;; should be the *last* of each sequence added...
	(subcomplist (make_list discr_list))
	(obodyl (make_list discr_list))
	(ombloc (instance class_objmultiblock
			  :obi_loc nloc
			  :oblo_bodyl obodyl
			  :omulblo_subcomp ()
			  ))
	(ofirstgoto (instance class_objgotoinstr
			      :obi_loc nloc
			      :obgoto_prefix matlabel
			      :obgoto_rank (make_integerbox discr_integer 0)
			      ))
	(oendlabel (instance class_objlabelinstr
			     :obi_loc nloc
			     :oblab_prefix endlabel
			     :oblab_rank ()))
	(tcx (instance class_testercompilcontext
		       :tcx_nrmatch nmat
		       :tcx_freelist (make_list discr_list)
		       :tcx_nextest ()	;updated below
		       ))
	(donetests (make_list discr_list))
	(omatched 
	 (progn 
	   (debug "compilobj_nrep_match nmatched=" nmatched)
	   (compile_obj nmatched gcx)))
	)
    (list_append obodyl ofirstgoto)
    (debug "compilobj_nrep_match ntests=" ntests " omatched=" omatched " oendlabel=" oendlabel)
    (foreach_in_multiple
     (ntests)
     (curotest :long testix)
     (debug "compilobj_nrep_match curotest=" curotest " testix=" testix)
     (assert_msg "check curotest" (is_a curotest class_normtester_any))
     (assert_msg "check curotest rank" (==i (get_int curotest) testix))
     ;; do we have both then & else?
     (compile_warning 
      ;; we probably don't need to test the curnthen & curntest; they
      ;; probably are set...
      "probably useless tests - the then & else parts are here!" ())
     (if (is_a curotest class_normtester_anytester)
	 (let ( (curnthen (get_field :ntest_then curotest))
		(curnelse (get_field :ntest_else curotest))
		)
	   (cond 
	    ( (null curnthen)
	      (debug "compilobj_nrep_match  with null then curotest=" curotest)
	      (shortbacktrace_dbg "compilobj_nrep_match curotest has null then" 14)
	      )
	    ( (null curnelse)
	      (debug "compilobj_nrep_match with null else curotest=" curotest)
	      (shortbacktrace_dbg "compilobj_nrep_match curotest has null else" 14)
	      )
	   )))
     (let (
	   (labins (normtester_labelinstr curotest gcx))
	   (curnmatched (get_field :ntest_matched curotest))
	   )
       (debug "compilobj_nrep_match labins=" labins)
       (let ( (nextest (multiple_nth ntests (+i testix 1))) )
	 (put_fields tcx :tcx_nextest nextest)
	 (debug "compilobj_nrep_match nextest=" nextest " tcx=" tcx))
       (multicall
	(curcomp curobdest) 
	(compile_tester curotest gcx tcx)
	(debug "compilobj_nrep_match curcomp=" curcomp "curobdest=" curobdest)
	(assert_msg "check curcomp" curcomp)
	;; always add the labins and the curcomp or its element into obodyl
	(list_append obodyl labins)
	(cond 
	 ( (is_list curcomp)
	   (let ( (lastlicomp (pair_head (list_last curcomp))) )
	     (debug "compilobj_nrep_match lastlicomp=" lastlicomp)
	     (list_append2list obodyl curcomp)
	     ))
	 ( (is_multiple curcomp)
	   (let ( (lastupcomp (multiple_nth curcomp -1)) )
	     (debug "compilobj_nrep_match lastupcomp=" lastupcomp)
	     (foreach_in_multiple
	      (curcomp)
	      (subtest :long subix)
	      (list_append obodyl subtest))
	     ))
	 ( (is_object curcomp)
	   (debug "compilobj_nrep_match obj curcomp=" curcomp)
	   (list_append obodyl curcomp)
	   )
	 (:else
	  (assert_msg "unexpected curcomp" ())
	  ))
	;; add into subcomplist the curobdest if not null
	(if curobdest (list_append subcomplist curobdest))
	;; 
	(list_append donetests curotest)
	;; dispose some stuff
	(let ( (disposablist (make_list discr_list)) )
	  (debug "compilobj_nrep_match disposing curotest=" curotest)
	  (cond
	   ;; if the current test is a success, we can dispose all the
	   ;; stuff which has already been tested
	   ( (is_a curotest class_normtester_success)
	     (mapobject_every 
	      stuffmap
	      (lambda (stuff stutests)
		(if (!= stuff omatched)
		(let ( (remstuff stuff) )
		  (foreach_in_list 
		   (stutests)
		   (testpair curtest)
		   (if (list_find donetests curtest)
		       (setq testpair ())
		     (setq remstuff ()))
		   )
		  (if remstuff 
		      (list_append disposablist remstuff))
		)))))
	   ;; if the curnmatched is the nmatched, we do nothing
	   ;; because we cannot dispose it
	   ( (== curnmatched nmatched)
	     (debug "compilobj_nrep_match curnmatched == nmatched=" nmatched)
	     )
	   ;; if the current test is not a success and the curnmatched
	   ;; is an object, we can dispose it if all its stuff has been
	   ;; tested
	   ( (is_object curnmatched)
	     (debug curnmatched
		    "compilobj_nrep_match disposing curnmatched=" curnmatched " omatched=" omatched)
	     (let ( (stutests (mapobject_get stuffmap curnmatched)) )
	       (let ( (remstuff curnmatched) )
		 (foreach_in_list 
		  (stutests)
		  (testpair curtest)
		  (if (list_find donetests curtest)
		      (setq testpair ())
		    (setq remstuff ()))
		  )
		 (if remstuff 
		     (list_append disposablist remstuff))
		 )))) 
;;; dispose all the stuff in the disposablist 
	  (debug "compilobj_nrep_match disposablist=" disposablist)
	  (foreach_in_list
	   (disposablist)
	   (dispair dispstuff)
	   (mapobject_remove stuffmap dispstuff)
	   (debug "compilobj_nrep_match dispstuff=" dispstuff)
	   (let ( (dispobj (compile_obj dispstuff gcx)) )
	     (debug "compilobj_nrep_match dispobj=" dispobj)
	     (assert_msg "check dispobj" (is_a dispobj class_objlocv))
	     ;; but never dispose omatched itself
	     (if (!= dispobj omatched)
		 (dispose_objloc dispobj gcx)
	       (debug  "compilobj_nrep_match dont dispose omatched=" omatched))
	     ))))))
    (list_append obodyl oendlabel)
    (put_fields ombloc 
		:omulblo_subcomp (list_to_multiple subcomplist discr_multiple))
    (debug "compilobj_nrep_match return ombloc=" ombloc)
    (return ombloc ())
    ))
(install_method class_nrep_match compile_obj compilobj_nrep_match)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;






(defclass class_alternate_match_nrep_data 
  :super class_root
  :fields (altmatchn_prev		;the previous
	   altmatchn_nrep		;the current nrep_altmatch
	   altmatchn_flagmap		;mapping from match flags to objflags
	   altmatchn_datamap		;mapping from nrep matched data to objvalues
	   )
  )
(export_class class_alternate_match_nrep_data)

;;;; compilation of alternate matches
(defun compilobj_nrep_altmatch (nmat gcx)
  (assert_msg "check nmat" (is_a nmat class_nrep_altmatch))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_altmatch nmat=" nmat "\n** gcx=" gcx 
	 "\n** class_objmatchflagblock=" class_objmatchflagblock "\n")
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nmat))
	(nctyp (unsafe_get_field :nexpr_ctyp nmat))
	(nmatched (unsafe_get_field :namatch_matched nmat))
	(nres (unsafe_get_field :namatch_result nmat))
	(nbody (unsafe_get_field :namatch_body nmat))
	(nflags (unsafe_get_field :namatch_flags nmat))
	(nmdatas (unsafe_get_field :namatch_mdatas nmat))
	(obodyl (make_list discr_list))
	(oldaltmatch (get_field :gncx_altmatch gcx))
	(oflagmap (make_mapobject discr_map_objects 
				  (+i 5 (*i 2 (multiple_length nflags)))))
	(odatamap (make_mapobject discr_map_objects
				  (+i 7 (*i 2 (multiple_length nmdatas)))))
	(altmatch (instance class_alternate_match_nrep_data 
			    :altmatchn_prev oldaltmatch
			    :altmatchn_nrep nmat
			    :altmatchn_flagmap oflagmap
			    :altmatchn_datamap odatamap
			    )))
							      
    (debug "compilobj_nrep_altmatch nmatched=" nmatched " nres=" nres 
	   " nflags=" nflags " nctyp=" nctyp
	   " nbody=" nbody " oldaltmatch=" oldaltmatch)
    (put_fields gcx :gncx_altmatch altmatch)
    (let (
	  (nsymbres (get_field :nocc_symb nres))
	  (obvares (get_free_objloctyped gcx nsymbres nctyp))
	  (ocleares (instance class_objclear
			      :obi_loc nloc
			      :oclr_vloc obvares))
	  )
      (list_append obodyl ocleares)
      ;;
      (debug "compilobj_nrep_altmatch nflags=" nflags)
      (let ( (oflags 
	      (multiple_map
	       nflags
	       (lambda (curnflag :long fix)
		 (debug "compilobj_nrep_altmatch/lambda curnflag=" curnflag " fix=" fix)
		 (let ( (curoflag (compile_obj curnflag gcx))
			)
		   (debug "compilobj_nrep_altmatch/lambda curoflag=" curoflag)
		   (return curoflag))))
	      )
	     )
	(debug "compilobj_nrep_altmatch oflags=" oflags)
	;;
	(debug "compilobj_nrep_altmatch nbody=" nbody)
	(foreach_in_multiple
	 (nbody)
	 (curncomp :long bodix)
	 (debug  "compilobj_nrep_altmatch curncomp=" curncomp " bodix=" bodix)
	 (let ( (curocomp (compile_obj curncomp gcx))
		)
	   (debug "compilobj_nrep_altmatch curocomp=" curocomp)
	   (assert_msg "check curocomp object" (is_object curocomp))
	   (list_append obodyl curocomp)
	   ))
	(debug "compilobj_nrep_altmatch obodyl=" obodyl)
	(dispose_objloc obvares gcx)
	(put_fields gcx :gncx_altmatch oldaltmatch)
	(assert_msg "@@unimplemented compilobj_nrep_altmatch")
	))))
(install_method class_nrep_altmatch compile_obj compilobj_nrep_altmatch)


;;;;;;;;;;;;;;;;
(defun compilobj_nrep_matchlabel (nmlab gcx)
  (assert_msg "check nmlab" (is_a nmlab class_nrep_match_label))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "compilobj_nrep_matchlabel nmlab=" nmlab " gcx=" gcx)
  (let (
	(nloc (get_field :nrep_loc nmlab))
	(nstep (get_field :nmlab_step nmlab))
	(stepixv (get_field :mstep_index nstep))
	)
    (debug "compilobj_nrep_matchlabel stepixv=" stepixv " nstep=" nstep)
    (shortbacktrace_dbg "compilobj_nrep_matchlabel" 12)
(let ( (objm (make_objcompute nloc ctype_void ##{??compilobj_nrep_matchlabel
#error incomplete compilobj_nrep_matchlabel
/*nstep=*/ $NSTEP
/*stepixv=*/ $STEPIXV
}#))
       )
  (error_plain nloc "not fully implemented compilobj_nrep_matchlabel")
  (debug "compilobj_nrep_matchlabel objm=" objm)
  (return objm)
    )))

(install_method class_nrep_match_label compile_obj compilobj_nrep_matchlabel)


;;;;;;;;;;;;;;;;
;; the compilation of a match flag should give a 
(defun compilobj_nrep_matchflag (nmflag gcx)
  (debug "compilobj_nrep_matchflag nmflag=" nmflag "\n of discrim=" (discrim nmflag)
	 "\n** gcx=" gcx)
  (assert_msg "check nmflag" (is_a nmflag class_nrep_match_flag))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let ( (nloc (unsafe_get_field :nrep_loc nmflag))
	 (nrfla (unsafe_get_field :nrpfla_flag nmflag))
	 (nrmatch (unsafe_get_field :nrpfla_nmatch nmflag))
	 (altmatchdata (get_field :gncx_altmatch gcx))
	 (oflagmap (get_field :altmatchn_flagmap altmatchdata))
	 )
    (debug "compilobj_nrep_matchflag nrfla=" nrfla " nrmatch=" nrmatch " oflagmap=" oflagmap)
    (assert_msg "check oflagmap" (is_mapobject oflagmap))
    (let ( (objmf (mapobject_get oflagmap nmflag))
	   )
      (if objmf
	  (progn
	    (debug "compilobj_nrep_matchflag found & returning objmf=" objmf)
	    (assert_msg "check ojbmf" (is_a objmf class_objflag))
	    (return objmf)))
      (setq objmf (instance class_objflag
			    :obv_type ctype_long
			    :obflag_matchflag nmflag
			    :obflag_name (get_field :mflag_string nrfla)
			    :obflag_rank (get_field :mflag_rank nrfla)))
      (mapobject_put oflagmap nmflag objmf)
      (debug "compilobj_nrep_matchflag new objmf=" objmf " in updated oflagmap=" oflagmap)
      (return objmf)
      )))

(install_method class_nrep_match_flag compile_obj compilobj_nrep_matchflag)

;;;;;;;;;;;;;;;;
(defun compilobj_nrep_matchdatainit (nmdat gcx)
  (debug "compilobj_nrep_matchdatainit nmdat=" nmdat 
	 "\n of discr=" (discrim nmdat) "\n gcx=" gcx)
  (assert_msg "check nmdat" (is_a nmdat class_nrep_match_data_initializer))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let (
	(nloc (unsafe_get_field :nrep_loc nmdat))
	(ndata (get_field :nmdac_data nmdat))
	(ndatatype (get_field :nrmatd_ctype ndata))
	(ndatarank (get_field :nrmatd_rank ndata))
	(matdata (get_field :nrmatd_mdata ndata))
	(altmatch (get_field :gncx_altmatch gcx))
	(symb (or (get_field :mdata_symb matdata) (clone_symbol 'matchdata)))
	)
    (shortbacktrace_dbg "compilobj_nrep_matchdatainit" 10)
    (debug "compilobj_nrep_matchdatainit ndata=" ndata "\n* ndatatype=" ndatatype
	   "\n* ndatarank=" ndatarank 
	   "\n* matdata=" matdata "\n* altmatch=" altmatch
	   "\n* symb=" symb)
    (let (
	  (obvloc (get_free_objloctyped gcx symb ndatatype))
	  (aldatamap (get_field :altmatchn_datamap altmatch))
	  (obcl (instance class_objclear
			  :obi_loc nloc
			  :oclr_vloc obvloc))
	  )
      (debug "compilobj_nrep_matchdatainit obvloc=" obvloc
	     "\n* obcl=" obcl
	     "\n* aldatamap=" aldatamap)
      (assert_msg "unknown ndata in aldatamap" (null (mapobject_get aldatamap ndata)))
      (mapobject_put aldatamap ndata obvloc)
      (debug "compilobj_nrep_matchdatainit updated aldatamap=" aldatamap 
	     "\n*return obcl=" obcl)
      (return obcl)
      )))

(install_method class_nrep_match_data_initializer compile_obj compilobj_nrep_matchdatainit)



;;;;;;;;;;;;;;;;
(defun compilobj_nrep_matchedata (nmdat gcx)
  (debug "compilobj_nrep_matchedata nmdat=" nmdat 
	 "\n of discr=" (discrim nmdat) "\n gcx=" gcx)
  (assert_msg "check nmdat" (is_a nmdat class_nrep_matched_data))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let (
	(nloc (unsafe_get_field :nrep_loc nmdat))
	(nctype (unsafe_get_field :nrmatd_ctype nmdat))
	(nrmdata (get_field :nrmatd_mdata nmdat))
	(nrmrank (get_field :nrmatd_rank nmdat))
	(altmatch (get_field :gncx_altmatch gcx))
	(aldatamap (get_field :altmatchn_datamap altmatch))
	(obmdat (mapobject_get aldatamap nmdat))
	)
    (shortbacktrace_dbg "compilobj_nrep_matchdatainit" 10)
    (debug "compilobj_nrep_matchedata  altmatch=" altmatch "\n aldatamap=" aldatamap 
	   "\n obmdat=" obmdat "\n.. of discrim=" (discrim obmdat))
    (assert_msg "check obmdat" (is_a obmdat class_objvalue))
    (return obmdat)
    ))

(install_method class_nrep_matched_data compile_obj compilobj_nrep_matchedata)



;;;;;;;;;;;;;;;;
(defun compilobj_nrep_matchjump (nmjump gcx)
  (debug "compilobj_nrep_matchedata nmjump=" nmjump 
	 "\n of discr=" (discrim nmjump) "\n gcx=" gcx)
  (assert_msg "check nmjump" (is_a nmjump class_nrep_match_jump))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let (
	(nloc (unsafe_get_field :nrep_loc nmjump))
	(altmatch (get_field :gncx_altmatch gcx))
	)
    (debug "compilobj_nrep_matchjump  altmatch=" altmatch)
    (let ( (objc (make_objcompute nloc ctype_void ##{??compilobj_nrep_matchjump
#error incomplete compilobj_nrep_matchjump 
}#))
	   )
      (error_plain nloc "not fully implemented compilobj_nrep_matchjump")
      (debug "compilobj_nrep_matchjump objc=" objc)
      (return objc)
    )))

(install_method class_nrep_match_jump compile_obj compilobj_nrep_matchjump)







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility function to return the label instr of a tester
(defun normtester_labelinstr (nt gcx)
  (debug "normtester_labelinstr start nt=" nt)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (if (is_not_a nt class_normtester_any)
      (progn
	(debug "normtester_labelinstr return nil")
	(return)))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nt))
	(:long ntestix (get_int nt))
	(normatch (unsafe_get_field :ntest_normatch nt))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	)
    (assert_msg "check normatch" (is_a normatch class_nrep_match))
    (assert_msg "check valid normatch" 
		(== (multiple_nth (get_field :nmatch_tests normatch) 
				  ntestix) 
		    nt))
    (let (
	  (prefix (mapobject_get matchmap normatch))
	  (labins (instance class_objlabelinstr
			    :obi_loc nloc
			    :oblab_prefix prefix
			    :oblab_rank nt)) 
	  )
      (debug "normtester_labelinstr result labins=" labins)
      (assert_msg "check prefix" (is_string prefix))
      (return labins)
      )))


;; utility function to return the goto instr into a tester
(defun normtester_gotoinstr (nt gcx)
  (debug  "normtester_gotoinstr start nt=" nt)
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (if (is_not_a nt class_normtester_any)
      (progn
	(debug "normtester_gotoinstr return nil")
	(return)))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc nt))
	(:long ntestix (get_int nt))
	(normatch (unsafe_get_field :ntest_normatch nt))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	)
    (debug "normtester_gotoinstr normatch=" normatch)
    (assert_msg "check normatch" (is_a normatch class_nrep_match))
    (assert_msg "check valid normatch" 
		(== (multiple_nth (get_field :nmatch_tests normatch) 
				  ntestix) 
		    nt))
    (let (
	  (prefix (mapobject_get matchmap normatch))
	  (goins (instance class_objgotoinstr
			    :obi_loc nloc
			    :obgoto_prefix prefix
			    :obgoto_rank nt)) 
	  )
      (debug "normtester_gotoinstr result goins=" goins)
      (assert_msg "check prefix" (is_string prefix))
      (return goins)
)))


;;; utility function to return the goto instr at end of matcher
(defun endmatch_gotoinstr (nma gcx nloc)
  (assert_msg "check nma" (is_a nma class_nrep_match))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (debug "endmatch_gotoinstr nma=" nma)
  (shortbacktrace_dbg "endmatch_gotoinstr" 15)
  (let ( 
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	(prefix (mapobject_get matchmap nma))
	(labuf (make_strbuf discr_strbuf))
	)
    (add2sbuf_string labuf prefix)
    (add2sbuf_strconst labuf "_end /*endmatch*/")
    (let (
	  (goins (instance 
		  class_objgotoinstr
		  :obi_loc nloc
		  :obgoto_prefix (strbuf2string discr_verbatim_string labuf)
		  :obgoto_rank ()))
	  )
      (debug "endmatch_gotoinstr goins=" goins)
      (return goins)
)))

;; utility function to return the goto instr to a given tester
(defun testmatch_gotoinstr (ntest nma gcx nloc)
  (debug "testmatch_gotoinstr ntest=" ntest)
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (assert_msg "check nma" (is_a nma class_nrep_match))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (shortbacktrace_dbg "testmatch_gotoinstr" 15)
  (let ( 
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	(prefix (mapobject_get matchmap nma))
	(labuf (make_strbuf discr_strbuf))
	)
    (add2sbuf_string labuf prefix)
    (add2sbuf_longdec labuf (get_int ntest))
    (add2sbuf_strconst labuf " /*testmatch*/")
    (let (
	  (goins (instance 
		  class_objgotoinstr
		  :obi_loc nloc
		  :obgoto_prefix (strbuf2string discr_verbatim_string labuf)
		  :obgoto_rank ()))
	  )
      (debug "testmatch_gotoinstr goins=" goins)
      (return goins)
      )))

;;; utility function to get free objloc for the local occurrences of a tester
(defun normtester_free_objloc_list (nt gcx tcx)
  (debug "normtester_free_objloc_list nt=" nt)
  (assert_msg "check nt" (is_a nt class_normtester_any))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloclist (unsafe_get_field :ntest_locclist nt))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	)
    (debug "normtester_free_objloc_list nloclist=" nloclist)
    (shortbacktrace_dbg "normtester_free_objloc_list" 15)
    (let ( (freelist
	    (list_map 
	     nloclist 
	     (lambda (nloc) 
	       (assert_msg "check nloc" (is_a nloc class_nrep_locsymocc))
	       (let ( (oblo
		       (get_free_objloctyped gcx 
				     (get_field :nocc_symb nloc)
				     (get_field :nocc_ctyp nloc)
				     )) )
		 (mapobject_put locmap (get_field :nocc_bind nloc) oblo)
		 oblo
	       )))) 
	   )
      (list_append2list (get_field :tcx_freelist tcx) freelist)
      (debug "normtester_free_objloc_list result freelist=" freelist)
      (return freelist)
      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; catch-all for unimplemented normtester
(defun compiltst_normtester_any (nta gcx tcx)
  (debug "compiltst_normtester_any nta=" nta 
	 "\n of discrim " (discrim nta)
	 "\n gcx=" gcx " tcx=" tcx)
  (error_strv (get_field :nrep_loc nta) 
	      "**UNIMPLEMENTED normal tester compilation "
	      (get_field :named_name (discrim nta)))
  (assert_msg "@$@UNIMPLEMENTED normal tester compilation" ())
)
(install_method class_normtester_any compile_tester compiltst_normtester_any)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compiltst_normtester_matcher (ntma gcx tcx)
  (debug "compiltst_normtester_matcher ntma=" ntma)
  (assert_msg "check ntma" (is_a ntma class_normtester_matcher))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntma))
	(nmatched (unsafe_get_field :ntest_matched ntma))
	(nthen (unsafe_get_field :ntest_then ntma))
	(nelse (unsafe_get_field :ntest_else ntma))
	(nmatcher (unsafe_get_field :ntmatch_matcher ntma))
	(nins (unsafe_get_field :ntmatch_inargs ntma))
	(nouts (unsafe_get_field :ntmatch_outlocs ntma))
	(normatch (unsafe_get_field :ntest_normatch ntma))
	(gotothen (normtester_gotoinstr nthen gcx))
	(gotoelse (normtester_gotoinstr nelse gcx))
	(olist (make_list discr_list))
	(matchmap (unsafe_get_field :gncx_matchmap gcx))
	(prefix (mapobject_get matchmap normatch))
	(freelist (normtester_free_objloc_list ntma gcx tcx))
	(nextest (get_field :tcx_nextest tcx))
	)
    (debug "compiltst_normtester_matcher matchmap=" matchmap " nextest=" nextest
	   " gotothen=" gotothen)
    (cond ( (null gotothen)
	    (shortbacktrace_dbg "compiltst_normtester_matcher null gotothen" 14)
	    (setq gotothen 
		  (if nextest 
		      (testmatch_gotoinstr nextest normatch gcx nloc)
		    (endmatch_gotoinstr normatch gcx nloc)))
	    (debug "compiltst_normtester_matcher fixed gotothen=" gotothen)
	    ))
    (debug "compiltst_normtester_matcher unfixed gotoelse=" gotoelse)
    (cond ( (null gotoelse)
	    (shortbacktrace_dbg "compiltst_normtester_matcher null gotoelse" 14)
	    (setq gotoelse 
		  (if nextest
		      (testmatch_gotoinstr nextest normatch gcx nloc)
		    (endmatch_gotoinstr normatch gcx nloc)))
	    (debug "compiltst_normtester_matcher fixed gotoelse=" gotoelse)
	    ))
    (debug "compiltst_normtester_matcher freelist=" freelist " prefix=" prefix)
    (assert_msg "check prefix" (is_string prefix))
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				:obi_loc nloc
				:oclr_vloc obloc
				)) )
       (list_append olist oclearob)
       ))
    (debug "compiltst_normtester_matcher before nmatcher=" nmatcher)
    (let ( (matcx (instance class_matchcompilcontext
			    :mcx_loc nloc
			    :mcx_normtester ntma
			    :mcx_gotothen gotothen
			    :mcx_gotoelse gotoelse
			    :mcx_olist olist
			    :mcx_suffix prefix
			    :mcx_statecounter (make_integerbox discr_integer 0)
			    )) )
      (debug "compiltst_normtester_matcher matcx=" matcx)
      (compile_matcher nmatcher matcx gcx)
      (debug "compiltst_normtester_matcher return olist=" olist)
      (return olist ())
      )
    ))
(install_method class_normtester_matcher compile_tester compiltst_normtester_matcher)

;;;;;;;;;;;;;;;;
(defun compiltst_normtester_instance (ntmi gcx tcx)
  (debug "compiltst_normtester_instance ntmi=" ntmi)
  (assert_msg "check ntmi" (is_a ntmi class_normtester_instance))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntmi))
	(nmatched (unsafe_get_field :ntest_matched ntmi))
	(nthen (unsafe_get_field :ntest_then ntmi))
	(nelse (unsafe_get_field :ntest_else ntmi))
	(normatch (unsafe_get_field :ntest_normatch ntmi))
	(nlocclist (unsafe_get_field :ntest_locclist ntmi))
	(olist (make_list discr_list))
	(:long ntestix (get_int ntmi))	
	(ntclass (unsafe_get_field :ntinst_class ntmi))
	(ntflds (unsafe_get_field :ntinst_fieldlocs ntmi))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(gotoelse (or (normtester_gotoinstr nelse gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(oclass (compile_obj ntclass gcx))
	(omatched (compile_obj nmatched gcx))
	(freelist (normtester_free_objloc_list ntmi gcx tcx))
	(othenlist (make_list discr_list))
	(oelselist (make_list discr_list))
	(othenblock (instance class_objplainblock
			      :obi_loc nloc
			      :oblo_bodyl othenlist
			      ))
	(oelseblock (instance class_objplainblock
			      :obi_loc nloc
			      :oblo_bodyl oelselist))
	(otest 
	 (make_objlocatedexp 
	  nloc ctype_long
	  ##{/*normtesterinst*/ (melt_is_instance_of((melt_ptr_t)($OMATCHED),
						     (melt_ptr_t)($OCLASS)))}#))	     
	(ocond (instance class_objcond
			 :obi_loc nloc
			 :obcond_test otest
			 :obcond_then othenblock
			 :obcond_else oelseblock))
	)
    (debug "compiltst_normtester_instance otest=" otest
	   " gotothen=" gotothen " gotoelse=" gotoelse
	   " ocond=" ocond)
    (assert_msg "check oclass" (is_object oclass))
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (debug "compiltst_normtester_instance obloc=" obloc)
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				 :obi_loc nloc
				 :oclr_vloc obloc
				 )) )
       (list_append olist oclearob)
     ))
    ;; add the cond
    (list_append olist ocond)
    ;; we have to add into the othenlist the fetch of each field and
    ;; the gotothen
    (debug "compiltst_normtester_instance ntflds=" ntflds " nlocclist=" nlocclist)
    (foreach_in_multiple
     (ntflds)
     (fldoc :long fldix)
     (if fldoc
	 (progn
	   (debug "compiltst_normtester_instance fldoc=" fldoc " fldix=" fldix)
	   (assert_msg "check fldoc" (is_a fldoc class_nrep_locsymocc))
	   (let ( (flovar (compile_obj fldoc gcx))
		  (flbind (unsafe_get_field :nocc_bind fldoc))
		  (fldget (unsafe_get_field :letbind_expr flbind))
		  (ofget (compile_obj fldget gcx))
		  )
	     (assert_msg "check flbind" (is_a flbind class_normal_let_binding))
	     (assert_msg "check fldget" (is_a fldget class_nrep_unsafe_get_field))
	     (put_objdest ofget flovar)
	     (debug "compiltst_normtester_instance ofget=" ofget)
	     (assert_msg "check ofget" (is_object ofget))
	     (list_append othenlist ofget)
     ))))
    ;; also add the gotothen
    (assert_msg "check gotothen" (is_object gotothen))
    (list_append othenlist gotothen)
    ;;
    ;; add into the oelselist the gotoelse
    (assert_msg "check gotoelse" (is_object gotoelse))
    (list_append oelselist gotoelse)
    (debug  "compiltst_normtester_instance final olist=" olist)
    (return olist ())
    )
  )
(install_method class_normtester_instance compile_tester compiltst_normtester_instance)




;;;;;;;;;;;;;;;;
(defun compiltst_normtester_tuple (ntup gcx tcx)
  (debug "compiltst_normtester_tuple ntup=" ntup " of discrim=" (discrim ntup))
  (assert_msg "check ntup" (is_a ntup class_normtester_tuple))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( (nloc (unsafe_get_field :nrep_loc ntup))
	 (nmatched (unsafe_get_field :ntest_matched ntup))
	 (nthen (unsafe_get_field :ntest_then ntup))
	 (nelse (unsafe_get_field :ntest_else ntup))
	 (normatch (unsafe_get_field :ntest_normatch ntup))
	 (nlocclist (unsafe_get_field :ntest_locclist ntup))
	 (ntupcomp (unsafe_get_field :nttuple_components ntup))
	 (:long nbcomp (multiple_length ntupcomp))
	 (olist (make_list discr_list))
	 (:long ntestix (get_int ntup))	
	 (gotothen (or (normtester_gotoinstr nthen gcx)
		       (endmatch_gotoinstr normatch gcx nloc)))
	 (gotoelse (or (normtester_gotoinstr nelse gcx)
		       (endmatch_gotoinstr normatch gcx nloc)))
	 (omatched (compile_obj nmatched gcx))
	 (freelist (normtester_free_objloc_list ntup gcx tcx))
	 (othenlist (make_list discr_list))
	 (oelselist (make_list discr_list))
	 (othenblock (instance class_objplainblock
			       :obi_loc nloc
			       :oblo_bodyl othenlist
			       ))
	 (oelseblock (instance class_objplainblock
			       :obi_loc nloc
			       :oblo_bodyl oelselist))
	 (otest 
	  (make_objlocatedexp
	   nloc ctype_long
	   ##{/*normtestertuple*/ (melt_magic_discr((melt_ptr_t)($OMATCHED)) == MELTOBMAG_MULTIPLE
		&& ((meltmultiple_ptr_t)($OMATCHED))->nbval == $NBCOMP)}#)				   )
	 (ocond (instance class_objcond
			  :obi_loc nloc
			  :obcond_test otest
			  :obcond_then othenblock
			  :obcond_else oelseblock))
	 )
    (debug "compiltst_normtester_tuple omatched=" omatched " freelist=" freelist 
	   "\n otest=" otest
	   "\n ocond=" ocond)
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (debug "compiltst_normtester_tuple obloc=" obloc)
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				:obi_loc nloc
				:oclr_vloc obloc
				)) )
       (list_append olist oclearob)
       ))
    ;; add the cond
    (list_append olist ocond)
    ;; we have to add into the othenlist the fetch of each component and
    ;; the gotothen
    (debug "compiltst_normtester_tuple ntupcomp=" ntupcomp)
    (foreach_in_multiple
     (ntupcomp)
     (curntup :long tupix)
     (debug "compiltst_normtester_tuple curntup=" curntup " tupix=" tupix)
     (if curntup
	 (let ( (curovar (compile_obj curntup gcx))
		(cnbind (get_field :nocc_bind curntup))
		(curbexp (get_field :letbind_expr cnbind))
		(curoexp (compile_obj curbexp gcx))
	     )
	   (debug "compiltst_normtester_tuple curovar=" curovar 
		  "  cnbind=" cnbind "  curbexp=" curbexp "  curoexp=" curoexp
		  " tupix=" tupix)
	   (assert_msg "check curovar" (is_a curovar class_objlocv))
	   (assert_msg "check cnbind" (is_a cnbind class_normal_let_binding))
	   (assert_msg "check curbexp" (is_a curbexp class_nrep_unsafe_nth_component))
	   (assert_msg "check nthrnk" (==i (get_int (get_field :nunth_index curbexp)) tupix))
	   (put_objdest curoexp curovar)
	   (debug "compiltst_normtester_tuple updated curoexp=" curoexp)
	   (list_append othenlist curoexp)
	   ))
     );; end foreach ntupcomp
    ;; also add the gotothen
    (assert_msg "check gotothen" (is_object gotothen))
    (list_append othenlist gotothen)
    ;;
    ;; add into the oelselist the gotoelse
    (assert_msg "check gotoelse" (is_object gotoelse))
    (list_append oelselist gotoelse)
    (debug "compiltst_normtester_tuple final olist=" olist)
    (return olist ())
    ))
(install_method class_normtester_tuple compile_tester compiltst_normtester_tuple)




;;;;;;;;;;;;;;;;
(defun compiltst_normtester_same (ntsa gcx tcx)
  (debug "compiltst_normtester_same ntsa=" ntsa)
  (assert_msg "check ntsa" (is_a ntsa class_normtester_same))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntsa))
	(nmatched (unsafe_get_field :ntest_matched ntsa))
	(nthen (unsafe_get_field :ntest_then ntsa))
	(nelse (unsafe_get_field :ntest_else ntsa))
	(normatch (unsafe_get_field :ntest_normatch ntsa))
	(nidentical (unsafe_get_field :ntsame_identical ntsa))
	(:long ntestix (get_int ntsa))	
	(omatched (compile_obj nmatched gcx))
	(oidentical (compile_obj nidentical gcx))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(gotoelse (or (normtester_gotoinstr nelse gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	(freelist (normtester_free_objloc_list ntsa gcx tcx))
	(othenlist (make_list discr_list))
	(oelselist (make_list discr_list))
	(othenblock (instance class_objplainblock
			      :obi_loc nloc
			      :oblo_bodyl othenlist
			      ))
	(oelseblock (instance class_objplainblock
			      :obi_loc nloc
			      :oblo_bodyl oelselist))
	(otest
	 (make_objlocatedexp 
	  nloc ctype_long
	  ##{/*testersame*/ ($OMATCHED == $OIDENTICAL)}#))
	(ocond (instance class_objcond
			 :obi_loc nloc
			 :obcond_test otest
			 :obcond_then othenblock
			 :obcond_else oelseblock))
	(olist (make_list discr_list))
	)
    (debug "compiltst_normtester_same ocond=" ocond)
    ;; clear the freelist
    (foreach_in_list
     (freelist)
     (locpair obloc)
     (assert_msg "check obloc" (is_a obloc class_objlocv))
     (let ( (oclearob (instance class_objclear
				 :obi_loc nloc
				 :oclr_vloc obloc
				 )) )
       (list_append olist oclearob)
     ))
    ;; add the cond
    (list_append olist ocond)
    ;; also add the gotothen
    (assert_msg "check gotothen" (is_object gotothen))
    (list_append othenlist gotothen)
    ;; add into the oelselist the gotoelse
    (assert_msg "check gotoelse" (is_object gotoelse))
    (list_append oelselist gotoelse)
    (debug "compiltst_normtester_same return olist=" olist)
    (return olist ())
    )
)
(install_method class_normtester_same compile_tester compiltst_normtester_same)


;;;;;;;;;;;;;;;;
(defun compiltst_normtester_success (ntsu gcx tcx)
  (debug "compiltst_normtester_success ntsu=" ntsu " tcx=" tcx)
  (assert_msg "check ntsu" (is_a ntsu class_normtester_success))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntsu))
	(nmatched (unsafe_get_field :ntest_matched ntsu))
	(nthen (unsafe_get_field :ntest_then ntsu))
	(nelse (unsafe_get_field :ntest_else ntsu))
	(nloclis (unsafe_get_field :ntest_locclist ntsu))
	(normatch (unsafe_get_field :ntest_normatch ntsu))
	(nsucdo (unsafe_get_field :ntsuccess_do ntsu))
	(:long ntestix (get_int ntsu))	
	(gotoend (endmatch_gotoinstr normatch gcx nloc))
	)
    (assert_msg "check nil nloclis" (null nloclis))
    (assert_msg "check nil nthen" (null nthen))
    (assert_msg "check nil nelse" (null nelse))
    (let ( (osucc (compile_obj nsucdo gcx)) 
	   )
      ;; maybe we have to free all the location allocated for this test
      (if (is_list osucc)
	  (progn
	    (list_append osucc gotoend)
	    (return osucc (list_last osucc)))
	(return (list osucc gotoend) osucc))
      )))
(install_method class_normtester_success compile_tester compiltst_normtester_success)

;;;;;;;;;;;;;;;;
(defun compiltst_normtester_orclear (ntoc gcx tcx)
  (debug "compiltst_normtester_orclear ntoc=" ntoc)
  (assert_msg "check ntoc" (is_a ntoc class_normtester_or_clear))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntoc))
	(nmatched (unsafe_get_field :ntest_matched ntoc))
	(normatch (unsafe_get_field :ntest_normatch ntoc))
	(nthen (unsafe_get_field :ntest_then ntoc))
	(nelse (unsafe_get_field :ntest_else ntoc))
	(nclear (unsafe_get_field :ntorclear_locsym ntoc))
	(locmap (unsafe_get_field :gncx_locmap gcx))
	(olist (make_list discr_list))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
;;;	(gotoelse (or (normtester_gotoinstr nelse gcx)
;;;		      (endmatch_gotoinstr normatch gcx nloc)))
	)
    (debug "compiltst_normtester_orclear nclear=" nclear
	   " nthen=" nthen " nelse=" nelse)
    (assert_msg "check nclear" (is_multiple nclear))
    (foreach_in_multiple
     (nclear)
     (curlocs :long cix)
     (debug "compiltst_normtester_orclear curlocs=" curlocs " cix=" cix)
     (shortbacktrace_dbg "compiltst_normtester_orclear curlocs" 14)
     (let ( 
	   ;; TODO: perhaps we should not allocate a new obva but just
	   ;; compile the curlocs
	   (ocurl (let ( (oc (compile_obj curlocs gcx)) 
			 )
		    (debug "compiltst_normtester_orclear ocurl=" oc)
		    oc))
	   (oclrloc (instance class_objclear
			      :obi_loc nloc
			      :oclr_vloc ocurl
			      ))
	   )
       (debug "compiltst_normtester_orclear oclrloc=" oclrloc)
       (list_append olist oclrloc)
       )
     )
    (list_append olist gotothen)
    (debug "compiltst_normtester_orclear final olist=" olist)
    (return olist ())
    ))
(install_method class_normtester_or_clear compile_tester compiltst_normtester_orclear)
;;;;;;;;;;;;;;;;

(defun compiltst_normtester_ortransmit (ntot gcx tcx)
  (debug "compiltst_normtester_ortransmit ntot=" ntot)
  (assert_msg "check ntot" (is_a ntot class_normtester_or_transmit))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let ( 
	(nloc (unsafe_get_field :nrep_loc ntot))
	(nmatched (unsafe_get_field :ntest_matched ntot))
	(normatch (unsafe_get_field :ntest_normatch ntot))
	(ntupdst (unsafe_get_field :ntortransmit_dst ntot))
	(ntupsrc (unsafe_get_field :ntortransmit_src ntot))
	(nthen (unsafe_get_field :ntest_then ntot))
	(nelse (unsafe_get_field :ntest_else ntot))
	(olist (make_list discr_list))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	)
    (assert_msg "check null nelse" (null nelse))
    (assert_msg "check same size ntupdst ntupsc" 
		(==i (multiple_length ntupdst) (multiple_length ntupsrc)))
    (foreach_in_multiple
     (ntupdst)
     (ncurdst :long nix)
     (let ( (ncursrc (multiple_nth ntupsrc nix)) 
	    )
       (debug "compiltst_normtester_ortransmit ncursrc=" ncursrc " ncurdst=" ncurdst " nix=" nix)
       (let ( 
	     (osrc (compile_obj ncursrc gcx))
	     (dstype (get_field :nocc_ctyp ncurdst))
	     (odst (compile_obj ncurdst gcx))
	     (dstlist (make_list discr_list))
	     (ocomp (instance class_objcompute
		     :obi_loc nloc
		     :obdi_destlist dstlist
		     :obcpt_type dstype
		     :obcpt_expr osrc))
	     )
	 (list_append dstlist odst)
	 (debug "compiltst_normtester_ortransmit osrc=" osrc " odst=" odst " ocomp=" ocomp)
	 (list_append olist ocomp)
       )))
    (list_append olist gotothen)
    (debug "compiltst_normtester_ortransmit final olist=" olist)
    (return olist ())
    ))
(install_method class_normtester_or_transmit compile_tester compiltst_normtester_ortransmit)

;;;;;;;;;;;;;;;;
;; to compile a disjunction, just goto the then case, because the
;; disjunction is only here to redistribute the then case inside the
;; disjuncts.
(defun compiltst_normtester_disjunction (ntdj gcx tcx)
  (debug "compiltst_normtester_disjunction ntdj=" ntdj)
  (assert_msg "check ntdj" (is_a ntdj class_normtester_disjunction))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (assert_msg "check tcx" (is_a tcx class_testercompilcontext))
  (let (
	(locmap (unsafe_get_field :gncx_locmap gcx))
	(nloc (unsafe_get_field :nrep_loc ntdj))
	(nthen (unsafe_get_field :ntest_then ntdj))
	(normatch (unsafe_get_field :ntest_normatch ntdj))
	(ndisjlocsy (unsafe_get_field :ntdisj_freshorvar ntdj))
	(gotothen (or (normtester_gotoinstr nthen gcx)
		      (endmatch_gotoinstr normatch gcx nloc)))
	;; not sure that freelist is needed!
	(freelist (normtester_free_objloc_list ntdj gcx tcx))
	)
    (debug "compiltst_normtester_disjunction ndisjlocsy=" ndisjlocsy " gotothen=" gotothen " freelist=" freelist)
    (compile_warning "do we need the freelist in compiltst_normtester_disjunction?")
    (foreach_in_multiple
     (ndisjlocsy)
     (curdisjloc :long lix)
     (debug  "compiltst_normtester_disjunction curdisjloc=" curdisjloc " lix=" lix)
     (assert_msg "check curdisjloc" (is_a curdisjloc class_nrep_locsymocc))
     (let ( (dbind (unsafe_get_field :nocc_bind curdisjloc))
	    (dsymb (unsafe_get_field :nocc_symb curdisjloc))
	    (dctyp (unsafe_get_field :nocc_ctyp curdisjloc))
	    (dobva (get_free_objloctyped gcx
					 dsymb
					 dctyp))
	   )
       (debug "compiltst_normtester_disjunction dobva=" dobva)
       (mapobject_put locmap dbind dobva)
       )
     )
    (return gotothen ())
    )
  )
(install_method class_normtester_disjunction compile_tester compiltst_normtester_disjunction)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilmatcher_cmatcher (cmat mcx gcx)
  (debug "compilmatcher_cmatcher cmat=" cmat " mcx=" mcx)
  (assert_msg "check cmat" (is_a cmat class_cmatcher))
  (assert_msg "check mcx" (is_a mcx class_matchcompilcontext))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let (
	(cmins (unsafe_get_field :amatch_in cmat))
	(cmbind (unsafe_get_field :amatch_matchbind cmat))
	(cmouts (unsafe_get_field :amatch_out cmat))
	(cmstate (unsafe_get_field :cmatch_state cmat))
	(cmexptest (unsafe_get_field :cmatch_exptest cmat))
	(cmexpfill (unsafe_get_field :cmatch_expfill cmat))
	;; the normtester
	(normtester (unsafe_get_field :mcx_normtester mcx))
	;; the subsitution map
	(substmap (make_mapobject discr_map_objects 
				  (+i 5
				      (*i 2 (+i (multiple_length cmins)
						(multiple_length cmouts))))))
	(:long mcxcount
	       (let ( (boxcnt (get_field :mcx_statecounter mcx))
		      (:long cnt (+i 1 (get_int boxcnt)) ) )
		 (put_int boxcnt cnt)
		 cnt))
	;; generate a unique state string
	(uniqstate (let ( (sbuf (make_strbuf discr_strbuf)) )
		     (add2sbuf_cident sbuf (get_field :named_name cmstate))
		     (add2sbuf_strconst sbuf "_")
		     (add2sbuf_string sbuf (get_field :mcx_suffix mcx))
		     (add2sbuf_strconst sbuf "_")
		     (add2sbuf_longdec sbuf mcxcount)
		     (strbuf2string discr_verbatim_string sbuf)))
	;; fetch the olist to add instructions into
	(olist (get_field :mcx_olist mcx))
	)
    ;; map the state to the unique string 
    (mapobject_put substmap cmstate uniqstate)
    ;; map the matched thing 
    (let ( (nmatched (get_field :ntest_matched normtester)) )
      (debug "compilmatcher_cmatcher nmatched=" nmatched)
      (let ( (obmatched (compile_obj nmatched gcx)) )
	(debug "compilmatcher_cmatcher obmatched=" obmatched)
	(mapobject_put substmap
		       (get_field :binder cmbind)
		       obmatched
		       )))
    ;;
    (debug "compilmatcher_cmatcher normtester=" normtester)
    ;; map each input arguments
    (multiple_every_both 
     (get_field :ntmatch_inargs normtester)
     cmins
     (lambda (curin formin :long ix)
       (debug "compilmatcher_cmatcher curin=" curin " formin=" formin " ix=" ix)
       (assert_msg "check formin" (is_a formin class_formal_binding))
       (let ( (oin (compile_obj curin gcx)) )
	 (debug "compilmatcher_cmatcher oin=" oin)
	 (mapobject_put substmap
			(get_field :binder formin)
			oin)
	 )))
    ;; map each output arguments
    (multiple_every_both
     (get_field :ntmatch_outlocs normtester)
     cmouts
     (lambda (curout formout :long ix)
       (debug "compilmatcher_cmatcher curout=" curout " formout=" formout " ix=" ix)
       (assert_msg "check formout" (is_a formout class_formal_binding))
       (let ( (oout (compile_obj curout gcx)) )
	 (debug "compilmatcher_cmatcher oout=" oout " ix=" ix)
	 (mapobject_put substmap
			(get_field :binder formout)
			oout))
       ))
    (debug "compilmatcher_cmatcher substmap=" substmap)
    ;; expand
    (let ( 
	  (expander 
	   (lambda (tup)
	     (multiple_map
	      tup
	      (lambda (c)
		(cond 
		 ( (is_a c class_symbol)
		   (let ( (r (mapobject_get substmap c)) )
		     (if (null r)
			 (error_strv (get_field :mcx_loc mcx)
				     "invalid symbol to expand for cmatcher" (get_field :named_name c)))
		     r))
		 ( (is_object c)
		   (error_plain (get_field :mcx_loc mcx)
				"invalid object to expand for cmatcher"))
		 ( (is_string c)
		   (make_string discr_verbatim_string c))
		 (:else
		  (error_plain (get_field :mcx_loc mcx)
			       "invalid stuff to expand for cmatcher")))))))
	  (exptest (expander cmexptest))
	  (expfill (expander cmexpfill))
	  (mloc (get_field :mcx_loc mcx))
	  (testchunk (instance class_objlocatedexpv
			       :obv_type ctype_long
			       :obx_cont exptest
			       :obcx_loc mloc))
	  (fillchunk (instance class_objlocatedexpv
			       :obv_type ctype_void
			       :obx_cont expfill
			       :obcx_loc mloc))
	  )
      (debug  "compilmatcher_cmatcher exptest=" exptest " expfill=" expfill
	      " testchunk=" testchunk " fillchunk=" fillchunk)
      (assert_msg "compilmatcher_cmatcher check exptest" exptest)
      (let ( 
	    (othenlist (make_list discr_list))
	    (othenbody (instance class_objplainblock
				 :obi_loc mloc
				 :oblo_bodyl othenlist
				 ))
	    (oelselist (make_list discr_list))
	    (oelsebody (instance class_objplainblock
				 :obi_loc mloc
				 :oblo_bodyl oelselist
				 ))
	    (ocond (instance class_objcond
			     :obi_loc mloc
			     :obcond_test testchunk
			     :obcond_then othenbody
			     :obcond_else oelsebody
			     ))
	    )
	(debug "compilmatcher_cmatcher ocond=" ocond)
	(list_append olist ocond)
	(foreach_in_multiple
	 (cmouts)
	 (curout :long outix)
	 (debug "compilmatcher_cmatcher curout=" curout " outix=" outix)
	 (assert_msg "check curout" (is_a curout class_formal_binding))
	 (let ( (locout
		 (mapobject_get substmap 
				(unsafe_get_field :binder curout)))
		(oclearout (instance class_objclear
				     :obi_loc mloc
				     :oclr_vloc locout)) )
	   (debug "compilmatcher_cmatcher oclearout=" oclearout)
	   (assert_msg "check locout" (is_object locout))
	   (list_append othenlist oclearout)
	   )
	 )
	(list_append othenlist fillchunk)
	(list_append othenlist (get_field :mcx_gotothen mcx))
	(list_append oelselist (get_field :mcx_gotoelse mcx))
	(debug "compilmatcher_cmatcher final ocond=" ocond)
	)
      )))
(install_method class_cmatcher compile_matcher compilmatcher_cmatcher)






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun compilmatcher_funmatcher (fmat mcx gcx)
  (debug "compilmatcher_funmatcher fmat=" fmat " mcx=" mcx)
  (assert_msg "check fmat" (is_a fmat class_funmatcher))
  (assert_msg "check mcx" (is_a mcx class_matchcompilcontext))
  (assert_msg "check gcx" (is_a gcx class_c_generation_context))
  (let (
	(fmins (unsafe_get_field :amatch_in fmat))
	(fmbind (unsafe_get_field :amatch_matchbind fmat))
	(fmouts (unsafe_get_field :amatch_out fmat))
	(ntma (get_field :mcx_normtester mcx))
	;; fetch the olist to add instructions into
	(olist (get_field :mcx_olist mcx)) 
	(mloc (get_field :mcx_loc mcx))
	)
    (debug "compilmatcher_funmatcher ntma=" ntma)
    (assert_msg "check ntma" (is_a ntma class_normtester_matcher))
    (let ( (matndata (get_field :ntmatch_matndata ntma)) 
	   (omatdata (compile_obj matndata gcx))
	   (nmatched (get_field :ntest_matched ntma))
	   (omatched (compile_obj nmatched gcx))
	   (nins (get_field :ntmatch_inargs ntma))
	   (nouts (get_field :ntmatch_outlocs ntma))
	   (oins (multiple_map 
		  nins 
		  (lambda (thein)
		    (compile_obj thein gcx)
		    )))
	   (oouts (multiple_map 
		  nouts 
		  (lambda (theout)
		    (compile_obj theout gcx)
		    )))
	   (otestres (get_free_objlocptr gcx fmat))
	   (otestclos (get_free_objlocptr gcx '_closfunmatch))
	   )
      (debug "compilmatcher_funmatcher matndata=" matndata " omatdata=" omatdata
	     " fmins=" fmins " fmbind=" fmbind " fmouts=" fmouts
	     " nins=" nins " nouts=" nouts
	     " nmatched=" nmatched " omatched=" omatched
	     " oins=" oins " oouts=" oouts " ntma=" ntma 
	     " otestres=" otestres " otestclos=" otestclos)
      ;; should generate a multiapplication etc...
      (let (
	    (oargs (make_multiple discr_multiple (+i 2 (multiple_length oins))))
	    (ogetclos (instance class_objgetslot
				:obi_loc mloc
				:obdi_destlist (list otestclos)
				:ogetsl_obj omatdata
				:ogetsl_field fmatch_matchf
				))
	    (omapp (instance class_objmultiapply
			      :obi_loc mloc
			      :obdi_destlist (list otestres)
			      :obapp_clos otestclos
			      :obapp_args oargs
			      :obmultapp_xres oouts
			      ))
	    (othenlist (make_list discr_list))
	    (othenbody (instance class_objplainblock
				 :obi_loc mloc
				 :oblo_bodyl othenlist
				 ))
	    (oelselist (make_list discr_list))
	    (oelsebody (instance class_objplainblock
				 :obi_loc mloc
				 :oblo_bodyl oelselist
				 ))
	    (ocond (instance class_objcond
			     :obi_loc mloc
			     :obcond_test otestres
			     :obcond_then othenbody
			     :obcond_else oelsebody
			     ))
	     )
	(multiple_put_nth oargs 0 omatdata)
	(multiple_put_nth oargs 1 omatched)
	(foreach_in_multiple
	 (oins)
	 (curins :long inix)
	 (multiple_put_nth oargs (+i inix 2) curins)
	 )
	;; add the clear of all the outs in the else branch
	(foreach_in_multiple
	 (oouts)
	 (curouts :long outix)
	 (let ( (obcl (instance class_objclear
				:obi_loc mloc
				:oclr_vloc curouts)) )
	   (debug "compilmatcher_funmatcher obcl=" obcl)
	   (list_append oelselist obcl)
	 ))
	;; dispose the temporary variables
	(dispose_objloc otestres gcx)
	(dispose_objloc otestclos gcx)
	;; add the final gotos
	(list_append othenlist (get_field :mcx_gotothen mcx))
	(list_append oelselist (get_field :mcx_gotoelse mcx))
	(debug "compilmatcher_funmatcher ogetclos=" ogetclos 
	       " omapp=" omapp " ocond=" ocond)
	(list_append olist ogetclos)
	(list_append olist omapp)
	(list_append olist ocond)
	)
      )
    ))
(install_method class_funmatcher compile_matcher compilmatcher_funmatcher)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; eof warmelt-genobj.melt
