/** Copyright (C) 2011 Free Software Foundation, Inc.
  This generated file meltrunsup.h is part of GCC.

                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/



 /** from generate_runtypesupport_enum_objmagic **/
enum meltobmag_en /*generated */
{ MELTOBMAG__NONE = 0,

  MELTOBMAG__FIRST /* first valid object magic */  = 20000,

/* value descriptor object magic */
  /*valdesc #1 VALDESC_CLOSURE */
  MELTOBMAG_CLOSURE /*valmagic */  = 20000,

  /*valdesc #2 VALDESC_DECAY */
  MELTOBMAG_DECAY /*valmagic */  = 20001,

  /*valdesc #3 VALDESC_INT */
  MELTOBMAG_INT /*valmagic */  = 20002,

  /*valdesc #4 VALDESC_LIST */
  MELTOBMAG_LIST /*valmagic */  = 20003,

  /*valdesc #5 VALDESC_MAPOBJECTS */
  MELTOBMAG_MAPOBJECTS /*valmagic */  = 20004,

  /*valdesc #6 VALDESC_MAPSTRINGS */
  MELTOBMAG_MAPSTRINGS /*valmagic */  = 20005,

  /*valdesc #7 VALDESC_MIXBIGINT */
  MELTOBMAG_MIXBIGINT /*valmagic */  = 20006,

  /*valdesc #8 VALDESC_MIXINT */
  MELTOBMAG_MIXINT /*valmagic */  = 20007,

  /*valdesc #9 VALDESC_MIXLOC */
  MELTOBMAG_MIXLOC /*valmagic */  = 20008,

  /*valdesc #10 VALDESC_MULTIPLE */
  MELTOBMAG_MULTIPLE /*valmagic */  = 20009,

  /*valdesc #11 VALDESC_OBJECT */
  MELTOBMAG_OBJECT /*valmagic */  = 20010,

  /*valdesc #12 VALDESC_PAIR */
  MELTOBMAG_PAIR /*valmagic */  = 20011,

  /*valdesc #13 VALDESC_REAL */
  MELTOBMAG_REAL /*valmagic */  = 20012,

  /*valdesc #14 VALDESC_ROUTINE */
  MELTOBMAG_ROUTINE /*valmagic */  = 20013,

  /*valdesc #15 VALDESC_SPECIAL_FILE */
  MELTOBMAG_SPEC_FILE /*valmagic */  = 20014,

  /*valdesc #16 VALDESC_SPECIAL_MPFR */
  MELTOBMAG_SPEC_MPFR /*valmagic */  = 20015,

  /*valdesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT */
  MELTOBMAG_SPECPPL_COEFFICIENT /*valmagic */  = 20016,

  /*valdesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT */
  MELTOBMAG_SPECPPL_CONSTRAINT /*valmagic */  = 20017,

  /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
  MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM /*valmagic */  = 20018,

  /*valdesc #20 VALDESC_SPECIAL_PPL_GENERATOR */
  MELTOBMAG_SPECPPL_GENERATOR /*valmagic */  = 20019,

  /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
  MELTOBMAG_SPECPPL_GENERATOR_SYSTEM /*valmagic */  = 20020,

  /*valdesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
  MELTOBMAG_SPECPPL_LINEAR_EXPRESSION /*valmagic */  = 20021,

  /*valdesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON */
  MELTOBMAG_SPECPPL_POLYHEDRON /*valmagic */  = 20022,

  /*valdesc #24 VALDESC_SPECIAL_RAW_FILE */
  MELTOBMAG_SPEC_RAWFILE /*valmagic */  = 20023,

  /*valdesc #25 VALDESC_STRBUF */
  MELTOBMAG_STRBUF /*valmagic */  = 20024,

  /*valdesc #26 VALDESC_STRING */
  MELTOBMAG_STRING /*valmagic */  = 20025,

/* ctype gty object magic */
  /*gtyctype #1 CTYPE_BASIC_BLOCK */
  MELTOBMAG_BASICBLOCK /*boxedmagic */  = 20026,
  MELTOBMAG_MAPBASICBLOCKS /*mapmagic */  = 20027,
  /*gtyctype #2 CTYPE_BITMAP */
  MELTOBMAG_BITMAP /*boxedmagic */  = 20028,
  MELTOBMAG_MAPBITMAPS /*mapmagic */  = 20029,
  /*gtyctype #3 CTYPE_EDGE */
  MELTOBMAG_EDGE /*boxedmagic */  = 20030,
  MELTOBMAG_MAPEDGES /*mapmagic */  = 20031,
  /*gtyctype #4 CTYPE_GIMPLE */
  MELTOBMAG_GIMPLE /*boxedmagic */  = 20032,
  MELTOBMAG_MAPGIMPLES /*mapmagic */  = 20033,
  /*gtyctype #5 CTYPE_GIMPLE_SEQ */
  MELTOBMAG_GIMPLESEQ /*boxedmagic */  = 20034,
  MELTOBMAG_MAPGIMPLESEQS /*mapmagic */  = 20035,
  /*gtyctype #6 CTYPE_LOOP */
  MELTOBMAG_LOOP /*boxedmagic */  = 20036,
  MELTOBMAG_MAPLOOPS /*mapmagic */  = 20037,
  /*gtyctype #7 CTYPE_RTVEC */
  MELTOBMAG_RTVEC /*boxedmagic */  = 20038,
  MELTOBMAG_MAPRTVECS /*mapmagic */  = 20039,
  /*gtyctype #8 CTYPE_RTX */
  MELTOBMAG_RTX /*boxedmagic */  = 20040,
  MELTOBMAG_MAPRTXS /*mapmagic */  = 20041,
  /*gtyctype #9 CTYPE_TREE */
  MELTOBMAG_TREE /*boxedmagic */  = 20042,
  MELTOBMAG_MAPTREES /*mapmagic */  = 20043,
  MELTOBMAG__LAST
};				/* end generated enum meltobmag_en */
#define MELT_COUNT_GENERATED_OBJMAGIC 35
/*** end from generate_runtypesupport_enum_objmagic **/


/** generated by generate_runtypesupport_gty **/

#ifndef meltobject_ptr_t_TYPEDEFINED
typedef struct meltobject_st *meltobject_ptr_t;
#define meltobject_ptr_t_TYPEDEFINED
#endif /*meltobject_ptr_t_TYPEDEFINED */


#ifndef melt_ptr_t_TYPEDEFINED
typedef union melt_un *melt_ptr_t;
#define melt_ptr_t_TYPEDEFINED
#endif /*melt_ptr_t_TYPEDEFINED */


#ifndef meltroutine_ptr_t_TYPEDEFINED
typedef struct meltroutine_st *meltroutine_ptr_t;
#define meltroutine_ptr_t_TYPEDEFINED
#endif /*meltroutine_ptr_t_TYPEDEFINED */


#ifndef meltclosure_ptr_t_TYPEDEFINED
typedef struct meltclosure_st *meltclosure_ptr_t;
#define meltclosure_ptr_t_TYPEDEFINED
#endif /*meltclosure_ptr_t_TYPEDEFINED */


#ifndef meltroutfun_t_TYPEDEFINED
typedef melt_ptr_t meltroutfun_t (struct meltclosure_st *closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un *xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un *xrestab_);
#define meltroutfun_t_TYPEDEFINED
#endif /*meltroutfun_t_TYPEDEFINED */


/* generated ctype gty structures */


/*gtyctype #1 CTYPE_BASIC_BLOCK*/
struct GTY (()) meltbasicblock_st
{				/* when MELTOBMAG_BASICBLOCK */
  meltobject_ptr_t discr;
  basic_block val;
};

struct GTY (()) entrybasicblockmelt_st
{				/* for MELTOBMAG_MAPBASICBLOCKS */
  basic_block e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmapbasicblocks_st
{				/* when MELTOBMAG_MAPBASICBLOCKS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entrybasicblockmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
};


/*gtyctype #2 CTYPE_BITMAP*/
struct GTY (()) meltbitmap_st
{				/* when MELTOBMAG_BITMAP */
  meltobject_ptr_t discr;
  bitmap val;
};

struct GTY (()) entrybitmapmelt_st
{				/* for MELTOBMAG_MAPBITMAPS */
  bitmap e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmapbitmaps_st
{				/* when MELTOBMAG_MAPBITMAPS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entrybitmapmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #3 CTYPE_EDGE*/
struct GTY (()) meltedge_st
{				/* when MELTOBMAG_EDGE */
  meltobject_ptr_t discr;
  edge val;
};

struct GTY (()) entryedgemelt_st
{				/* for MELTOBMAG_MAPEDGES */
  edge e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmapedges_st
{				/* when MELTOBMAG_MAPEDGES */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entryedgemelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #4 CTYPE_GIMPLE*/
struct GTY (()) meltgimple_st
{				/* when MELTOBMAG_GIMPLE */
  meltobject_ptr_t discr;
  gimple val;
};

struct GTY (()) entrygimplemelt_st
{				/* for MELTOBMAG_MAPGIMPLES */
  gimple e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmapgimples_st
{				/* when MELTOBMAG_MAPGIMPLES */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entrygimplemelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #5 CTYPE_GIMPLE_SEQ*/
struct GTY (()) meltgimpleseq_st
{				/* when MELTOBMAG_GIMPLESEQ */
  meltobject_ptr_t discr;
  gimple_seq val;
};

struct GTY (()) entrygimpleseqmelt_st
{				/* for MELTOBMAG_MAPGIMPLESEQS */
  gimple_seq e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmapgimpleseqs_st
{				/* when MELTOBMAG_MAPGIMPLESEQS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entrygimpleseqmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
};


/*gtyctype #6 CTYPE_LOOP*/
struct GTY (()) meltloop_st
{				/* when MELTOBMAG_LOOP */
  meltobject_ptr_t discr;
  loop_p val;
};

struct GTY (()) entryloopmelt_st
{				/* for MELTOBMAG_MAPLOOPS */
  loop_p e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmaploops_st
{				/* when MELTOBMAG_MAPLOOPS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entryloopmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #7 CTYPE_RTVEC*/
struct GTY (()) meltrtvec_st
{				/* when MELTOBMAG_RTVEC */
  meltobject_ptr_t discr;
  rtvec val;
};

struct GTY (()) entryrtvecmelt_st
{				/* for MELTOBMAG_MAPRTVECS */
  rtvec e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmaprtvecs_st
{				/* when MELTOBMAG_MAPRTVECS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entryrtvecmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #8 CTYPE_RTX*/
struct GTY (()) meltrtx_st
{				/* when MELTOBMAG_RTX */
  meltobject_ptr_t discr;
  rtx val;
};

struct GTY (()) entryrtxmelt_st
{				/* for MELTOBMAG_MAPRTXS */
  rtx e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmaprtxs_st
{				/* when MELTOBMAG_MAPRTXS */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entryrtxmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/*gtyctype #9 CTYPE_TREE*/
struct GTY (()) melttree_st
{				/* when MELTOBMAG_TREE */
  meltobject_ptr_t discr;
  tree val;
};

struct GTY (()) entrytreemelt_st
{				/* for MELTOBMAG_MAPTREES */
  tree e_at;
  melt_ptr_t e_va;
};

struct GTY (()) meltmaptrees_st
{				/* when MELTOBMAG_MAPTREES */
  /* keep in sync with meltmappointers_st */
  meltobject_ptr_t discr;
  unsigned count;
  unsigned char lenix;
  struct entrytreemelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
};


/* value GTY types */

/*gtyvaldesc #1 VALDESC_CLOSURE*/
struct GTY ((variable_size)) meltclosure_st /* when MELTOBMAG_CLOSURE */
{
  meltobject_ptr_t discr;
  /* from VALDESC_CLOSURE in warmelt-base.melt */
  meltroutine_ptr_t rout;
  unsigned nbval;
  melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];

};				/* end meltclosure_st */

/* decl. chunk */
 /* decl VALDESC_CLOSURE  in warmelt-base.melt */
#define MELT_CLOSURE_STRUCT(N) {                \
    meltobject_ptr_t discr;                     \
    meltroutine_ptr_t rout;			\
    unsigned nbval;                             \
    melt_ptr_t tabval[N];                       \
    long _gap; }




/*gtyvaldesc #2 VALDESC_DECAY*/
struct GTY ((mark_hook ("melt_mark_decay"))) meltdecay_st /* when MELTOBMAG_DECAY */
{
  meltobject_ptr_t discr;
  /* from VALDESC_DECAY in warmelt-base.melt */
  melt_ptr_t val;
  unsigned remain;		/* remaining number of marking */

};				/* end meltdecay_st */

/* no decl. chunk */


/*gtyvaldesc #3 VALDESC_INT*/
struct GTY (()) meltint_st /* when MELTOBMAG_INT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_INT in warmelt-base.melt */
  long val;

};				/* end meltint_st */

/* decl. chunk */
 /* decl VALDESC_INT in warmelt-base.melt */
typedef struct meltint_st *meltint_ptr_t;
#define melt_unsafe_boxed_int_value(V) (((meltint_ptr_t)(V))->val)
static inline long
melt_boxed_int_value (melt_ptr_t v)
{
  return (melt_magic_discr (v) ==
	  MELTOBMAG_INT) ? melt_unsafe_boxed_int_value (v) : 0L;
}




/*gtyvaldesc #4 VALDESC_LIST*/
struct GTY (()) meltlist_st /* when MELTOBMAG_LIST */
{
  meltobject_ptr_t discr;
  /* from VALDESC_LIST in warmelt-base.melt */
  struct meltpair_st *first;
  struct meltpair_st *last;

};				/* end meltlist_st */

/* decl. chunk */
 /* decl VALDESC_LIST in warmelt-base.melt */
typedef struct meltlist_st *meltlist_ptr_t;




/*gtyvaldesc #5 VALDESC_MAPOBJECTS*/
struct GTY (()) meltmapobjects_st /* when MELTOBMAG_MAPOBJECTS */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MAPOBJECTS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  struct entryobjectsmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;
  /* the following field is usually the value of entab (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  struct entryobjectsmelt_st GTY ((length ("0"))) map_space[FLEXIBLE_DIM];

};				/* end meltmapobjects_st */

/* decl. chunk */
 /* decl VALDESC_MAPOBJECTS in warmelt-base.melt */
typedef struct meltmapobjects_st *meltmapobjects_ptr_t;




/*gtyvaldesc #6 VALDESC_MAPSTRINGS*/
struct GTY (()) meltmapstrings_st /* when MELTOBMAG_MAPSTRINGS */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MAPSTRINGS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  struct entrystringsmelt_st *GTY ((length ("melt_primtab[%h.lenix]"))) entab;

};				/* end meltmapstrings_st */

/* no decl. chunk */


/*gtyvaldesc #7 VALDESC_MIXBIGINT*/
struct GTY ((variable_size)) meltmixbigint_st /* when MELTOBMAG_MIXBIGINT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MIXBIGINT in warmelt-base.melt */
/* an exported array mpz compatible; since we use an exported mpz format, 
   the value can be copied and trashed by MELT garbage collector without 
   harm. */
  melt_ptr_t ptrval;
  bool negative;
  unsigned biglen;
  long GTY ((length ("%h.biglen"))) tabig[FLEXIBLE_DIM];

};				/* end meltmixbigint_st */

/* no decl. chunk */


/*gtyvaldesc #8 VALDESC_MIXINT*/
struct GTY (()) meltmixint_st /* when MELTOBMAG_MIXINT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MIXINT in warmelt-base.melt */
  melt_ptr_t ptrval;
  long intval;

};				/* end meltmixint_st */

/* no decl. chunk */


/*gtyvaldesc #9 VALDESC_MIXLOC*/
struct GTY (()) meltmixloc_st /* when MELTOBMAG_MIXLOC */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MIXLOC in warmelt-base.melt.melt */
  melt_ptr_t ptrval;
  long intval;
  location_t locval;

};				/* end meltmixloc_st */

/* no decl. chunk */


/*gtyvaldesc #10 VALDESC_MULTIPLE*/
struct GTY ((variable_size)) meltmultiple_st /* when MELTOBMAG_MULTIPLE */
{
  meltobject_ptr_t discr;
  /* from VALDESC_MULTIPLE in warmelt-base.melt */
  unsigned nbval;
  melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];

};				/* end meltmultiple_st */

/* decl. chunk */
  /* decl VALDESC_MULTIPLE in warmelt-base.melt */
#define MELT_MULTIPLE_STRUCT(N) {               \
    meltobject_ptr_t discr;                     \
    unsigned nbval;                             \
    melt_ptr_t tabval[N];                       \
    long _gap; }
typedef struct meltmultiple_st *meltmultiple_ptr_t;




/*gtyvaldesc #11 VALDESC_OBJECT*/
struct GTY ((variable_size)) meltobject_st /* when MELTOBMAG_OBJECT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_OBJECT in warmelt-base.melt */
  unsigned obj_hash;		/* hash code of the object */
  unsigned short obj_num;
  unsigned short obj_len;
  melt_ptr_t GTY ((length ("%h.obj_len"))) obj_vartab[FLEXIBLE_DIM];

};				/* end meltobject_st */

/* decl. chunk */
 /* decl VALDESC_OBJECT */
#define meltobj_class discr
#define meltobj_magic obj_num
#define MELT_OBJECT_STRUCT(N) {			\
  meltobject_ptr_t meltobj_class;		\
  unsigned obj_hash;				\
  unsigned short obj_num;			\
  unsigned short obj_len;			\
  melt_ptr_t* obj_vartab[N];			\
  long _gap; }




/*gtyvaldesc #12 VALDESC_PAIR*/
struct GTY ((chain_next ("%h.tl"))) meltpair_st /* when MELTOBMAG_PAIR */
{
  meltobject_ptr_t discr;
  /* from VALDESC_PAIR in warmelt-base.melt */
  melt_ptr_t hd;
  struct meltpair_st *tl;

};				/* end meltpair_st */

/* decl. chunk */
 /* decl VALDESC_PAIR in warmelt-base.melt */
typedef struct meltpair_st *meltpair_ptr_t;




/*gtyvaldesc #13 VALDESC_REAL*/
struct GTY (()) meltreal_st /* when MELTOBMAG_REAL */
{
  meltobject_ptr_t discr;
  /* from VALDESC_REAL in warmelt-base.melt */
  REAL_VALUE_TYPE val;

};				/* end meltreal_st */

/* no decl. chunk */


/*gtyvaldesc #14 VALDESC_ROUTINE*/
struct GTY ((variable_size)) meltroutine_st /* when MELTOBMAG_ROUTINE */
{
  meltobject_ptr_t discr;
  /* from VALDESC_ROUTINE in warmelt-base.melt */
  char routdescr[MELT_ROUTDESCR_LEN];
  meltroutfun_t *GTY ((skip)) routfunad;
  melt_ptr_t routdata;
  unsigned nbval;
  melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];

};				/* end meltroutine_st */

/* decl. chunk */
 /* decl VALDESC_ROUTINE */
#ifndef meltroutine_ptr_t_TYPEDEFINED
typedef struct meltroutine_st *meltroutine_ptr_t;
#define  meltroutine_ptr_t_TYPEDEFINED
#endif /*meltroutine_ptr_t_TYPEDEFINED from VALDESC_ROUTINE */

/* unsafely set inside the meltroutine_st pointed by Rptr the
   routine function pointer to Rout */
#define MELT_ROUTINE_SET_ROUTCODE(Rptr,Rout) do {	\
  ((struct meltroutine_st*)(Rptr))->routfunad		\
     = (Rout);						\
} while(0)

#define MELT_ROUTINE_STRUCT(N) {		\
  meltobject_ptr_t discr;			\
  char routdescr[MELT_ROUTDESCR_LEN];		\
  meltroutfun_t* routfunad;			\
  melt_ptr_t routdata;				\
  unsigned nbval;				\
  melt_ptr_t tabval[N];				\
  long _gap; }




/*gtyvaldesc #15 VALDESC_SPECIAL_FILE*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialfile_st /* when MELTOBMAG_SPEC_FILE */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_FILE in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialfile_st */

/* no decl. chunk */


/*gtyvaldesc #16 VALDESC_SPECIAL_MPFR*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialmpfr_st /* when MELTOBMAG_SPEC_MPFR */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_MPFR in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialmpfr_st */

/* no decl. chunk */


/*gtyvaldesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialpplcoefficient_st /* when MELTOBMAG_SPECPPL_COEFFICIENT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_COEFFICIENT in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplcoefficient_st */

/* no decl. chunk */


/*gtyvaldesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialpplconstraint_st /* when MELTOBMAG_SPECPPL_CONSTRAINT */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_CONSTRAINT in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplconstraint_st */

/* no decl. chunk */


/*gtyvaldesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM*/
struct GTY ((mark_hook ("melt_mark_special")))
  meltspecialpplconstraintsystem_st
/* when MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplconstraintsystem_st */

/* no decl. chunk */


/*gtyvaldesc #20 VALDESC_SPECIAL_PPL_GENERATOR*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialpplgenerator_st /* when MELTOBMAG_SPECPPL_GENERATOR */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_GENERATOR in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplgenerator_st */

/* no decl. chunk */


/*gtyvaldesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM*/
struct GTY ((mark_hook ("melt_mark_special")))
  meltspecialpplgeneratorsystem_st
/* when MELTOBMAG_SPECPPL_GENERATOR_SYSTEM */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplgeneratorsystem_st */

/* no decl. chunk */


/*gtyvaldesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION*/
struct GTY ((mark_hook ("melt_mark_special")))
  meltspecialppllinearexpression_st
/* when MELTOBMAG_SPECPPL_LINEAR_EXPRESSION */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialppllinearexpression_st */

/* no decl. chunk */


/*gtyvaldesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialpplpolyhedron_st /* when MELTOBMAG_SPECPPL_POLYHEDRON */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_PPL_POLYHEDRON in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialpplpolyhedron_st */

/* no decl. chunk */


/*gtyvaldesc #24 VALDESC_SPECIAL_RAW_FILE*/
struct GTY ((mark_hook ("melt_mark_special"))) meltspecialrawfile_st /* when MELTOBMAG_SPEC_RAWFILE */
{
  meltobject_ptr_t discr;
  /* from VALDESC_SPECIAL_RAW_FILE in warmelt-base.melt */
  int mark;
  struct meltspecial_st *GTY ((skip)) nextspec;
  union melt_special_un GTY ((skip)) val;

};				/* end meltspecialrawfile_st */

/* no decl. chunk */


/*gtyvaldesc #25 VALDESC_STRBUF*/
struct GTY (()) meltstrbuf_st /* when MELTOBMAG_STRBUF */
{
  meltobject_ptr_t discr;
  /* from VALDESC_STRBUF in warmelt-base.melt */
  char *GTY ((length ("1+melt_primtab[%h.buflenix]"))) bufzn;
  unsigned char buflenix;	/* allocated length index of
				   buffer */
  unsigned bufstart;
  unsigned bufend;		/* start & end useful positions */
  /* the following field is usually the value of buf (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  char GTY ((length ("0"))) buf_space[FLEXIBLE_DIM];

};				/* end meltstrbuf_st */

/* no decl. chunk */


/*gtyvaldesc #26 VALDESC_STRING*/
struct GTY ((variable_size)) meltstring_st /* when MELTOBMAG_STRING */
{
  meltobject_ptr_t discr;
  /* from VALDESC_STRING in warmelt-base.melt */
  char val[FLEXIBLE_DIM];	/* null terminated */

};				/* end meltstring_st */

/* decl. chunk */
 /* decl VALDESC_STRING from warmelt-base.melt */
#define MELT_STRING_STRUCT(N) {			\
  meltobject_ptr_t discr;			\
  char val[(N)+1];	/* null terminated */	\
  long _gap; }



/* our generated MELT union for everything */
typedef union GTY ((desc ("%0.u_discr->meltobj_magic"))) melt_un
{				/*generated melt_un */
  meltobject_ptr_t GTY ((skip)) u_discr;
  struct meltforward_st GTY ((skip)) u_forward;

  /*union gtyctype #1 CTYPE_BASIC_BLOCK */
  struct meltbasicblock_st GTY ((tag ("MELTOBMAG_BASICBLOCK"))) u_basicblock;	/* generated boxed union member */
  struct meltmapbasicblocks_st GTY ((tag ("MELTOBMAG_MAPBASICBLOCKS"))) u_mapbasicblocks;	/* generated map union member */

  /*union gtyctype #2 CTYPE_BITMAP */
  struct meltbitmap_st GTY ((tag ("MELTOBMAG_BITMAP"))) u_bitmap;	/* generated boxed union member */
  struct meltmapbitmaps_st GTY ((tag ("MELTOBMAG_MAPBITMAPS"))) u_mapbitmaps;	/* generated map union member */

  /*union gtyctype #3 CTYPE_EDGE */
  struct meltedge_st GTY ((tag ("MELTOBMAG_EDGE"))) u_edge;	/* generated boxed union member */
  struct meltmapedges_st GTY ((tag ("MELTOBMAG_MAPEDGES"))) u_mapedges;	/* generated map union member */

  /*union gtyctype #4 CTYPE_GIMPLE */
  struct meltgimple_st GTY ((tag ("MELTOBMAG_GIMPLE"))) u_gimple;	/* generated boxed union member */
  struct meltmapgimples_st GTY ((tag ("MELTOBMAG_MAPGIMPLES"))) u_mapgimples;	/* generated map union member */

  /*union gtyctype #5 CTYPE_GIMPLE_SEQ */
  struct meltgimpleseq_st GTY ((tag ("MELTOBMAG_GIMPLESEQ"))) u_gimpleseq;	/* generated boxed union member */
  struct meltmapgimpleseqs_st GTY ((tag ("MELTOBMAG_MAPGIMPLESEQS"))) u_mapgimpleseqs;	/* generated map union member */

  /*union gtyctype #6 CTYPE_LOOP */
  struct meltloop_st GTY ((tag ("MELTOBMAG_LOOP"))) u_loop;	/* generated boxed union member */
  struct meltmaploops_st GTY ((tag ("MELTOBMAG_MAPLOOPS"))) u_maploops;	/* generated map union member */

  /*union gtyctype #7 CTYPE_RTVEC */
  struct meltrtvec_st GTY ((tag ("MELTOBMAG_RTVEC"))) u_rtvec;	/* generated boxed union member */
  struct meltmaprtvecs_st GTY ((tag ("MELTOBMAG_MAPRTVECS"))) u_maprtvecs;	/* generated map union member */

  /*union gtyctype #8 CTYPE_RTX */
  struct meltrtx_st GTY ((tag ("MELTOBMAG_RTX"))) u_rtx;	/* generated boxed union member */
  struct meltmaprtxs_st GTY ((tag ("MELTOBMAG_MAPRTXS"))) u_maprtxs;	/* generated map union member */

  /*union gtyctype #9 CTYPE_TREE */
  struct melttree_st GTY ((tag ("MELTOBMAG_TREE"))) u_tree;	/* generated boxed union member */
  struct meltmaptrees_st GTY ((tag ("MELTOBMAG_MAPTREES"))) u_maptrees;	/* generated map union member */


  /*union.valdesc #1 VALDESC_CLOSURE */
  struct meltclosure_st GTY ((tag ("MELTOBMAG_CLOSURE"))) u_closure;	/* generated value union member */

  /*union.valdesc #2 VALDESC_DECAY */
  struct meltdecay_st GTY ((tag ("MELTOBMAG_DECAY"))) u_decay;	/* generated value union member */

  /*union.valdesc #3 VALDESC_INT */
  struct meltint_st GTY ((tag ("MELTOBMAG_INT"))) u_int;	/* generated value union member */

  /*union.valdesc #4 VALDESC_LIST */
  struct meltlist_st GTY ((tag ("MELTOBMAG_LIST"))) u_list;	/* generated value union member */

  /*union.valdesc #5 VALDESC_MAPOBJECTS */
  struct meltmapobjects_st GTY ((tag ("MELTOBMAG_MAPOBJECTS"))) u_mapobjects;	/* generated value union member */

  /*union.valdesc #6 VALDESC_MAPSTRINGS */
  struct meltmapstrings_st GTY ((tag ("MELTOBMAG_MAPSTRINGS"))) u_mapstrings;	/* generated value union member */

  /*union.valdesc #7 VALDESC_MIXBIGINT */
  struct meltmixbigint_st GTY ((tag ("MELTOBMAG_MIXBIGINT"))) u_mixbigint;	/* generated value union member */

  /*union.valdesc #8 VALDESC_MIXINT */
  struct meltmixint_st GTY ((tag ("MELTOBMAG_MIXINT"))) u_mixint;	/* generated value union member */

  /*union.valdesc #9 VALDESC_MIXLOC */
  struct meltmixloc_st GTY ((tag ("MELTOBMAG_MIXLOC"))) u_mixloc;	/* generated value union member */

  /*union.valdesc #10 VALDESC_MULTIPLE */
  struct meltmultiple_st GTY ((tag ("MELTOBMAG_MULTIPLE"))) u_multiple;	/* generated value union member */

  /*union.valdesc #11 VALDESC_OBJECT */
  struct meltobject_st GTY ((tag ("MELTOBMAG_OBJECT"))) u_object;	/* generated value union member */

  /*union.valdesc #12 VALDESC_PAIR */
  struct meltpair_st GTY ((tag ("MELTOBMAG_PAIR"))) u_pair;	/* generated value union member */

  /*union.valdesc #13 VALDESC_REAL */
  struct meltreal_st GTY ((tag ("MELTOBMAG_REAL"))) u_real;	/* generated value union member */

  /*union.valdesc #14 VALDESC_ROUTINE */
  struct meltroutine_st GTY ((tag ("MELTOBMAG_ROUTINE"))) u_routine;	/* generated value union member */

  /*union.valdesc #15 VALDESC_SPECIAL_FILE */
  struct meltspecialfile_st GTY ((tag ("MELTOBMAG_SPEC_FILE"))) u_special_file;	/* generated value union member */

  /*union.valdesc #16 VALDESC_SPECIAL_MPFR */
  struct meltspecialmpfr_st GTY ((tag ("MELTOBMAG_SPEC_MPFR"))) u_special_mpfr;	/* generated value union member */

  /*union.valdesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT */
  struct meltspecialpplcoefficient_st GTY ((tag ("MELTOBMAG_SPECPPL_COEFFICIENT"))) u_special_ppl_coefficient;	/* generated value union member */

  /*union.valdesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT */
  struct meltspecialpplconstraint_st GTY ((tag ("MELTOBMAG_SPECPPL_CONSTRAINT"))) u_special_ppl_constraint;	/* generated value union member */

  /*union.valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
  struct meltspecialpplconstraintsystem_st GTY ((tag ("MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM"))) u_special_ppl_constraint_system;	/* generated value union member */

  /*union.valdesc #20 VALDESC_SPECIAL_PPL_GENERATOR */
  struct meltspecialpplgenerator_st GTY ((tag ("MELTOBMAG_SPECPPL_GENERATOR"))) u_special_ppl_generator;	/* generated value union member */

  /*union.valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
  struct meltspecialpplgeneratorsystem_st GTY ((tag ("MELTOBMAG_SPECPPL_GENERATOR_SYSTEM"))) u_special_ppl_generator_system;	/* generated value union member */

  /*union.valdesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
  struct meltspecialppllinearexpression_st GTY ((tag ("MELTOBMAG_SPECPPL_LINEAR_EXPRESSION"))) u_special_ppl_linear_expression;	/* generated value union member */

  /*union.valdesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON */
  struct meltspecialpplpolyhedron_st GTY ((tag ("MELTOBMAG_SPECPPL_POLYHEDRON"))) u_special_ppl_polyhedron;	/* generated value union member */

  /*union.valdesc #24 VALDESC_SPECIAL_RAW_FILE */
  struct meltspecialrawfile_st GTY ((tag ("MELTOBMAG_SPEC_RAWFILE"))) u_special_rawfile;	/* generated value union member */

  /*union.valdesc #25 VALDESC_STRBUF */
  struct meltstrbuf_st GTY ((tag ("MELTOBMAG_STRBUF"))) u_strbuf;	/* generated value union member */

  /*union.valdesc #26 VALDESC_STRING */
  struct meltstring_st GTY ((tag ("MELTOBMAG_STRING"))) u_string;	/* generated value union member */

} melt_un_t /*end generated melt_un */ ;

/** end generated by generate_runtypesupport_gty **/



/** start of code generated by generate_runtypesupport_param **/
/* support for MELT parameter passing*/
enum /* generated enumeration for MELT parameters */
{
  MELTBPAR__NONE = 0,
  /*gtyctype #1 CTYPE_BASIC_BLOCK */
  MELTBPAR_BB /*=1*/ ,
#define MELTBPARSTR_BB  "\x1"

  /*gtyctype #2 CTYPE_BITMAP */
  MELTBPAR_BITMAP /*=2*/ ,
#define MELTBPARSTR_BITMAP  "\x2"

  /*gtyctype #3 CTYPE_CSTRING */
  MELTBPAR_CSTRING /*=3*/ ,
#define MELTBPARSTR_CSTRING  "\x3"

  /*gtyctype #4 CTYPE_EDGE */
  MELTBPAR_EDGE /*=4*/ ,
#define MELTBPARSTR_EDGE  "\x4"

  /*gtyctype #5 CTYPE_GIMPLE */
  MELTBPAR_GIMPLE /*=5*/ ,
#define MELTBPARSTR_GIMPLE  "\x5"

  /*gtyctype #6 CTYPE_GIMPLE_SEQ */
  MELTBPAR_GIMPLESEQ /*=6*/ ,
#define MELTBPARSTR_GIMPLESEQ  "\x6"

  /*gtyctype #7 CTYPE_LONG */
  MELTBPAR_LONG /*=7*/ ,
#define MELTBPARSTR_LONG  "\x7"

  /*gtyctype #8 CTYPE_LOOP */
  MELTBPAR_LOOP /*=8*/ ,
#define MELTBPARSTR_LOOP  "\x8"

  /*gtyctype #9 CTYPE_PPL_COEFFICIENT */
  MELTBPAR_PPL_COEFFICIENT /*=9*/ ,
#define MELTBPARSTR_PPL_COEFFICIENT  "\x9"

  /*gtyctype #10 CTYPE_PPL_CONSTRAINT */
  MELTBPAR_PPL_CONSTRAINT /*=10*/ ,
#define MELTBPARSTR_PPL_CONSTRAINT  "\xa"

  /*gtyctype #11 CTYPE_PPL_CONSTRAINT_SYSTEM */
  MELTBPAR_PPL_CONSTRAINT_SYSTEM /*=11*/ ,
#define MELTBPARSTR_PPL_CONSTRAINT_SYSTEM  "\xb"

  /*gtyctype #12 CTYPE_PPL_LINEAR_EXPRESSION */
  MELTBPAR_PPL_LINEAR_EXPRESSION /*=12*/ ,
#define MELTBPARSTR_PPL_LINEAR_EXPRESSION  "\xc"

  /*gtyctype #13 CTYPE_PPL_POLYHEDRON */
  MELTBPAR_PPL_POLYHEDRON /*=13*/ ,
#define MELTBPARSTR_PPL_POLYHEDRON  "\xd"

  /*gtyctype #14 CTYPE_RTVEC */
  MELTBPAR_RTVEC /*=14*/ ,
#define MELTBPARSTR_RTVEC  "\xe"

  /*gtyctype #15 CTYPE_RTX */
  MELTBPAR_RTX /*=15*/ ,
#define MELTBPARSTR_RTX  "\xf"

  /*gtyctype #16 CTYPE_TREE */
  MELTBPAR_TREE /*=16*/ ,
#define MELTBPARSTR_TREE  "\x10"

  /*gtyctype #17 CTYPE_VALUE */
  MELTBPAR_PTR /*=17*/ ,
#define MELTBPARSTR_PTR  "\x11"

  /*gtyctype #18 CTYPE_VOID */
    /*-- non parameter --*/
   /*-- non paramstr --*/

  MELTBPAR__LAST
};				/*end enum for MELT parameters */

union meltparam_un /* generated union for MELT parameters */
{
  void *meltbp_any;

  /*ctype #1 CTYPE_BASIC_BLOCK */
  basic_block meltbp_bb;	/*argument param. */

  basic_block *meltbp_bbptr;	/*result param. */
  /*ctype #2 CTYPE_BITMAP */
  bitmap meltbp_bitmap;		/*argument param. */

  bitmap *meltbp_bitmapptr;	/*result param. */
  /*ctype #3 CTYPE_CSTRING */
  const char *meltbp_cstring;	/*argument param. */

  /*no result */
  /*ctype #4 CTYPE_EDGE */
  edge meltbp_edge;		/*argument param. */

  edge *meltbp_edgeptr;		/*result param. */
  /*ctype #5 CTYPE_GIMPLE */
  gimple meltbp_gimple;		/*argument param. */

  gimple *meltbp_gimpleptr;	/*result param. */
  /*ctype #6 CTYPE_GIMPLE_SEQ */
  gimple_seq meltbp_gimpleseq;	/*argument param. */

  gimple_seq *meltbp_gimpleseqptr;	/*result param. */
  /*ctype #7 CTYPE_LONG */
  long meltbp_long;		/*argument param. */

  long *meltbp_longptr;		/*result param. */
  /*ctype #8 CTYPE_LOOP */
  loop_p meltbp_loop;		/*argument param. */

  loop_p *meltbp_loopptr;	/*result param. */
  /*ctype #9 CTYPE_PPL_COEFFICIENT */
  ppl_Coefficient_t meltbp_ppl_coefficient;	/*argument param. */

  ppl_Coefficient_t *meltbp_ppl_coefficientptr;	/*result param. */
  /*ctype #10 CTYPE_PPL_CONSTRAINT */
  ppl_Constraint_t meltbp_ppl_constraint;	/*argument param. */

  ppl_Constraint_t *meltbp_ppl_constraintptr;	/*result param. */
  /*ctype #11 CTYPE_PPL_CONSTRAINT_SYSTEM */
  ppl_Constraint_System_t meltbp_ppl_constraint_system;	/*argument param. */

  ppl_Constraint_System_t *meltbp_ppl_constraint_systemptr;	/*result param. */
  /*ctype #12 CTYPE_PPL_LINEAR_EXPRESSION */
  ppl_Linear_Expression_t meltbp_ppl_linear_expression;	/*argument param. */

  ppl_Linear_Expression_t *meltbp_ppl_linear_expressionptr;	/*result param. */
  /*ctype #13 CTYPE_PPL_POLYHEDRON */
  ppl_Polyhedron_t meltbp_ppl_polyhedron;	/*argument param. */

  ppl_Polyhedron_t *meltbp_ppl_polyhedronptr;	/*result param. */
  /*ctype #14 CTYPE_RTVEC */
  rtvec meltbp_rtvec;		/*argument param. */

  rtvec *meltbp_rtvecptr;	/*result param. */
  /*ctype #15 CTYPE_RTX */
  rtx meltbp_rtx;		/*argument param. */

  rtx *meltbp_rtxptr;		/*result param. */
  /*ctype #16 CTYPE_TREE */
  tree meltbp_tree;		/*argument param. */

  tree *meltbp_treeptr;		/*result param. */
  /*ctype #17 CTYPE_VALUE */
  melt_ptr_t meltbp_vptr;	/*argument param. */

  melt_ptr_t *meltbp_aptr;	/*result param. */
  /*ctype #18 CTYPE_VOID */
  /* no argument */

  /*no result */
};				/* end generated union for MELT parameters */
/** end of code generated by generate_runtypesupport_param **/


/** declaration generated by generate_runtypesupport_mag2str **/
const char *melt_obmag_string (int i);
#define MELT_OBMAG_STRING_generated



/** start of declarations generated by generate_runtypesupport_boxingfun **/
/*gtyctype #1 CTYPE_BASIC_BLOCK*/
melt_ptr_t meltgc_new_basicblock (meltobject_ptr_t discr, basic_block val);
void meltgc_basicblock_updatebox (melt_ptr_t boxp, basic_block val);

static inline basic_block
melt_basicblock_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_BASICBLOCK)
    return ((struct meltbasicblock_st *) box_p)->val;
  return (basic_block) 0;
}				/* end generated melt_basicblock_content */

/*gtyctype #2 CTYPE_BITMAP*/
melt_ptr_t meltgc_new_bitmap (meltobject_ptr_t discr, bitmap val);
void meltgc_bitmap_updatebox (melt_ptr_t boxp, bitmap val);

static inline bitmap
melt_bitmap_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_BITMAP)
    return ((struct meltbitmap_st *) box_p)->val;
  return (bitmap) 0;
}				/* end generated melt_bitmap_content */

/*gtyctype #3 CTYPE_EDGE*/
melt_ptr_t meltgc_new_edge (meltobject_ptr_t discr, edge val);
void meltgc_edge_updatebox (melt_ptr_t boxp, edge val);

static inline edge
melt_edge_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_EDGE)
    return ((struct meltedge_st *) box_p)->val;
  return (edge) 0;
}				/* end generated melt_edge_content */

/*gtyctype #4 CTYPE_GIMPLE*/
melt_ptr_t meltgc_new_gimple (meltobject_ptr_t discr, gimple val);
void meltgc_gimple_updatebox (melt_ptr_t boxp, gimple val);

static inline gimple
melt_gimple_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_GIMPLE)
    return ((struct meltgimple_st *) box_p)->val;
  return (gimple) 0;
}				/* end generated melt_gimple_content */

/*gtyctype #5 CTYPE_GIMPLE_SEQ*/
melt_ptr_t meltgc_new_gimpleseq (meltobject_ptr_t discr, gimple_seq val);
void meltgc_gimpleseq_updatebox (melt_ptr_t boxp, gimple_seq val);

static inline gimple_seq
melt_gimpleseq_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_GIMPLESEQ)
    return ((struct meltgimpleseq_st *) box_p)->val;
  return (gimple_seq) 0;
}				/* end generated melt_gimpleseq_content */

/*gtyctype #6 CTYPE_LOOP*/
melt_ptr_t meltgc_new_loop (meltobject_ptr_t discr, loop_p val);
void melt_loop_updatebox (melt_ptr_t boxp, loop_p val);

static inline loop_p
melt_loop_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_LOOP)
    return ((struct meltloop_st *) box_p)->val;
  return (loop_p) 0;
}				/* end generated melt_loop_content */

/*gtyctype #7 CTYPE_RTVEC*/
melt_ptr_t meltgc_new_rtvec (meltobject_ptr_t discr, rtvec val);
void meltgc_rtvec_updatebox (melt_ptr_t boxp, rtvec val);

static inline rtvec
melt_rtvec_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_RTVEC)
    return ((struct meltrtvec_st *) box_p)->val;
  return (rtvec) 0;
}				/* end generated melt_rtvec_content */

/*gtyctype #8 CTYPE_RTX*/
melt_ptr_t meltgc_new_rtx (meltobject_ptr_t discr, rtx val);
void meltgc_rtx_updatebox (melt_ptr_t boxp, rtx val);

static inline rtx
melt_rtx_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_RTX)
    return ((struct meltrtx_st *) box_p)->val;
  return (rtx) 0;
}				/* end generated melt_rtx_content */

/*gtyctype #9 CTYPE_TREE*/
melt_ptr_t meltgc_new_tree (meltobject_ptr_t discr, tree val);
void meltgc_tree_updatebox (melt_ptr_t boxp, tree val);

static inline tree
melt_tree_content (melt_ptr_t box_p)
{
  if (melt_magic_discr (box_p) == MELTOBMAG_TREE)
    return ((struct melttree_st *) box_p)->val;
  return (tree) 0;
}				/* end generated melt_tree_content */


/** end of declarations generated by generate_runtypesupport_boxingfun **/



/** start of code generated by generate_runtypesupport_mapfun **/

/*gtyctype #1 CTYPE_BASIC_BLOCK*/

/***map support for GTY ctype CTYPE_BASIC_BLOCK **/
static inline melt_ptr_t /*New map for CTYPE_BASIC_BLOCK */
meltgc_new_mapbasicblocks (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPBASICBLOCKS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_BASIC_BLOCK */

static inline melt_ptr_t /* Map getter for CTYPE_BASIC_BLOCK */
melt_get_mapbasicblocks (melt_ptr_t map_p, basic_block attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBASICBLOCKS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_BASIC_BLOCK */

static inline void /* Map putter for CTYPE_BASIC_BLOCK */
melt_put_mapbasicblocks (melt_ptr_t map_p, basic_block attr,
			 melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBASICBLOCKS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_BASIC_BLOCK */

static inline void /* Map remover for CTYPE_BASIC_BLOCK */
melt_remove_mapbasicblocks (melt_ptr_t map_p, basic_block attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBASICBLOCKS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_BASIC_BLOCK */

static inline unsigned /* Map counter for CTYPE_BASIC_BLOCK */
melt_count_mapbasicblocks (struct meltmapbasicblocks_st *map_s)
{
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBASICBLOCKS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_BASIC_BLOCK */

static inline unsigned /* Map size for CTYPE_BASIC_BLOCK */
melt_size_mapbasicblocks (struct meltmapbasicblocks_st *map_s)
{
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBASICBLOCKS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_BASIC_BLOCK */

static inline basic_block /* Map nth attr for CTYPE_BASIC_BLOCK */
melt_nthattr_mapbasicblocks (struct meltmapbasicblocks_st *map_s, int ix)
{
  basic_block at = 0;
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBASICBLOCKS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_BASIC_BLOCK */

static inline melt_ptr_t /* Map nth value for CTYPE_BASIC_BLOCK */
melt_nthval_mapbasicblocks (struct meltmapbasicblocks_st *map_s, int ix)
{
  basic_block at = 0;
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBASICBLOCKS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_BASIC_BLOCK */

/***end of map support for GTY ctype CTYPE_BASIC_BLOCK **/

 /*gtyctype #2 CTYPE_BITMAP */

/***map support for GTY ctype CTYPE_BITMAP **/
static inline melt_ptr_t /*New map for CTYPE_BITMAP */
meltgc_new_mapbitmaps (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPBITMAPS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_BITMAP */

static inline melt_ptr_t /* Map getter for CTYPE_BITMAP */
melt_get_mapbitmaps (melt_ptr_t map_p, bitmap attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBITMAPS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_BITMAP */

static inline void /* Map putter for CTYPE_BITMAP */
melt_put_mapbitmaps (melt_ptr_t map_p, bitmap attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBITMAPS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_BITMAP */

static inline void /* Map remover for CTYPE_BITMAP */
melt_remove_mapbitmaps (melt_ptr_t map_p, bitmap attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPBITMAPS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_BITMAP */

static inline unsigned /* Map counter for CTYPE_BITMAP */
melt_count_mapbitmaps (struct meltmapbitmaps_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBITMAPS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_BITMAP */

static inline unsigned /* Map size for CTYPE_BITMAP */
melt_size_mapbitmaps (struct meltmapbitmaps_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBITMAPS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_BITMAP */

static inline bitmap /* Map nth attr for CTYPE_BITMAP */
melt_nthattr_mapbitmaps (struct meltmapbitmaps_st *map_s, int ix)
{
  bitmap at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBITMAPS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_BITMAP */

static inline melt_ptr_t /* Map nth value for CTYPE_BITMAP */
melt_nthval_mapbitmaps (struct meltmapbitmaps_st *map_s, int ix)
{
  bitmap at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPBITMAPS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_BITMAP */

/***end of map support for GTY ctype CTYPE_BITMAP **/

 /*gtyctype #3 CTYPE_EDGE */

/***map support for GTY ctype CTYPE_EDGE **/
static inline melt_ptr_t /*New map for CTYPE_EDGE */
meltgc_new_mapedges (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPEDGES)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_EDGE */

static inline melt_ptr_t /* Map getter for CTYPE_EDGE */
melt_get_mapedges (melt_ptr_t map_p, edge attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPEDGES)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_EDGE */

static inline void /* Map putter for CTYPE_EDGE */
melt_put_mapedges (melt_ptr_t map_p, edge attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPEDGES)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_EDGE */

static inline void /* Map remover for CTYPE_EDGE */
melt_remove_mapedges (melt_ptr_t map_p, edge attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPEDGES)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_EDGE */

static inline unsigned /* Map counter for CTYPE_EDGE */
melt_count_mapedges (struct meltmapedges_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPEDGES)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_EDGE */

static inline unsigned /* Map size for CTYPE_EDGE */
melt_size_mapedges (struct meltmapedges_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPEDGES)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_EDGE */

static inline edge /* Map nth attr for CTYPE_EDGE */
melt_nthattr_mapedges (struct meltmapedges_st *map_s, int ix)
{
  edge at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPEDGES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_EDGE */

static inline melt_ptr_t /* Map nth value for CTYPE_EDGE */
melt_nthval_mapedges (struct meltmapedges_st *map_s, int ix)
{
  edge at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPEDGES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_EDGE */

/***end of map support for GTY ctype CTYPE_EDGE **/

 /*gtyctype #4 CTYPE_GIMPLE */

/***map support for GTY ctype CTYPE_GIMPLE **/
static inline melt_ptr_t /*New map for CTYPE_GIMPLE */
meltgc_new_mapgimples (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPGIMPLES)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_GIMPLE */

static inline melt_ptr_t /* Map getter for CTYPE_GIMPLE */
melt_get_mapgimples (melt_ptr_t map_p, gimple attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLES)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_GIMPLE */

static inline void /* Map putter for CTYPE_GIMPLE */
melt_put_mapgimples (melt_ptr_t map_p, gimple attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLES)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_GIMPLE */

static inline void /* Map remover for CTYPE_GIMPLE */
melt_remove_mapgimples (melt_ptr_t map_p, gimple attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLES)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_GIMPLE */

static inline unsigned /* Map counter for CTYPE_GIMPLE */
melt_count_mapgimples (struct meltmapgimples_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLES)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_GIMPLE */

static inline unsigned /* Map size for CTYPE_GIMPLE */
melt_size_mapgimples (struct meltmapgimples_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLES)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_GIMPLE */

static inline gimple /* Map nth attr for CTYPE_GIMPLE */
melt_nthattr_mapgimples (struct meltmapgimples_st *map_s, int ix)
{
  gimple at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_GIMPLE */

static inline melt_ptr_t /* Map nth value for CTYPE_GIMPLE */
melt_nthval_mapgimples (struct meltmapgimples_st *map_s, int ix)
{
  gimple at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_GIMPLE */

/***end of map support for GTY ctype CTYPE_GIMPLE **/

 /*gtyctype #5 CTYPE_GIMPLE_SEQ */

/***map support for GTY ctype CTYPE_GIMPLE_SEQ **/
static inline melt_ptr_t /*New map for CTYPE_GIMPLE_SEQ */
meltgc_new_mapgimpleseqs (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPGIMPLESEQS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_GIMPLE_SEQ */

static inline melt_ptr_t /* Map getter for CTYPE_GIMPLE_SEQ */
melt_get_mapgimpleseqs (melt_ptr_t map_p, gimple_seq attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLESEQS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_GIMPLE_SEQ */

static inline void /* Map putter for CTYPE_GIMPLE_SEQ */
melt_put_mapgimpleseqs (melt_ptr_t map_p, gimple_seq attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLESEQS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_GIMPLE_SEQ */

static inline void /* Map remover for CTYPE_GIMPLE_SEQ */
melt_remove_mapgimpleseqs (melt_ptr_t map_p, gimple_seq attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPGIMPLESEQS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_GIMPLE_SEQ */

static inline unsigned /* Map counter for CTYPE_GIMPLE_SEQ */
melt_count_mapgimpleseqs (struct meltmapgimpleseqs_st *map_s)
{
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLESEQS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_GIMPLE_SEQ */

static inline unsigned /* Map size for CTYPE_GIMPLE_SEQ */
melt_size_mapgimpleseqs (struct meltmapgimpleseqs_st *map_s)
{
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLESEQS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_GIMPLE_SEQ */

static inline gimple_seq /* Map nth attr for CTYPE_GIMPLE_SEQ */
melt_nthattr_mapgimpleseqs (struct meltmapgimpleseqs_st *map_s, int ix)
{
  gimple_seq at = 0;
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLESEQS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_GIMPLE_SEQ */

static inline melt_ptr_t /* Map nth value for CTYPE_GIMPLE_SEQ */
melt_nthval_mapgimpleseqs (struct meltmapgimpleseqs_st *map_s, int ix)
{
  gimple_seq at = 0;
  if (!map_s
      || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPGIMPLESEQS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_GIMPLE_SEQ */

/***end of map support for GTY ctype CTYPE_GIMPLE_SEQ **/

 /*gtyctype #6 CTYPE_LOOP */

/***map support for GTY ctype CTYPE_LOOP **/
static inline melt_ptr_t /*New map for CTYPE_LOOP */
meltgc_new_maploops (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPLOOPS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_LOOP */

static inline melt_ptr_t /* Map getter for CTYPE_LOOP */
melt_get_maploops (melt_ptr_t map_p, loop_p attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPLOOPS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_LOOP */

static inline void /* Map putter for CTYPE_LOOP */
melt_put_maploops (melt_ptr_t map_p, loop_p attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPLOOPS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_LOOP */

static inline void /* Map remover for CTYPE_LOOP */
melt_remove_maploops (melt_ptr_t map_p, loop_p attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPLOOPS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_LOOP */

static inline unsigned /* Map counter for CTYPE_LOOP */
melt_count_maploops (struct meltmaploops_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPLOOPS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_LOOP */

static inline unsigned /* Map size for CTYPE_LOOP */
melt_size_maploops (struct meltmaploops_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPLOOPS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_LOOP */

static inline loop_p /* Map nth attr for CTYPE_LOOP */
melt_nthattr_maploops (struct meltmaploops_st *map_s, int ix)
{
  loop_p at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPLOOPS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_LOOP */

static inline melt_ptr_t /* Map nth value for CTYPE_LOOP */
melt_nthval_maploops (struct meltmaploops_st *map_s, int ix)
{
  loop_p at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPLOOPS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_LOOP */

/***end of map support for GTY ctype CTYPE_LOOP **/

 /*gtyctype #7 CTYPE_RTVEC */

/***map support for GTY ctype CTYPE_RTVEC **/
static inline melt_ptr_t /*New map for CTYPE_RTVEC */
meltgc_new_maprtvecs (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPRTVECS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_RTVEC */

static inline melt_ptr_t /* Map getter for CTYPE_RTVEC */
melt_get_maprtvecs (melt_ptr_t map_p, rtvec attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTVECS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_RTVEC */

static inline void /* Map putter for CTYPE_RTVEC */
melt_put_maprtvecs (melt_ptr_t map_p, rtvec attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTVECS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_RTVEC */

static inline void /* Map remover for CTYPE_RTVEC */
melt_remove_maprtvecs (melt_ptr_t map_p, rtvec attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTVECS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_RTVEC */

static inline unsigned /* Map counter for CTYPE_RTVEC */
melt_count_maprtvecs (struct meltmaprtvecs_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTVECS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_RTVEC */

static inline unsigned /* Map size for CTYPE_RTVEC */
melt_size_maprtvecs (struct meltmaprtvecs_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTVECS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_RTVEC */

static inline rtvec /* Map nth attr for CTYPE_RTVEC */
melt_nthattr_maprtvecs (struct meltmaprtvecs_st *map_s, int ix)
{
  rtvec at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTVECS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_RTVEC */

static inline melt_ptr_t /* Map nth value for CTYPE_RTVEC */
melt_nthval_maprtvecs (struct meltmaprtvecs_st *map_s, int ix)
{
  rtvec at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTVECS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_RTVEC */

/***end of map support for GTY ctype CTYPE_RTVEC **/

 /*gtyctype #8 CTYPE_RTX */

/***map support for GTY ctype CTYPE_RTX **/
static inline melt_ptr_t /*New map for CTYPE_RTX */
meltgc_new_maprtxs (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPRTXS)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_RTX */

static inline melt_ptr_t /* Map getter for CTYPE_RTX */
melt_get_maprtxs (melt_ptr_t map_p, rtx attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTXS)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_RTX */

static inline void /* Map putter for CTYPE_RTX */
melt_put_maprtxs (melt_ptr_t map_p, rtx attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTXS)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_RTX */

static inline void /* Map remover for CTYPE_RTX */
melt_remove_maprtxs (melt_ptr_t map_p, rtx attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPRTXS)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_RTX */

static inline unsigned /* Map counter for CTYPE_RTX */
melt_count_maprtxs (struct meltmaprtxs_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTXS)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_RTX */

static inline unsigned /* Map size for CTYPE_RTX */
melt_size_maprtxs (struct meltmaprtxs_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTXS)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_RTX */

static inline rtx /* Map nth attr for CTYPE_RTX */
melt_nthattr_maprtxs (struct meltmaprtxs_st *map_s, int ix)
{
  rtx at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTXS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_RTX */

static inline melt_ptr_t /* Map nth value for CTYPE_RTX */
melt_nthval_maprtxs (struct meltmaprtxs_st *map_s, int ix)
{
  rtx at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPRTXS)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_RTX */

/***end of map support for GTY ctype CTYPE_RTX **/

 /*gtyctype #9 CTYPE_TREE */

/***map support for GTY ctype CTYPE_TREE **/
static inline melt_ptr_t /*New map for CTYPE_TREE */
meltgc_new_maptrees (meltobject_ptr_t discr, unsigned len)
{
  /*generated map creation */
  if (melt_magic_discr ((melt_ptr_t) discr) != MELTOBMAG_OBJECT)
    return NULL;
  if (discr->meltobj_magic != MELTOBMAG_MAPTREES)	/* not map magic */
    return NULL;
  return (melt_ptr_t) meltgc_raw_new_mappointers (discr, len);
}				/*end generated new map for CTYPE_TREE */

static inline melt_ptr_t /* Map getter for CTYPE_TREE */
melt_get_maptrees (melt_ptr_t map_p, tree attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPTREES)
    return NULL;
  return melt_raw_get_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map getter for CTYPE_TREE */

static inline void /* Map putter for CTYPE_TREE */
melt_put_maptrees (melt_ptr_t map_p, tree attr, melt_ptr_t valu_p)
{
  if (!map_p || !attr || !valu_p
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPTREES)
    return;
  meltgc_raw_put_mappointers ((void *) map_p, (void *) attr, valu_p);
}				/*end generated map putter for CTYPE_TREE */

static inline void /* Map remover for CTYPE_TREE */
melt_remove_maptrees (melt_ptr_t map_p, tree attr)
{
  if (!map_p || !attr
      || melt_magic_discr ((melt_ptr_t) map_p) != MELTOBMAG_MAPTREES)
    return;
  meltgc_raw_remove_mappointers ((void *) map_p, (void *) attr);
}				/*end generated map remover for CTYPE_TREE */

static inline unsigned /* Map counter for CTYPE_TREE */
melt_count_maptrees (struct meltmaptrees_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPTREES)
    return 0;
  return map_s->count;
}				/*end generated map counter for CTYPE_TREE */

static inline unsigned /* Map size for CTYPE_TREE */
melt_size_maptrees (struct meltmaptrees_st *map_s)
{
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPTREES)
    return 0;
  return melt_primtab[map_s->lenix];
}				/*end generated map size for CTYPE_TREE */

static inline tree /* Map nth attr for CTYPE_TREE */
melt_nthattr_maptrees (struct meltmaptrees_st *map_s, int ix)
{
  tree at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPTREES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return at;
}				/*end generated map nth attr for CTYPE_TREE */

static inline melt_ptr_t /* Map nth value for CTYPE_TREE */
melt_nthval_maptrees (struct meltmaptrees_st *map_s, int ix)
{
  tree at = 0;
  if (!map_s || melt_magic_discr ((melt_ptr_t) map_s) != MELTOBMAG_MAPTREES)
    return 0;
  at = map_s->entab[ix].e_at;
  if ((void *) at == (void *) HTAB_DELETED_ENTRY)
    return 0;
  return map_s->entab[ix].e_va;
}				/*end generated map nth value for CTYPE_TREE */

/***end of map support for GTY ctype CTYPE_TREE **/

 /** end of code generated by generate_runtypesupport_mapfun **/


/*** End of declaration file meltrunsup.h generated on 2011 Sep 12
 * by GCC MELT 4.7.0 20110912 (experimental) [melt-branch revision 178777] MELT_0.9rc1 . ***/
