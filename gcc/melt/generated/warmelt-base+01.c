/* GCC MELT GENERATED FILE warmelt-base+01.c - DO NOT EDIT */
/* secondary MELT generated C file of rank #1 */
#include "melt-run.h"


/* used hash from melt-run.h when compiling this file: */
const char used_meltrun_md5_melt_f1[] =
  MELT_RUN_HASHMD5 /* from melt-run.h */ ;


/**** warmelt-base+01.c declarations ****/
#define MELT_HAS_INITIAL_ENVIRONMENT 1

struct melt_callframe_st;	/*defined in melt-runtime.h */


/**!!** ***
    Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
               and Pierre Vittet  <piervit@pvittet.com>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
*****!!**/




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_1_warmelt_base_COMPARE_NAMED_ALPHA (meltclosure_ptr_t closp_,
					     melt_ptr_t firstargp_,
					     const melt_argdescr_cell_t
					     xargdescr_[],
					     union meltparam_un *xargtab_,
					     const melt_argdescr_cell_t
					     xresdescr_[],
					     union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_2_warmelt_base_MAPSTRING_EVERY (meltclosure_ptr_t closp_,
					 melt_ptr_t firstargp_,
					 const melt_argdescr_cell_t
					 xargdescr_[],
					 union meltparam_un *xargtab_,
					 const melt_argdescr_cell_t
					 xresdescr_[],
					 union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_3_warmelt_base_MAPSTRING_ITERATE_TEST (meltclosure_ptr_t closp_,
						melt_ptr_t firstargp_,
						const melt_argdescr_cell_t
						xargdescr_[],
						union meltparam_un *xargtab_,
						const melt_argdescr_cell_t
						xresdescr_[],
						union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_4_warmelt_base_MULTIPLE_EVERY (meltclosure_ptr_t closp_,
					melt_ptr_t firstargp_,
					const melt_argdescr_cell_t
					xargdescr_[],
					union meltparam_un *xargtab_,
					const melt_argdescr_cell_t
					xresdescr_[],
					union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_5_warmelt_base_MULTIPLE_BACKWARD_EVERY (meltclosure_ptr_t closp_,
						 melt_ptr_t firstargp_,
						 const melt_argdescr_cell_t
						 xargdescr_[],
						 union meltparam_un *xargtab_,
						 const melt_argdescr_cell_t
						 xresdescr_[],
						 union meltparam_un
						 *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_6_warmelt_base_MULTIPLE_EVERY_BOTH (meltclosure_ptr_t closp_,
					     melt_ptr_t firstargp_,
					     const melt_argdescr_cell_t
					     xargdescr_[],
					     union meltparam_un *xargtab_,
					     const melt_argdescr_cell_t
					     xresdescr_[],
					     union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_7_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS (meltclosure_ptr_t
						      closp_,
						      melt_ptr_t firstargp_,
						      const
						      melt_argdescr_cell_t
						      xargdescr_[],
						      union meltparam_un
						      *xargtab_,
						      const
						      melt_argdescr_cell_t
						      xresdescr_[],
						      union meltparam_un
						      *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_8_warmelt_base_REGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
						      closp_,
						      melt_ptr_t firstargp_,
						      const
						      melt_argdescr_cell_t
						      xargdescr_[],
						      union meltparam_un
						      *xargtab_,
						      const
						      melt_argdescr_cell_t
						      xresdescr_[],
						      union meltparam_un
						      *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_9_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				 melt_ptr_t firstargp_,
				 const melt_argdescr_cell_t xargdescr_[],
				 union meltparam_un *xargtab_,
				 const melt_argdescr_cell_t xresdescr_[],
				 union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_10_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un
							 *xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un
							 *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_11_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un *xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_12_warmelt_base_REGISTER_PRAGMA_HANDLER (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un
						  *xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un
						  *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_13_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST (meltclosure_ptr_t
							     closp_,
							     melt_ptr_t
							     firstargp_,
							     const
							     melt_argdescr_cell_t
							     xargdescr_[],
							     union
							     meltparam_un
							     *xargtab_,
							     const
							     melt_argdescr_cell_t
							     xresdescr_[],
							     union
							     meltparam_un
							     *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_14_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST (meltclosure_ptr_t
							    closp_,
							    melt_ptr_t
							    firstargp_,
							    const
							    melt_argdescr_cell_t
							    xargdescr_[],
							    union meltparam_un
							    *xargtab_,
							    const
							    melt_argdescr_cell_t
							    xresdescr_[],
							    union meltparam_un
							    *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_15_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER (meltclosure_ptr_t closp_,
						     melt_ptr_t firstargp_,
						     const
						     melt_argdescr_cell_t
						     xargdescr_[],
						     union meltparam_un
						     *xargtab_,
						     const
						     melt_argdescr_cell_t
						     xresdescr_[],
						     union meltparam_un
						     *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_16_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un *xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_17_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un *xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_18_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un *xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_19_warmelt_base_SET_CONTENT (meltclosure_ptr_t closp_,
				      melt_ptr_t firstargp_,
				      const melt_argdescr_cell_t xargdescr_[],
				      union meltparam_un *xargtab_,
				      const melt_argdescr_cell_t xresdescr_[],
				      union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_20_warmelt_base_INSTALL_VALUE_DESCRIPTOR (meltclosure_ptr_t closp_,
						   melt_ptr_t firstargp_,
						   const melt_argdescr_cell_t
						   xargdescr_[],
						   union meltparam_un
						   *xargtab_,
						   const melt_argdescr_cell_t
						   xresdescr_[],
						   union meltparam_un
						   *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_21_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un
							 *xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un
							 *xrestab_);


void *start_module_melt (void *);

struct frame_start_module_melt_st;
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_0 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_1 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_2 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_3 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_4 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_5 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_6 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_7 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_8 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_9 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_10 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_11 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_12 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_13 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_14 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_15 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_16 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_17 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_18 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_19 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_20 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_21 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_22 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_23 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_24 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_25 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_26 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_27 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_28 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_29 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_30 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_31 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_32 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_33 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_34 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_35 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_36 (struct
							      frame_start_module_melt_st
							      *, char *);
static void forward_or_mark_module_start_frame_warmelt_base (struct
							     melt_callframe_st
							     *fp,
							     int marking);


/**** warmelt-base+01.c implementations ****/




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_5_warmelt_base_MULTIPLE_BACKWARD_EVERY (meltclosure_ptr_t closp_,
						 melt_ptr_t firstargp_,
						 const melt_argdescr_cell_t
						 xargdescr_[],
						 union meltparam_un *xargtab_,
						 const melt_argdescr_cell_t
						 xresdescr_[],
						 union meltparam_un *xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_5_warmelt_base_MULTIPLE_BACKWARD_EVERY_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 5
    void *mcfr_varptr[5];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 5; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 5;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MULTIPLE_BACKWARD_EVERY", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1152:/ getarg");
 /*_.TUP__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MULTIPLE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.TUP__V2*/ meltfptr[1])) ==
       MELTOBMAG_MULTIPLE);;
    MELT_LOCATION ("warmelt-base.melt:1155:/ cond");
    /*cond */ if ( /*_#IS_MULTIPLE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_CLOSURE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) ==
	     MELTOBMAG_CLOSURE);;
	  MELT_LOCATION ("warmelt-base.melt:1156:/ cond");
	  /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*citerblock FOREACH_IN_MULTIPLE_BACKWARD */
		{
		  /* start cit1__EACHTUPBACK: */
		  long cit1__EACHTUPBACK_ln =
		    melt_multiple_length ((melt_ptr_t) /*_.TUP__V2*/
					  meltfptr[1]);
		  long cit1__EACHTUPBACK_ix = 0;
		  for (cit1__EACHTUPBACK_ix = cit1__EACHTUPBACK_ln - 1;
		       cit1__EACHTUPBACK_ix >= 0; cit1__EACHTUPBACK_ix--)
		    {
		      /*_.COMP__V4*/ meltfptr[3] =
			melt_multiple_nth ((melt_ptr_t)
					   ( /*_.TUP__V2*/ meltfptr[1]),
					   cit1__EACHTUPBACK_ix);
   /*_#IX__L3*/ meltfnum[2] = cit1__EACHTUPBACK_ix;


		      MELT_LOCATION ("warmelt-base.melt:1160:/ apply");
		      /*apply */
		      {
			union meltparam_un argtab[1];
			memset (&argtab, 0, sizeof (argtab));
			/*^apply.arg */
			argtab[0].meltbp_long = /*_#IX__L3*/ meltfnum[2];
			/*_.F__V5*/ meltfptr[4] =
			  melt_apply ((meltclosure_ptr_t)
				      ( /*_.F__V3*/ meltfptr[2]),
				      (melt_ptr_t) ( /*_.COMP__V4*/
						    meltfptr[3]),
				      (MELTBPARSTR_LONG ""), argtab, "",
				      (union meltparam_un *) 0);
		      }
		      ;
		    }		/* end cit1__EACHTUPBACK */

		  /*citerepilog */

		  MELT_LOCATION ("warmelt-base.melt:1157:/ clear");
		/*clear *//*_.COMP__V4*/ meltfptr[3] = 0;
		  /*^clear */
		/*clear *//*_#IX__L3*/ meltfnum[2] = 0;
		  /*^clear */
		/*clear *//*_.F__V5*/ meltfptr[4] = 0;
		}		/*endciterblock FOREACH_IN_MULTIPLE_BACKWARD */
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1155:/ clear");
	     /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1152:/ clear");
	   /*clear *//*_#IS_MULTIPLE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MULTIPLE_BACKWARD_EVERY", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_5_warmelt_base_MULTIPLE_BACKWARD_EVERY */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_6_warmelt_base_MULTIPLE_EVERY_BOTH (meltclosure_ptr_t closp_,
					     melt_ptr_t firstargp_,
					     const melt_argdescr_cell_t
					     xargdescr_[],
					     union meltparam_un * xargtab_,
					     const melt_argdescr_cell_t
					     xresdescr_[],
					     union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_6_warmelt_base_MULTIPLE_EVERY_BOTH_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 13
    void *mcfr_varptr[13];
#define MELTFRAM_NBVARNUM 10
    long mcfr_varnum[10];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 13; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 13;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MULTIPLE_EVERY_BOTH", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1164:/ getarg");
 /*_.TUP1__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.TUP2__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])) !=
	      NULL);


  /*getarg#2 */
  /*^getarg */
  if (xargdescr_[1] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V4*/ meltfptr[3] =
    (xargtab_[1].meltbp_aptr) ? (*(xargtab_[1].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V4*/ meltfptr[3])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MULTIPLE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1])) ==
       MELTOBMAG_MULTIPLE);;
    MELT_LOCATION ("warmelt-base.melt:1167:/ cond");
    /*cond */ if ( /*_#IS_MULTIPLE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_MULTIPLE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])) ==
	     MELTOBMAG_MULTIPLE);;
	  MELT_LOCATION ("warmelt-base.melt:1168:/ cond");
	  /*cond */ if ( /*_#IS_MULTIPLE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

     /*_#IS_CLOSURE__L3*/ meltfnum[2] =
		  (melt_magic_discr ((melt_ptr_t) ( /*_.F__V4*/ meltfptr[3]))
		   == MELTOBMAG_CLOSURE);;
		MELT_LOCATION ("warmelt-base.melt:1169:/ cond");
		/*cond */ if ( /*_#IS_CLOSURE__L3*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      MELT_LOCATION ("warmelt-base.melt:1170:/ quasiblock");


       /*_#LN1__L4*/ meltfnum[3] =
			(melt_multiple_length
			 ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1])));;
		      /*^compute */

       /*_#LN2__L5*/ meltfnum[4] =
			(melt_multiple_length
			 ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])));;
		      /*^compute */

       /*_#IX__L6*/ meltfnum[5] = 0;;
		      MELT_LOCATION ("warmelt-base.melt:1173:/ loop");
		      /*loop */
		      {
		      labloop_TUPLOOP_1:;
				/*^loopbody */

			/*^block */
			/*anyblock */
			{

	 /*_#I__L7*/ meltfnum[6] =
			    (( /*_#IX__L6*/ meltfnum[5]) >=
			     ( /*_#LN1__L4*/ meltfnum[3]));;
			  MELT_LOCATION ("warmelt-base.melt:1174:/ cond");
			  /*cond */ if ( /*_#I__L7*/ meltfnum[6])	/*then */
			    {
			      /*^cond.then */
			      /*^block */
			      /*anyblock */
			      {

				/*^quasiblock */


				/*^compute */
	   /*_.TUPLOOP__V10*/ meltfptr[9] = NULL;;

				/*^exit */
				/*exit */
				{
				  goto labexit_TUPLOOP_1;
				}
				;
				/*epilog */
			      }
			      ;
			    }	/*noelse */
			  ;
	 /*_#I__L8*/ meltfnum[7] =
			    (( /*_#IX__L6*/ meltfnum[5]) >=
			     ( /*_#LN2__L5*/ meltfnum[4]));;
			  MELT_LOCATION ("warmelt-base.melt:1175:/ cond");
			  /*cond */ if ( /*_#I__L8*/ meltfnum[7])	/*then */
			    {
			      /*^cond.then */
			      /*^block */
			      /*anyblock */
			      {

				/*^quasiblock */


				/*^compute */
	   /*_.TUPLOOP__V10*/ meltfptr[9] = NULL;;

				/*^exit */
				/*exit */
				{
				  goto labexit_TUPLOOP_1;
				}
				;
				/*epilog */
			      }
			      ;
			    }	/*noelse */
			  ;
	 /*_.MULTIPLE_NTH__V11*/ meltfptr[10] =
			    (melt_multiple_nth
			     ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1]),
			      ( /*_#IX__L6*/ meltfnum[5])));;
			  /*^compute */

	 /*_.MULTIPLE_NTH__V12*/ meltfptr[11] =
			    (melt_multiple_nth
			     ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2]),
			      ( /*_#IX__L6*/ meltfnum[5])));;
			  MELT_LOCATION ("warmelt-base.melt:1176:/ apply");
			  /*apply */
			  {
			    union meltparam_un argtab[2];
			    memset (&argtab, 0, sizeof (argtab));
			    /*^apply.arg */
			    argtab[0].meltbp_aptr =
			      (melt_ptr_t *) & /*_.MULTIPLE_NTH__V12*/
			      meltfptr[11];
			    /*^apply.arg */
			    argtab[1].meltbp_long = /*_#IX__L6*/ meltfnum[5];
			    /*_.F__V13*/ meltfptr[12] =
			      melt_apply ((meltclosure_ptr_t)
					  ( /*_.F__V4*/ meltfptr[3]),
					  (melt_ptr_t) ( /*_.MULTIPLE_NTH__V11*/ meltfptr[10]), (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "", (union meltparam_un *) 0);
			  }
			  ;
	 /*_#I__L9*/ meltfnum[8] =
			    (( /*_#IX__L6*/ meltfnum[5]) + (1));;
			  MELT_LOCATION ("warmelt-base.melt:1177:/ compute");
			  /*_#IX__L6*/ meltfnum[5] =
			    /*_#SETQ___L10*/ meltfnum[9] =
			    /*_#I__L9*/ meltfnum[8];;
			  /*epilog */

			  MELT_LOCATION ("warmelt-base.melt:1173:/ clear");
		   /*clear *//*_#I__L7*/ meltfnum[6] = 0;
			  /*^clear */
		   /*clear *//*_#I__L8*/ meltfnum[7] = 0;
			  /*^clear */
		   /*clear *//*_.MULTIPLE_NTH__V11*/ meltfptr[10] = 0;
			  /*^clear */
		   /*clear *//*_.MULTIPLE_NTH__V12*/ meltfptr[11] = 0;
			  /*^clear */
		   /*clear *//*_.F__V13*/ meltfptr[12] = 0;
			  /*^clear */
		   /*clear *//*_#I__L9*/ meltfnum[8] = 0;
			  /*^clear */
		   /*clear *//*_#SETQ___L10*/ meltfnum[9] = 0;
			}
			;
			;
			goto labloop_TUPLOOP_1;
		      labexit_TUPLOOP_1:;
				/*^loopepilog */
			/*loopepilog */
			/*_.FOREVER___V9*/ meltfptr[8] =
			  /*_.TUPLOOP__V10*/ meltfptr[9];;
		      }
		      ;
		      /*^compute */

		      /*_.LET___V8*/ meltfptr[7] =
			/*_.FOREVER___V9*/ meltfptr[8];;

		      MELT_LOCATION ("warmelt-base.melt:1170:/ clear");
		 /*clear *//*_#LN1__L4*/ meltfnum[3] = 0;
		      /*^clear */
		 /*clear *//*_#LN2__L5*/ meltfnum[4] = 0;
		      /*^clear */
		 /*clear *//*_#IX__L6*/ meltfnum[5] = 0;
		      /*^clear */
		 /*clear *//*_.FOREVER___V9*/ meltfptr[8] = 0;
		      /*_.IF___V7*/ meltfptr[6] = /*_.LET___V8*/ meltfptr[7];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:1169:/ clear");
		 /*clear *//*_.LET___V8*/ meltfptr[7] = 0;
		    }
		    ;
		  }
		else
		  {		/*^cond.else */

      /*_.IF___V7*/ meltfptr[6] = NULL;;
		  }
		;
		/*^compute */

		/*_.IF___V6*/ meltfptr[5] = /*_.IF___V7*/ meltfptr[6];;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1168:/ clear");
	       /*clear *//*_#IS_CLOSURE__L3*/ meltfnum[2] = 0;
		/*^clear */
	       /*clear *//*_.IF___V7*/ meltfptr[6] = 0;
	      }
	      ;
	    }
	  else
	    {			/*^cond.else */

    /*_.IF___V6*/ meltfptr[5] = NULL;;
	    }
	  ;
	  /*^compute */

	  /*_.IF___V5*/ meltfptr[4] = /*_.IF___V6*/ meltfptr[5];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1167:/ clear");
	     /*clear *//*_#IS_MULTIPLE__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IF___V6*/ meltfptr[5] = 0;
	}
	;
      }
    else
      {				/*^cond.else */

  /*_.IF___V5*/ meltfptr[4] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1164:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IF___V5*/ meltfptr[4];;
    MELT_LOCATION ("warmelt-base.melt:1164:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#IS_MULTIPLE__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V5*/ meltfptr[4] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MULTIPLE_EVERY_BOTH", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_6_warmelt_base_MULTIPLE_EVERY_BOTH */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_7_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS (meltclosure_ptr_t
						      closp_,
						      melt_ptr_t firstargp_,
						      const
						      melt_argdescr_cell_t
						      xargdescr_[],
						      union meltparam_un *
						      xargtab_,
						      const
						      melt_argdescr_cell_t
						      xresdescr_[],
						      union meltparam_un *
						      xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_7_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 7
    void *mcfr_varptr[7];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 7; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 7;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("RUN_ALL_PASS_EXECUTION_HOOKS", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1204:/ getarg");
 /*_.HOOKLIST__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.PASSNAME__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.PASSNAME__V3*/ meltfptr[2])) !=
	      NULL);


  /*getarg#2 */
  /*^getarg */
  if (xargdescr_[1] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[1].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    /*citerblock FOREACH_IN_LIST */
    {
      /* start cit1__EACHLIST */
      for ( /*_.CURPAIR__V4*/ meltfptr[3] =
	   melt_list_first ( /*_.HOOKLIST__V2*/ meltfptr[1]);
	   melt_magic_discr ( /*_.CURPAIR__V4*/ meltfptr[3]) ==
	   MELTOBMAG_PAIR;
	   /*_.CURPAIR__V4*/ meltfptr[3] =
	   melt_pair_tail ( /*_.CURPAIR__V4*/ meltfptr[3]))
	{
	  /*_.CURHOOK__V5*/ meltfptr[4] =
	    melt_pair_head ( /*_.CURPAIR__V4*/ meltfptr[3]);


	  MELT_LOCATION ("warmelt-base.melt:1209:/ apply");
	  /*apply */
	  {
	    union meltparam_un argtab[1];
	    memset (&argtab, 0, sizeof (argtab));
	    /*^apply.arg */
	    argtab[0].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
	    /*_.CURHOOK__V6*/ meltfptr[5] =
	      melt_apply ((meltclosure_ptr_t)
			  ( /*_.CURHOOK__V5*/ meltfptr[4]),
			  (melt_ptr_t) ( /*_.PASSNAME__V3*/ meltfptr[2]),
			  (MELTBPARSTR_LONG ""), argtab, "",
			  (union meltparam_un *) 0);
	  }
	  ;
	}			/* end cit1__EACHLIST */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1206:/ clear");
	    /*clear *//*_.CURPAIR__V4*/ meltfptr[3] = 0;
      /*^clear */
	    /*clear *//*_.CURHOOK__V5*/ meltfptr[4] = 0;
      /*^clear */
	    /*clear *//*_.CURHOOK__V6*/ meltfptr[5] = 0;
    }				/*endciterblock FOREACH_IN_LIST */
    ;
    MELT_LOCATION ("warmelt-base.melt:1211:/ quasiblock");


 /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
    MELT_LOCATION ("warmelt-base.melt:1211:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    MELT_LOCATION ("warmelt-base.melt:1204:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.RETURN___V7*/ meltfptr[6];;
    MELT_LOCATION ("warmelt-base.melt:1204:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RETURN___V7*/ meltfptr[6] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("RUN_ALL_PASS_EXECUTION_HOOKS", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_7_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_8_warmelt_base_REGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
						      closp_,
						      melt_ptr_t firstargp_,
						      const
						      melt_argdescr_cell_t
						      xargdescr_[],
						      union meltparam_un *
						      xargtab_,
						      const
						      melt_argdescr_cell_t
						      xresdescr_[],
						      union meltparam_un *
						      xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_8_warmelt_base_REGISTER_PASS_EXECUTION_HOOK_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 17
    void *mcfr_varptr[17];
#define MELTFRAM_NBVARNUM 4
    long mcfr_varnum[4];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 17; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 17;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PASS_EXECUTION_HOOK", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1215:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1221:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  MELT_LOCATION ("warmelt-base.melt:1222:/ quasiblock");


	  /*^getslot */
	  {
	    melt_ptr_t slot = 0;
	    melt_object_get_field (slot, (melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															 /*_.HOOKLIST__V5*/
	    meltfptr[4] = slot;
	  };
	  ;
   /*_#NULL__L2*/ meltfnum[1] =
	    (( /*_.HOOKLIST__V5*/ meltfptr[4]) == NULL);;
	  MELT_LOCATION ("warmelt-base.melt:1225:/ cond");
	  /*cond */ if ( /*_#NULL__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1227:/ blockmultialloc");
		/*multiallocblock */
		{
		  struct meltletrec_1_st
		  {
		    struct meltlist_st rlist_0__LIST_;
		    long meltletrec_1_endgap;
		  } *meltletrec_1_ptr = 0;
		  meltletrec_1_ptr =
		    (struct meltletrec_1_st *)
		    meltgc_allocate (sizeof (struct meltletrec_1_st), 0);
		  /*^blockmultialloc.initfill */
		  /*inilist rlist_0__LIST_ */
       /*_.LIST___V7*/ meltfptr[6] =
		    (void *) &meltletrec_1_ptr->rlist_0__LIST_;
		  meltletrec_1_ptr->rlist_0__LIST_.discr =
		    (meltobject_ptr_t) (((void
					  *) (MELT_PREDEF (DISCR_LIST))));



		  /*_.LIST___V6*/ meltfptr[5] = /*_.LIST___V7*/ meltfptr[6];;
		  /*epilog */

		  MELT_LOCATION ("warmelt-base.melt:1227:/ clear");
		/*clear *//*_.LIST___V7*/ meltfptr[6] = 0;
		  /*^clear */
		/*clear *//*_.LIST___V7*/ meltfptr[6] = 0;
		}		/*end multiallocblock */
		;
		/*^compute */
		/*_.HOOKLIST__V5*/ meltfptr[4] = /*_.SETQ___V8*/ meltfptr[6] =
		  /*_.LIST___V6*/ meltfptr[5];;
		MELT_LOCATION ("warmelt-base.melt:1228:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[1]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg ("putslot checkobj @CONTAINER_VALUE",
				      melt_magic_discr ((melt_ptr_t)
							(( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!PASS_EXECUTION_CONTAINER */
					      meltfrout->tabval[0])), (0),
					    ( /*_.HOOKLIST__V5*/ meltfptr[4]),
					    "CONTAINER_VALUE");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!PASS_EXECUTION_CONTAINER */
				     meltfrout->tabval[0]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		MELT_LOCATION ("warmelt-base.melt:1226:/ quasiblock");


		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1225:/ clear");
	       /*clear *//*_.LIST___V6*/ meltfptr[5] = 0;
		/*^clear */
	       /*clear *//*_.SETQ___V8*/ meltfptr[6] = 0;
	      }
	      ;
	    }			/*noelse */
	  ;

#if MELT_HAVE_DEBUG
	  MELT_LOCATION ("warmelt-base.melt:1229:/ cppif.then");
	  /*^block */
	  /*anyblock */
	  {

     /*_#IS_LIST__L3*/ meltfnum[2] =
	      (melt_magic_discr
	       ((melt_ptr_t) ( /*_.HOOKLIST__V5*/ meltfptr[4])) ==
	       MELTOBMAG_LIST);;
	    MELT_LOCATION ("warmelt-base.melt:1229:/ cond");
	    /*cond */ if ( /*_#IS_LIST__L3*/ meltfnum[2])	/*then */
	      {
		/*^cond.then */
		/*_.IFELSE___V10*/ meltfptr[6] = ( /*nil */ NULL);;
	      }
	    else
	      {
		MELT_LOCATION ("warmelt-base.melt:1229:/ cond.else");

		/*^block */
		/*anyblock */
		{




		  {
		    /*^locexp */
		    melt_assert_failed (("check hooklist"),
					("warmelt-base.melt")
					? ("warmelt-base.melt") : __FILE__,
					(1229) ? (1229) : __LINE__,
					__FUNCTION__);
		    ;
		  }
		  ;
		 /*clear *//*_.IFELSE___V10*/ meltfptr[6] = 0;
		  /*epilog */
		}
		;
	      }
	    ;
	    /*^compute */

	    /*_.IFCPP___V9*/ meltfptr[5] = /*_.IFELSE___V10*/ meltfptr[6];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1229:/ clear");
	       /*clear *//*_#IS_LIST__L3*/ meltfnum[2] = 0;
	    /*^clear */
	       /*clear *//*_.IFELSE___V10*/ meltfptr[6] = 0;
	  }

#else /*MELT_HAVE_DEBUG */
	  /*^cppif.else */
	  /*_.IFCPP___V9*/ meltfptr[5] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
	  ;
	  /*citerblock FOREACH_IN_LIST */
	  {
	    /* start cit1__EACHLIST */
	    for ( /*_.CURPAIR__V11*/ meltfptr[6] =
		 melt_list_first ( /*_.HOOKLIST__V5*/ meltfptr[4]);
		 melt_magic_discr ( /*_.CURPAIR__V11*/ meltfptr[6]) ==
		 MELTOBMAG_PAIR;
		 /*_.CURPAIR__V11*/ meltfptr[6] =
		 melt_pair_tail ( /*_.CURPAIR__V11*/ meltfptr[6]))
	      {
		/*_.CURHOOK__V12*/ meltfptr[11] =
		  melt_pair_head ( /*_.CURPAIR__V11*/ meltfptr[6]);


    /*_#__L4*/ meltfnum[2] =
		  (( /*_.CURHOOK__V12*/ meltfptr[11]) ==
		   ( /*_.FUN__V2*/ meltfptr[1]));;
		MELT_LOCATION ("warmelt-base.melt:1234:/ cond");
		/*cond */ if ( /*_#__L4*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      MELT_LOCATION ("warmelt-base.melt:1235:/ quasiblock");


      /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
		      MELT_LOCATION ("warmelt-base.melt:1235:/ finalreturn");
		      ;
		      /*finalret */ goto labend_rout;
		      /*_.IF___V13*/ meltfptr[12] =
			/*_.RETURN___V14*/ meltfptr[13];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:1234:/ clear");
		/*clear *//*_.RETURN___V14*/ meltfptr[13] = 0;
		    }
		    ;
		  }
		else
		  {		/*^cond.else */

     /*_.IF___V13*/ meltfptr[12] = NULL;;
		  }
		;
	      }			/* end cit1__EACHLIST */

	    /*citerepilog */

	    MELT_LOCATION ("warmelt-base.melt:1231:/ clear");
	      /*clear *//*_.CURPAIR__V11*/ meltfptr[6] = 0;
	    /*^clear */
	      /*clear *//*_.CURHOOK__V12*/ meltfptr[11] = 0;
	    /*^clear */
	      /*clear *//*_#__L4*/ meltfnum[2] = 0;
	    /*^clear */
	      /*clear *//*_.IF___V13*/ meltfptr[12] = 0;
	  }			/*endciterblock FOREACH_IN_LIST */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1237:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.HOOKLIST__V5*/ meltfptr[4]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1240:/ quasiblock");


	  /*^newclosure */
		   /*newclosure *//*_.LAMBDA___V16*/ meltfptr[15] =
	    meltgc_new_closure ((meltobject_ptr_t)
				(((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
				(meltroutine_ptr_t) (( /*!konst_4 */
						      meltfrout->tabval[4])),
				(1));
	  ;
	  /*^putclosedv */
	  /*putclosv */
	  melt_assertmsg ("putclosv checkclo",
			  melt_magic_discr ((melt_ptr_t)
					    ( /*_.LAMBDA___V16*/
					     meltfptr[15])) ==
			  MELTOBMAG_CLOSURE);
	  melt_assertmsg ("putclosv checkoff", 0 >= 0
			  && 0 <
			  melt_closure_size ((melt_ptr_t)
					     ( /*_.LAMBDA___V16*/
					      meltfptr[15])));
	  ((meltclosure_ptr_t) /*_.LAMBDA___V16*/ meltfptr[15])->tabval[0] =
	    (melt_ptr_t) ( /*_.HOOKLIST__V5*/ meltfptr[4]);
	  ;
	  /*_.LAMBDA___V15*/ meltfptr[13] = /*_.LAMBDA___V16*/ meltfptr[15];;
	  MELT_LOCATION ("warmelt-base.melt:1238:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[2])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[2]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[2])), (25),
				      ( /*_.LAMBDA___V15*/ meltfptr[13]),
				      "SYSDATA_PASSEXEC_HOOK");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[2]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1243:/ locexp");
	    /*REGPASSXECHOOK__1 */
	    meltgc_notify_sysdata_passexec_hook ();
	    ;
	  }
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1246:/ quasiblock");


   /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
	  MELT_LOCATION ("warmelt-base.melt:1246:/ finalreturn");
	  ;
	  /*finalret */ goto labend_rout;
	  /*_.LET___V4*/ meltfptr[3] = /*_.RETURN___V17*/ meltfptr[16];;

	  MELT_LOCATION ("warmelt-base.melt:1222:/ clear");
	     /*clear *//*_.HOOKLIST__V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_#NULL__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IFCPP___V9*/ meltfptr[5] = 0;
	  /*^clear */
	     /*clear *//*_.LAMBDA___V15*/ meltfptr[13] = 0;
	  /*^clear */
	     /*clear *//*_.RETURN___V17*/ meltfptr[16] = 0;
	  /*_.IF___V3*/ meltfptr[2] = /*_.LET___V4*/ meltfptr[3];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1221:/ clear");
	     /*clear *//*_.LET___V4*/ meltfptr[3] = 0;
	}
	;
      }
    else
      {				/*^cond.else */

  /*_.IF___V3*/ meltfptr[2] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1215:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IF___V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1215:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PASS_EXECUTION_HOOK", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_8_warmelt_base_REGISTER_PASS_EXECUTION_HOOK */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_9_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				 melt_ptr_t firstargp_,
				 const melt_argdescr_cell_t xargdescr_[],
				 union meltparam_un * xargtab_,
				 const melt_argdescr_cell_t xresdescr_[],
				 union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_9_warmelt_base_LAMBDA__st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1240:/ getarg");
 /*_.PASSNAME__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[0].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1241:/ apply");
    /*apply */
    {
      union meltparam_un argtab[2];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.PASSNAME__V2*/ meltfptr[1];
      /*^apply.arg */
      argtab[1].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!RUN_ALL_PASS_EXECUTION_HOOKS */ meltfrout->
		      tabval[0])),
		    (melt_ptr_t) (( /*~HOOKLIST */ meltfclos->tabval[0])),
		    (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1240:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] =
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1240:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_9_warmelt_base_LAMBDA_ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_10_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un *
							 xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un *
							 xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_10_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 9
    void *mcfr_varptr[9];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 9; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 9;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("UNREGISTER_PASS_EXECUTION_HOOK", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1250:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1253:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  MELT_LOCATION ("warmelt-base.melt:1254:/ quasiblock");


	  /*^getslot */
	  {
	    melt_ptr_t slot = 0;
	    melt_object_get_field (slot, (melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															 /*_.OLDHOOKLIST__V3*/
	    meltfptr[2] = slot;
	  };
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1256:/ blockmultialloc");
	  /*multiallocblock */
	  {
	    struct meltletrec_1_st
	    {
	      struct meltlist_st rlist_0__LIST_;
	      long meltletrec_1_endgap;
	    } *meltletrec_1_ptr = 0;
	    meltletrec_1_ptr =
	      (struct meltletrec_1_st *)
	      meltgc_allocate (sizeof (struct meltletrec_1_st), 0);
	    /*^blockmultialloc.initfill */
	    /*inilist rlist_0__LIST_ */
     /*_.LIST___V5*/ meltfptr[4] =
	      (void *) &meltletrec_1_ptr->rlist_0__LIST_;
	    meltletrec_1_ptr->rlist_0__LIST_.discr =
	      (meltobject_ptr_t) (((void *) (MELT_PREDEF (DISCR_LIST))));



	    /*_.NEWHOOKLIST__V4*/ meltfptr[3] = /*_.LIST___V5*/ meltfptr[4];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1256:/ clear");
	      /*clear *//*_.LIST___V5*/ meltfptr[4] = 0;
	    /*^clear */
	      /*clear *//*_.LIST___V5*/ meltfptr[4] = 0;
	  }			/*end multiallocblock */
	  ;
	  /*citerblock FOREACH_IN_LIST */
	  {
	    /* start cit1__EACHLIST */
	    for ( /*_.CURPAIR__V6*/ meltfptr[4] =
		 melt_list_first ( /*_.OLDHOOKLIST__V3*/ meltfptr[2]);
		 melt_magic_discr ( /*_.CURPAIR__V6*/ meltfptr[4]) ==
		 MELTOBMAG_PAIR;
		 /*_.CURPAIR__V6*/ meltfptr[4] =
		 melt_pair_tail ( /*_.CURPAIR__V6*/ meltfptr[4]))
	      {
		/*_.CURHOOK__V7*/ meltfptr[6] =
		  melt_pair_head ( /*_.CURPAIR__V6*/ meltfptr[4]);


    /*_#__L2*/ meltfnum[1] =
		  (( /*_.CURHOOK__V7*/ meltfptr[6]) !=
		   ( /*_.FUN__V2*/ meltfptr[1]));;
		MELT_LOCATION ("warmelt-base.melt:1261:/ cond");
		/*cond */ if ( /*_#__L2*/ meltfnum[1])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {


		      {
			MELT_LOCATION ("warmelt-base.melt:1262:/ locexp");
			meltgc_append_list ((melt_ptr_t)
					    ( /*_.NEWHOOKLIST__V4*/
					     meltfptr[3]),
					    (melt_ptr_t) ( /*_.CURHOOK__V7*/
							  meltfptr[6]));
		      }
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
	      }			/* end cit1__EACHLIST */

	    /*citerepilog */

	    MELT_LOCATION ("warmelt-base.melt:1258:/ clear");
	      /*clear *//*_.CURPAIR__V6*/ meltfptr[4] = 0;
	    /*^clear */
	      /*clear *//*_.CURHOOK__V7*/ meltfptr[6] = 0;
	    /*^clear */
	      /*clear *//*_#__L2*/ meltfnum[1] = 0;
	  }			/*endciterblock FOREACH_IN_LIST */
	  ;
   /*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2] =
	    (melt_magic_discr
	     ((melt_ptr_t) ( /*_.NEWHOOKLIST__V4*/ meltfptr[3])) ==
	     MELTOBMAG_LIST
	     && NULL !=
	     melt_list_first ((melt_ptr_t)
			      ( /*_.NEWHOOKLIST__V4*/ meltfptr[3])));;
	  MELT_LOCATION ("warmelt-base.melt:1264:/ cond");
	  /*cond */ if ( /*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1265:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[2]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg
			("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
			 melt_magic_discr ((melt_ptr_t)
					   (( /*!INITIAL_SYSTEM_DATA */
					     meltfrout->tabval[1]))) ==
			 MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[1])), (25),
					    (( /*nil */ NULL)),
					    "SYSDATA_PASSEXEC_HOOK");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				     tabval[1]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		/*epilog */
	      }
	      ;
	    }
	  else
	    {
	      MELT_LOCATION ("warmelt-base.melt:1264:/ cond.else");

	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1269:/ quasiblock");


		/*^newclosure */
		     /*newclosure *//*_.LAMBDA___V9*/ meltfptr[8] =
		  meltgc_new_closure ((meltobject_ptr_t)
				      (((void
					 *) (MELT_PREDEF (DISCR_CLOSURE)))),
				      (meltroutine_ptr_t) (( /*!konst_4 */
							    meltfrout->
							    tabval[4])), (1));
		;
		/*^putclosedv */
		/*putclosv */
		melt_assertmsg ("putclosv checkclo",
				melt_magic_discr ((melt_ptr_t)
						  ( /*_.LAMBDA___V9*/
						   meltfptr[8])) ==
				MELTOBMAG_CLOSURE);
		melt_assertmsg ("putclosv checkoff", 0 >= 0
				&& 0 <
				melt_closure_size ((melt_ptr_t)
						   ( /*_.LAMBDA___V9*/
						    meltfptr[8])));
		((meltclosure_ptr_t) /*_.LAMBDA___V9*/ meltfptr[8])->
		  tabval[0] =
		  (melt_ptr_t) ( /*_.NEWHOOKLIST__V4*/ meltfptr[3]);
		;
		/*_.LAMBDA___V8*/ meltfptr[7] =
		  /*_.LAMBDA___V9*/ meltfptr[8];;
		MELT_LOCATION ("warmelt-base.melt:1267:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[2]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg
			("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
			 melt_magic_discr ((melt_ptr_t)
					   (( /*!INITIAL_SYSTEM_DATA */
					     meltfrout->tabval[1]))) ==
			 MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[1])), (25),
					    ( /*_.LAMBDA___V8*/ meltfptr[7]),
					    "SYSDATA_PASSEXEC_HOOK");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				     tabval[1]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1264:/ clear");
	       /*clear *//*_.LAMBDA___V8*/ meltfptr[7] = 0;
	      }
	      ;
	    }
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1272:/ locexp");
	    /*UNREGPASSXECHOOK__1 */
	    meltgc_notify_sysdata_passexec_hook ();
	    ;
	  }
	  ;

	  MELT_LOCATION ("warmelt-base.melt:1254:/ clear");
	     /*clear *//*_.OLDHOOKLIST__V3*/ meltfptr[2] = 0;
	  /*^clear */
	     /*clear *//*_.NEWHOOKLIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2] = 0;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1250:/ clear");
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("UNREGISTER_PASS_EXECUTION_HOOK", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_10_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_11_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un * xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_11_warmelt_base_LAMBDA__st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1269:/ getarg");
 /*_.PASSNAME__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[0].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1270:/ apply");
    /*apply */
    {
      union meltparam_un argtab[2];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.PASSNAME__V2*/ meltfptr[1];
      /*^apply.arg */
      argtab[1].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!RUN_ALL_PASS_EXECUTION_HOOKS */ meltfrout->
		      tabval[0])),
		    (melt_ptr_t) (( /*~NEWHOOKLIST */ meltfclos->tabval[0])),
		    (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1269:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] =
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1269:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_11_warmelt_base_LAMBDA_ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_12_warmelt_base_REGISTER_PRAGMA_HANDLER (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un *
						  xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un *
						  xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_12_warmelt_base_REGISTER_PRAGMA_HANDLER_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 12
    void *mcfr_varptr[12];
#define MELTFRAM_NBVARNUM 14
    long mcfr_varnum[14];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 12; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 12;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRAGMA_HANDLER", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1278:/ getarg");
 /*_.LSTHANDLER__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {


#if MELT_HAVE_DEBUG
    MELT_LOCATION ("warmelt-base.melt:1283:/ cppif.then");
    /*^block */
    /*anyblock */
    {

   /*_#IS_LIST__L1*/ meltfnum[0] =
	(melt_magic_discr ((melt_ptr_t) ( /*_.LSTHANDLER__V2*/ meltfptr[1]))
	 == MELTOBMAG_LIST);;
      MELT_LOCATION ("warmelt-base.melt:1283:/ cond");
      /*cond */ if ( /*_#IS_LIST__L1*/ meltfnum[0])	/*then */
	{
	  /*^cond.then */
	  /*_.IFELSE___V4*/ meltfptr[3] = ( /*nil */ NULL);;
	}
      else
	{
	  MELT_LOCATION ("warmelt-base.melt:1283:/ cond.else");

	  /*^block */
	  /*anyblock */
	  {




	    {
	      /*^locexp */
	      melt_assert_failed (("register_pragma_handler takes a list as argument."), ("warmelt-base.melt") ? ("warmelt-base.melt") : __FILE__, (1283) ? (1283) : __LINE__, __FUNCTION__);
	      ;
	    }
	    ;
	       /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
	    /*epilog */
	  }
	  ;
	}
      ;
      /*^compute */

      /*_.IFCPP___V3*/ meltfptr[2] = /*_.IFELSE___V4*/ meltfptr[3];;
      /*epilog */

      MELT_LOCATION ("warmelt-base.melt:1283:/ clear");
	     /*clear *//*_#IS_LIST__L1*/ meltfnum[0] = 0;
      /*^clear */
	     /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
    }

#else /*MELT_HAVE_DEBUG */
    /*^cppif.else */
    /*_.IFCPP___V3*/ meltfptr[2] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
    ;
    MELT_LOCATION ("warmelt-base.melt:1285:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), 27, "SYSDATA_MELTPRAGMAS");
															/*_.OLDTUPLE__V5*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.OLDTUPLE__V5*/ meltfptr[3] = NULL;;
      }
    ;
    /*^compute */

 /*_#OLDSIZE__L2*/ meltfnum[0] = 0;;
    MELT_LOCATION ("warmelt-base.melt:1287:/ cond");
    /*cond */ if (( /*!NOTNULL */ meltfrout->tabval[2]))	/*then */
      {
	/*^cond.then */
	/*_.IF___V6*/ meltfptr[5] = /*_.OLDTUPLE__V5*/ meltfptr[3];;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1287:/ cond.else");

  /*_.IF___V6*/ meltfptr[5] = NULL;;
      }
    ;
    /*^compute */

 /*_#MULTIPLE_LENGTH__L3*/ meltfnum[2] =
      (melt_multiple_length
       ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3])));;
    MELT_LOCATION ("warmelt-base.melt:1288:/ compute");
    /*_#OLDSIZE__L2*/ meltfnum[0] = /*_#SETQ___L4*/ meltfnum[3] =
      /*_#MULTIPLE_LENGTH__L3*/ meltfnum[2];;
    MELT_LOCATION ("warmelt-base.melt:1289:/ quasiblock");


 /*_#MULTIPLE_LENGTH__L5*/ meltfnum[4] =
      (melt_multiple_length
       ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3])));;
    /*^compute */

 /*_#LIST_LENGTH__L6*/ meltfnum[5] =
      (melt_list_length ((melt_ptr_t) ( /*_.LSTHANDLER__V2*/ meltfptr[1])));;
    /*^compute */

 /*_#NEWSIZE__L7*/ meltfnum[6] =
      (( /*_#MULTIPLE_LENGTH__L5*/ meltfnum[4]) +
       ( /*_#LIST_LENGTH__L6*/ meltfnum[5]));;
    /*^compute */

 /*_.NEWTUPLE__V7*/ meltfptr[6] =
      (meltgc_new_multiple
       ((meltobject_ptr_t) (( /*!DISCR_MULTIPLE */ meltfrout->tabval[3])),
	( /*_#NEWSIZE__L7*/ meltfnum[6])));;
    /*^compute */

 /*_#I__L8*/ meltfnum[7] = 0;;
    /*citerblock FOREACH_IN_MULTIPLE */
    {
      /* start cit1__EACHTUP: */
      long cit1__EACHTUP_ln =
	melt_multiple_length ((melt_ptr_t) /*_.OLDTUPLE__V5*/ meltfptr[3]);
      for ( /*_#IUNUSED__L9*/ meltfnum[8] = 0;
	   ( /*_#IUNUSED__L9*/ meltfnum[8] >= 0)
	   && ( /*_#IUNUSED__L9*/ meltfnum[8] < cit1__EACHTUP_ln);
	/*_#IUNUSED__L9*/ meltfnum[8]++)
	{
	  /*_.CURHANDER__V8*/ meltfptr[7] =
	    melt_multiple_nth ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3]),
			       /*_#IUNUSED__L9*/ meltfnum[8]);




	  {
	    MELT_LOCATION ("warmelt-base.melt:1297:/ locexp");
	    meltgc_multiple_put_nth ((melt_ptr_t)
				     ( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				     ( /*_#I__L8*/ meltfnum[7]),
				     (melt_ptr_t) ( /*_.CURHANDER__V8*/
						   meltfptr[7]));
	  }
	  ;
  /*_#I__L10*/ meltfnum[9] =
	    (( /*_#I__L8*/ meltfnum[7]) + (1));;
	  MELT_LOCATION ("warmelt-base.melt:1298:/ compute");
	  /*_#I__L8*/ meltfnum[7] = /*_#SETQ___L11*/ meltfnum[10] =
	    /*_#I__L10*/ meltfnum[9];;
	  if ( /*_#IUNUSED__L9*/ meltfnum[8] < 0)
	    break;
	}			/* end cit1__EACHTUP */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1294:/ clear");
	    /*clear *//*_.CURHANDER__V8*/ meltfptr[7] = 0;
      /*^clear */
	    /*clear *//*_#IUNUSED__L9*/ meltfnum[8] = 0;
      /*^clear */
	    /*clear *//*_#I__L10*/ meltfnum[9] = 0;
      /*^clear */
	    /*clear *//*_#SETQ___L11*/ meltfnum[10] = 0;
    }				/*endciterblock FOREACH_IN_MULTIPLE */
    ;
    /*citerblock FOREACH_IN_LIST */
    {
      /* start cit2__EACHLIST */
      for ( /*_.CURPAIR__V9*/ meltfptr[8] =
	   melt_list_first ( /*_.LSTHANDLER__V2*/ meltfptr[1]);
	   melt_magic_discr ( /*_.CURPAIR__V9*/ meltfptr[8]) ==
	   MELTOBMAG_PAIR;
	   /*_.CURPAIR__V9*/ meltfptr[8] =
	   melt_pair_tail ( /*_.CURPAIR__V9*/ meltfptr[8]))
	{
	  /*_.CURHANDLER__V10*/ meltfptr[9] =
	    melt_pair_head ( /*_.CURPAIR__V9*/ meltfptr[8]);



#if MELT_HAVE_DEBUG
	  MELT_LOCATION ("warmelt-base.melt:1304:/ cppif.then");
	  /*^block */
	  /*anyblock */
	  {

    /*_#IS_A__L12*/ meltfnum[11] =
	      melt_is_instance_of ((melt_ptr_t)
				   ( /*_.CURHANDLER__V10*/ meltfptr[9]),
				   (melt_ptr_t) (( /*!CLASS_GCC_PRAGMA */
						  meltfrout->tabval[4])));;
	    MELT_LOCATION ("warmelt-base.melt:1304:/ cond");
	    /*cond */ if ( /*_#IS_A__L12*/ meltfnum[11])	/*then */
	      {
		/*^cond.then */
		/*_.IFELSE___V12*/ meltfptr[11] = ( /*nil */ NULL);;
	      }
	    else
	      {
		MELT_LOCATION ("warmelt-base.melt:1304:/ cond.else");

		/*^block */
		/*anyblock */
		{




		  {
		    /*^locexp */
		    melt_assert_failed (("register_pragma_handler must be a list of class_gcc_pragma."), ("warmelt-base.melt") ? ("warmelt-base.melt") : __FILE__, (1304) ? (1304) : __LINE__, __FUNCTION__);
		    ;
		  }
		  ;
		/*clear *//*_.IFELSE___V12*/ meltfptr[11] = 0;
		  /*epilog */
		}
		;
	      }
	    ;
	    /*^compute */

	    /*_.IFCPP___V11*/ meltfptr[10] = /*_.IFELSE___V12*/ meltfptr[11];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1304:/ clear");
	      /*clear *//*_#IS_A__L12*/ meltfnum[11] = 0;
	    /*^clear */
	      /*clear *//*_.IFELSE___V12*/ meltfptr[11] = 0;
	  }

#else /*MELT_HAVE_DEBUG */
	  /*^cppif.else */
	  /*_.IFCPP___V11*/ meltfptr[10] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1306:/ locexp");
	    meltgc_multiple_put_nth ((melt_ptr_t)
				     ( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				     ( /*_#I__L8*/ meltfnum[7]),
				     (melt_ptr_t) ( /*_.CURHANDLER__V10*/
						   meltfptr[9]));
	  }
	  ;
  /*_#I__L13*/ meltfnum[11] =
	    (( /*_#I__L8*/ meltfnum[7]) + (1));;
	  MELT_LOCATION ("warmelt-base.melt:1307:/ compute");
	  /*_#I__L8*/ meltfnum[7] = /*_#SETQ___L14*/ meltfnum[13] =
	    /*_#I__L13*/ meltfnum[11];;
	}			/* end cit2__EACHLIST */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1301:/ clear");
	    /*clear *//*_.CURPAIR__V9*/ meltfptr[8] = 0;
      /*^clear */
	    /*clear *//*_.CURHANDLER__V10*/ meltfptr[9] = 0;
      /*^clear */
	    /*clear *//*_.IFCPP___V11*/ meltfptr[10] = 0;
      /*^clear */
	    /*clear *//*_#I__L13*/ meltfnum[11] = 0;
      /*^clear */
	    /*clear *//*_#SETQ___L14*/ meltfnum[13] = 0;
    }				/*endciterblock FOREACH_IN_LIST */
    ;
    MELT_LOCATION ("warmelt-base.melt:1309:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  /*^putslot */
	  /*putslot */
	  melt_assertmsg ("putslot checkobj @SYSDATA_MELTPRAGMAS",
			  melt_magic_discr ((melt_ptr_t)
					    (( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[0]))) ==
			  MELTOBMAG_OBJECT);
	  melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				  tabval[0])), (27),
				( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				"SYSDATA_MELTPRAGMAS");
	  ;
	  /*^touch */
	  meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0]));
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;

    MELT_LOCATION ("warmelt-base.melt:1289:/ clear");
	   /*clear *//*_#MULTIPLE_LENGTH__L5*/ meltfnum[4] = 0;
    /*^clear */
	   /*clear *//*_#LIST_LENGTH__L6*/ meltfnum[5] = 0;
    /*^clear */
	   /*clear *//*_#NEWSIZE__L7*/ meltfnum[6] = 0;
    /*^clear */
	   /*clear *//*_.NEWTUPLE__V7*/ meltfptr[6] = 0;
    /*^clear */
	   /*clear *//*_#I__L8*/ meltfnum[7] = 0;

    MELT_LOCATION ("warmelt-base.melt:1285:/ clear");
	   /*clear *//*_.OLDTUPLE__V5*/ meltfptr[3] = 0;
    /*^clear */
	   /*clear *//*_#OLDSIZE__L2*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V6*/ meltfptr[5] = 0;
    /*^clear */
	   /*clear *//*_#MULTIPLE_LENGTH__L3*/ meltfnum[2] = 0;
    /*^clear */
	   /*clear *//*_#SETQ___L4*/ meltfnum[3] = 0;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1278:/ clear");
	   /*clear *//*_.IFCPP___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRAGMA_HANDLER", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_12_warmelt_base_REGISTER_PRAGMA_HANDLER */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_13_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST (meltclosure_ptr_t
							     closp_,
							     melt_ptr_t
							     firstargp_,
							     const
							     melt_argdescr_cell_t
							     xargdescr_[],
							     union
							     meltparam_un *
							     xargtab_,
							     const
							     melt_argdescr_cell_t
							     xresdescr_[],
							     union
							     meltparam_un *
							     xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_13_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 6
    void *mcfr_varptr[6];
#define MELTFRAM_NBVARNUM 2
    long mcfr_varnum[2];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 6; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 6;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRE_GENERICIZE_HOOK_FIRST", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1320:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1324:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.FIRSTLIST__V3*/
	  meltfptr[2] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.FIRSTLIST__V3*/ meltfptr[2] = NULL;;
      }
    ;
    /*^compute */

 /*_#NULL__L1*/ meltfnum[0] =
      (( /*_.FIRSTLIST__V3*/ meltfptr[2]) == NULL);;
    MELT_LOCATION ("warmelt-base.melt:1326:/ cond");
    /*cond */ if ( /*_#NULL__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_.MAKE_LIST__V4*/ meltfptr[3] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1328:/ compute");
	  /*_.FIRSTLIST__V3*/ meltfptr[2] = /*_.SETQ___V5*/ meltfptr[4] =
	    /*_.MAKE_LIST__V4*/ meltfptr[3];;
   /*_.MAKE_LIST__V6*/ meltfptr[5] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1329:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_FIRST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (2),
				      ( /*_.FIRSTLIST__V3*/ meltfptr[2]),
				      "DELQU_FIRST");
		;
		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_LAST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (3),
				      ( /*_.MAKE_LIST__V6*/ meltfptr[5]),
				      "DELQU_LAST");
		;
		/*^touch */
		meltgc_touch (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->
			       tabval[0]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1333:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[3])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PRE_GENERICIZE",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[3]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[3])), (21),
				      (( /*!PRE_GENERICIZE_HOOK_RUNNER */
					meltfrout->tabval[4])),
				      "SYSDATA_PRE_GENERICIZE");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[3]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1327:/ quasiblock");


	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1326:/ clear");
	     /*clear *//*_.MAKE_LIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_.SETQ___V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_.MAKE_LIST__V6*/ meltfptr[5] = 0;
	}
	;
      }				/*noelse */
    ;
 /*_#IS_CLOSURE__L2*/ meltfnum[1] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1336:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1337:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.FIRSTLIST__V3*/ meltfptr[2]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1336:/ cond.else");

	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1338:/ locexp");
	    error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter,
		   ("Bad hook passed to register_pre_genericize_hook"));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    ;

    MELT_LOCATION ("warmelt-base.melt:1324:/ clear");
	   /*clear *//*_.FIRSTLIST__V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_#NULL__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRE_GENERICIZE_HOOK_FIRST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_13_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_14_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST (meltclosure_ptr_t
							    closp_,
							    melt_ptr_t
							    firstargp_,
							    const
							    melt_argdescr_cell_t
							    xargdescr_[],
							    union meltparam_un
							    * xargtab_,
							    const
							    melt_argdescr_cell_t
							    xresdescr_[],
							    union meltparam_un
							    * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_14_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 6
    void *mcfr_varptr[6];
#define MELTFRAM_NBVARNUM 2
    long mcfr_varnum[2];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 6; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 6;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRE_GENERICIZE_HOOK_LAST", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1343:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1347:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.LASTLIST__V3*/
	  meltfptr[2] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.LASTLIST__V3*/ meltfptr[2] = NULL;;
      }
    ;
    /*^compute */

 /*_#NULL__L1*/ meltfnum[0] =
      (( /*_.LASTLIST__V3*/ meltfptr[2]) == NULL);;
    MELT_LOCATION ("warmelt-base.melt:1349:/ cond");
    /*cond */ if ( /*_#NULL__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_.MAKE_LIST__V4*/ meltfptr[3] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1351:/ compute");
	  /*_.LASTLIST__V3*/ meltfptr[2] = /*_.SETQ___V5*/ meltfptr[4] =
	    /*_.MAKE_LIST__V4*/ meltfptr[3];;
   /*_.MAKE_LIST__V6*/ meltfptr[5] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1352:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_FIRST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (2),
				      ( /*_.LASTLIST__V3*/ meltfptr[2]),
				      "DELQU_FIRST");
		;
		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_LAST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (3),
				      ( /*_.MAKE_LIST__V6*/ meltfptr[5]),
				      "DELQU_LAST");
		;
		/*^touch */
		meltgc_touch (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->
			       tabval[0]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1356:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[3])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PRE_GENERICIZE",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[3]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[3])), (21),
				      (( /*!PRE_GENERICIZE_HOOK_RUNNER */
					meltfrout->tabval[4])),
				      "SYSDATA_PRE_GENERICIZE");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[3]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1350:/ quasiblock");


	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1349:/ clear");
	     /*clear *//*_.MAKE_LIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_.SETQ___V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_.MAKE_LIST__V6*/ meltfptr[5] = 0;
	}
	;
      }				/*noelse */
    ;
 /*_#IS_CLOSURE__L2*/ meltfnum[1] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1359:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1360:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.LASTLIST__V3*/ meltfptr[2]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1359:/ cond.else");

	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1361:/ locexp");
	    error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter,
		   ("Bad hook passed to register_pre_genericize_hook"));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    ;

    MELT_LOCATION ("warmelt-base.melt:1347:/ clear");
	   /*clear *//*_.LASTLIST__V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_#NULL__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRE_GENERICIZE_HOOK_LAST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_14_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_15_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER (meltclosure_ptr_t closp_,
						     melt_ptr_t firstargp_,
						     const
						     melt_argdescr_cell_t
						     xargdescr_[],
						     union meltparam_un *
						     xargtab_,
						     const
						     melt_argdescr_cell_t
						     xresdescr_[],
						     union meltparam_un *
						     xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_15_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 17
    void *mcfr_varptr[17];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 17; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 17;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("PRE_GENERICIZE_HOOK_RUNNER", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1366:/ getarg");
 /*_.FNDECLV__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1371:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.FIRSTLIST__V4*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.FIRSTLIST__V4*/ meltfptr[3] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1372:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 3, "DELQU_LAST");
														      /*_.LASTLIST__V5*/
	  meltfptr[4] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.LASTLIST__V5*/ meltfptr[4] = NULL;;
      }
    ;
    /*^compute */

 /*_.REVLASTLIST__V6*/ meltfptr[5] =
      (meltgc_new_list
       ((meltobject_ptr_t) (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
    MELT_LOCATION ("warmelt-base.melt:1374:/ quasiblock");


    /*^rawallocobj */
    /*rawallocobj */
    {
      melt_ptr_t newobj = 0;
      melt_raw_object_create (newobj,
			      (melt_ptr_t) (( /*!CLASS_CONTAINER */
					     meltfrout->tabval[3])), (1),
			      "CLASS_CONTAINER");
  /*_.INST__V8*/ meltfptr[7] =
	newobj;
    };
    ;
    /*_.RESCONT__V7*/ meltfptr[6] = /*_.INST__V8*/ meltfptr[7];;
    MELT_LOCATION ("warmelt-base.melt:1379:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V10*/ meltfptr[9] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_5 */ meltfrout->
						tabval[5])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V10*/ meltfptr[9])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V10*/ meltfptr[9])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V10*/ meltfptr[9])->tabval[0] =
      (melt_ptr_t) ( /*_.FNDECLV__V2*/ meltfptr[1]);
    ;
    /*_.LAMBDA___V9*/ meltfptr[8] = /*_.LAMBDA___V10*/ meltfptr[9];;
    MELT_LOCATION ("warmelt-base.melt:1377:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.LAMBDA___V9*/ meltfptr[8];
      /*_.LIST_EVERY__V11*/ meltfptr[10] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.FIRSTLIST__V4*/ meltfptr[3]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1385:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V13*/ meltfptr[12] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_6 */ meltfrout->
						tabval[6])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V13*/ meltfptr[12])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V13*/ meltfptr[12])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V13*/ meltfptr[12])->tabval[0] =
      (melt_ptr_t) ( /*_.REVLASTLIST__V6*/ meltfptr[5]);
    ;
    /*_.LAMBDA___V12*/ meltfptr[11] = /*_.LAMBDA___V13*/ meltfptr[12];;
    MELT_LOCATION ("warmelt-base.melt:1383:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr =
	(melt_ptr_t *) & /*_.LAMBDA___V12*/ meltfptr[11];
      /*_.LIST_EVERY__V14*/ meltfptr[13] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.LASTLIST__V5*/ meltfptr[4]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1390:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V16*/ meltfptr[15] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_7 */ meltfrout->
						tabval[7])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V16*/ meltfptr[15])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V16*/ meltfptr[15])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V16*/ meltfptr[15])->tabval[0] =
      (melt_ptr_t) ( /*_.FNDECLV__V2*/ meltfptr[1]);
    ;
    /*_.LAMBDA___V15*/ meltfptr[14] = /*_.LAMBDA___V16*/ meltfptr[15];;
    MELT_LOCATION ("warmelt-base.melt:1388:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr =
	(melt_ptr_t *) & /*_.LAMBDA___V15*/ meltfptr[14];
      /*_.LIST_EVERY__V17*/ meltfptr[16] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.REVLASTLIST__V6*/ meltfptr[5]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    /*_.LET___V3*/ meltfptr[2] = /*_.LIST_EVERY__V17*/ meltfptr[16];;

    MELT_LOCATION ("warmelt-base.melt:1371:/ clear");
	   /*clear *//*_.FIRSTLIST__V4*/ meltfptr[3] = 0;
    /*^clear */
	   /*clear *//*_.LASTLIST__V5*/ meltfptr[4] = 0;
    /*^clear */
	   /*clear *//*_.REVLASTLIST__V6*/ meltfptr[5] = 0;
    /*^clear */
	   /*clear *//*_.RESCONT__V7*/ meltfptr[6] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V9*/ meltfptr[8] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V11*/ meltfptr[10] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V12*/ meltfptr[11] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V14*/ meltfptr[13] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V15*/ meltfptr[14] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V17*/ meltfptr[16] = 0;
    MELT_LOCATION ("warmelt-base.melt:1366:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.LET___V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1366:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.LET___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("PRE_GENERICIZE_HOOK_RUNNER", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_15_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_16_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un * xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_16_warmelt_base_LAMBDA__st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1379:/ getarg");
 /*_.FIRSTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1380:/ apply");
    /*apply */
    {
      /*_.FIRSTPROC__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t) ( /*_.FIRSTPROC__V2*/ meltfptr[1]),
		    (melt_ptr_t) (( /*~FNDECLV */ meltfclos->tabval[0])),
		    (""), (union meltparam_un *) 0, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1379:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.FIRSTPROC__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1379:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.FIRSTPROC__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_16_warmelt_base_LAMBDA_ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_17_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un * xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_17_warmelt_base_LAMBDA__st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 2
    void *mcfr_varptr[2];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 2; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 2;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1385:/ getarg");
 /*_.LASTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.LASTPROC__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1386:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    /*^locexp */
	    meltgc_prepend_list ((melt_ptr_t)
				 (( /*~REVLASTLIST */ meltfclos->tabval[0])),
				 (melt_ptr_t) ( /*_.LASTPROC__V2*/
					       meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1385:/ clear");
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_17_warmelt_base_LAMBDA_ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_18_warmelt_base_LAMBDA_ (meltclosure_ptr_t closp_,
				  melt_ptr_t firstargp_,
				  const melt_argdescr_cell_t xargdescr_[],
				  union meltparam_un * xargtab_,
				  const melt_argdescr_cell_t xresdescr_[],
				  union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_18_warmelt_base_LAMBDA__st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1390:/ getarg");
 /*_.LASTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1391:/ apply");
    /*apply */
    {
      /*_.LASTPROC__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t) ( /*_.LASTPROC__V2*/ meltfptr[1]),
		    (melt_ptr_t) (( /*~FNDECLV */ meltfclos->tabval[0])),
		    (""), (union meltparam_un *) 0, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1390:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.LASTPROC__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1390:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.LASTPROC__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_18_warmelt_base_LAMBDA_ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_19_warmelt_base_SET_CONTENT (meltclosure_ptr_t closp_,
				      melt_ptr_t firstargp_,
				      const melt_argdescr_cell_t xargdescr_[],
				      union meltparam_un * xargtab_,
				      const melt_argdescr_cell_t xresdescr_[],
				      union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_19_warmelt_base_SET_CONTENT_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("SET_CONTENT", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1435:/ getarg");
 /*_.C__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.V__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.V__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1438:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) ( /*_.C__V2*/ meltfptr[1]), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[0]))))	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  /*^putslot */
	  /*putslot */
	  melt_assertmsg ("putslot checkobj @CONTAINER_VALUE",
			  melt_magic_discr ((melt_ptr_t)
					    ( /*_.C__V2*/ meltfptr[1])) ==
			  MELTOBMAG_OBJECT);
	  melt_putfield_object (( /*_.C__V2*/ meltfptr[1]), (0),
				( /*_.V__V3*/ meltfptr[2]),
				"CONTAINER_VALUE");
	  ;
	  /*^touch */
	  meltgc_touch ( /*_.C__V2*/ meltfptr[1]);
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("SET_CONTENT", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_19_warmelt_base_SET_CONTENT */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_20_warmelt_base_INSTALL_VALUE_DESCRIPTOR (meltclosure_ptr_t closp_,
						   melt_ptr_t firstargp_,
						   const melt_argdescr_cell_t
						   xargdescr_[],
						   union meltparam_un *
						   xargtab_,
						   const melt_argdescr_cell_t
						   xresdescr_[],
						   union meltparam_un *
						   xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_20_warmelt_base_INSTALL_VALUE_DESCRIPTOR_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 5
    void *mcfr_varptr[5];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 5; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 5;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("INSTALL_VALUE_DESCRIPTOR", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1447:/ getarg");
 /*_.VD__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {


#if MELT_HAVE_DEBUG
    MELT_LOCATION ("warmelt-base.melt:1448:/ cppif.then");
    /*^block */
    /*anyblock */
    {

   /*_#IS_A__L1*/ meltfnum[0] =
	melt_is_instance_of ((melt_ptr_t) ( /*_.VD__V2*/ meltfptr[1]),
			     (melt_ptr_t) (( /*!CLASS_VALUE_DESCRIPTOR */
					    meltfrout->tabval[0])));;
      MELT_LOCATION ("warmelt-base.melt:1448:/ cond");
      /*cond */ if ( /*_#IS_A__L1*/ meltfnum[0])	/*then */
	{
	  /*^cond.then */
	  /*_.IFELSE___V4*/ meltfptr[3] = ( /*nil */ NULL);;
	}
      else
	{
	  MELT_LOCATION ("warmelt-base.melt:1448:/ cond.else");

	  /*^block */
	  /*anyblock */
	  {




	    {
	      /*^locexp */
	      melt_assert_failed (("check vd"),
				  ("warmelt-base.melt")
				  ? ("warmelt-base.melt") : __FILE__,
				  (1448) ? (1448) : __LINE__, __FUNCTION__);
	      ;
	    }
	    ;
	       /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
	    /*epilog */
	  }
	  ;
	}
      ;
      /*^compute */

      /*_.IFCPP___V3*/ meltfptr[2] = /*_.IFELSE___V4*/ meltfptr[3];;
      /*epilog */

      MELT_LOCATION ("warmelt-base.melt:1448:/ clear");
	     /*clear *//*_#IS_A__L1*/ meltfnum[0] = 0;
      /*^clear */
	     /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
    }

#else /*MELT_HAVE_DEBUG */
    /*^cppif.else */
    /*_.IFCPP___V3*/ meltfptr[2] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
    ;
    MELT_LOCATION ("warmelt-base.melt:1449:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[2]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[1])), 0, "CONTAINER_VALUE");
															       /*_.CONTAINER_VALUE__V5*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.CONTAINER_VALUE__V5*/ meltfptr[3] = NULL;;
      }
    ;

    {
      MELT_LOCATION ("warmelt-base.melt:1449:/ locexp");
      meltgc_append_list ((melt_ptr_t)
			  ( /*_.CONTAINER_VALUE__V5*/ meltfptr[3]),
			  (melt_ptr_t) ( /*_.VD__V2*/ meltfptr[1]));
    }
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1447:/ clear");
	   /*clear *//*_.IFCPP___V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_.CONTAINER_VALUE__V5*/ meltfptr[3] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("INSTALL_VALUE_DESCRIPTOR", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_20_warmelt_base_INSTALL_VALUE_DESCRIPTOR */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_21_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un *
							 xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un *
							 xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_21_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 2
    void *mcfr_varptr[2];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 2; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 2;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("RETRIEVE_VALUE_DESCRIPTOR_LIST", meltcallcount);
/*getargs*/
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
  MELT_LOCATION ("warmelt-base.melt:1452:/ block");
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1453:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															       /*_.CONTAINER_VALUE__V2*/
	  meltfptr[1] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.CONTAINER_VALUE__V2*/ meltfptr[1] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1452:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.CONTAINER_VALUE__V2*/ meltfptr[1];;
    MELT_LOCATION ("warmelt-base.melt:1452:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.CONTAINER_VALUE__V2*/ meltfptr[1] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("RETRIEVE_VALUE_DESCRIPTOR_LIST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_21_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST */



/**** end of warmelt-base+01.c ****/
